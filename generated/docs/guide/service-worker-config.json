{
  "id" : "guide/service-worker-config",
  "title" : "服务工作者配置",
  "contents" : "<div class=\"content\">\n<a id=\"glob\"></a>\n<h1 id=\"service-worker-configuration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dyzvipjjtbw1xl7d15hia25ag\"><i class=\"material-icons\">link</i>服务工作者配置</h1>\n<h4 id=\"prerequisites\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e44b21uig1fakj5vcfuvz1bdu\"><i class=\"material-icons\">link</i>先决条件</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xq8keqzpcinu80uje7xu3rbf\">对以下内容的基本了解：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3iyhol8jsafrwwg3fbgeoz1jt\"><a href=\"guide/service-worker-devops\">生产环境中的服务工作者</a>.</li>\n</ul>\n<hr>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amyzggh79xbl4jk8zhbujiupy\"><code>src/ngsw-config.json</code> 配置文件指定了 Angular 服务工作者应缓存哪些文件和数据 URL，以及它应如何更新缓存的文件和数据。CLI 在 \n<code>ng build --prod</code> 期间处理配置文件。手动操作时，可以使用 \n<code>ngsw-config</code> 工具处理它：</p>\n<code-example language=\"sh\">\nngsw-config dist src/ngsw-config.json /base/href\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nxh15qfxe3r2iqomb3n4iyx5\">配置文件使用 JSON 格式。所有文件路径必须以 \n<code>/</code> 开头，这是部署目录——通常是 CLI 项目中的 \n<code>dist</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4h7kr1t0t6drvcvk5yf28hld7\">模式使用有限的 glob 格式：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93y7l43amqi7bgebk1d4lgy44\"><code>**</code> 匹配 0 个或多个路径段。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3t1mxjp2l246aj118nrmap820\"><code>*</code> 匹配正好一个路径段或文件名段。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zgqriv0soix9qsftxf5bivk8\"><code>!</code> 前缀将模式标记为负数，这意味着只有不匹配模式的文件才会被包含。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c7jrdcy64rnb4z051flnifjd8\">范例模式：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3qjizl4fpykyz86yyck2d5nx\"><code>/**/*.html</code> 指定所有 HTML 文件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jxey2lr4iyog1t546do5jjhh\"><code>/*.html</code> 仅指定根目录中的 HTML 文件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71w9oxip0wtj76y18ggx6w6ba\"><code>!/**/*.map</code> 排除所有源映射。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4mp77pn67jzrimjlbj9lhxd4a\">配置文件的每个部分将在下面描述。</p>\n<h2 id=\"appdata\"><code>appData</code></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"fuo2umeakedlvxfwydcqr4v3\">此部分使你能够传递任何你想要的数据，这些数据描述了此特定版本的应用。 \n<code><a href=\"api/service-worker/SwUpdate\" class=\"code-anchor\">SwUpdate</a></code> 服务在更新通知中包含这些数据。许多应用使用此部分为 UI 弹出窗口的显示提供更多信息，通知用户可用的更新。</p>\n<h2 id=\"index\"><code>index</code></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bkstwo4g4qx5elhvbet49ahfj\">指定用作索引页面的文件，以满足导航请求。通常这是 \n<code>/index.html</code>。</p>\n<h2 id=\"assetgroups\"><code>assetGroups</code></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zs49snrbkeh3lsjvqqm2r32g\"><em>资产</em> 是应用版本的一部分，它们与应用一起更新。它们可以包括从页面的来源加载的资源，以及从 CDN 和其他外部 URL 加载的第三方资源。由于并非所有此类外部 URL 都可能在构建时已知，因此可以匹配 URL 模式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"33jvqpjqsyzt31w1a50k84ms5\">该字段包含一个资产组的数组，每个资产组中会定义一组资产资源和它们的缓存策略。</p>\n<code-example language=\"json\">\n{\n  \"assetGroups\": [{\n    ...\n  }, {\n    ...\n  }]\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqoclkp6c3vurgj6t9w3ho2np\">每个资产组都指定了一组资源和一个管理它们的策略。此策略决定何时获取资源以及在检测到更改时会发生什么。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"asulkzv2i7y4o7p8f266gibb6\">这些资产组会遵循下面的 Typescript 接口：</p>\n<code-example language=\"typescript\">\ninterface AssetGroup {\n  name: string;\n  installMode?: 'prefetch' | 'lazy';\n  updateMode?: 'prefetch' | 'lazy';\n  resources: {\n    files?: string[];\n    versionedFiles?: string[];\n    urls?: string[];\n  };\n}\n</code-example>\n<h3 id=\"name\"><code>name</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5winsjfxrmozz651zavcs1230\"><code>name</code> 是必需的。它在配置的不同版本之间标识此特定资产组。</p>\n<h3 id=\"installmode\"><code>installMode</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"566gijkqd3acg817ab770x0gn\"><code>installMode</code> 决定如何最初缓存这些资源。\n<code>installMode</code> 可以是以下两个值之一：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"etkgo1m537semmzwm8hlhn2x8\"><code>prefetch</code> 告诉 Angular 服务工作者在缓存应用的当前版本时获取每个列出的资源。这会占用大量带宽，但可以确保资源在请求时始终可用，即使浏览器当前处于脱机状态。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afos0kj7wdh56tznr6x0fcj9r\"><code>lazy</code> 不会预先缓存任何资源。相反，Angular 服务工作者只缓存它收到请求的资源。这是一种按需缓存模式。从未请求的资源将不会被缓存。这对于不同分辨率的图像等内容很有用，因此服务工作者只缓存特定屏幕和方向的正确资产。</p>\n</li>\n</ul>\n<h3 id=\"updatemode\"><code>updateMode</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"57fvkq4ous3lelac4zfbpawbp\">对于已在缓存中的资源，\n<code>updateMode</code> 决定在发现应用的新版本时缓存行为。组中自上一个版本以来已更改的任何资源都将根据 \n<code>updateMode</code> 进行更新。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fzankxt8me4m0f44q15ryfqp\"><code>prefetch</code> 告诉服务工作者立即下载并缓存更改的资源。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hd9lvfnmfc5e83cc5n66tds\"><code>lazy</code> 告诉服务工作者不要缓存这些资源。相反，它将它们视为未请求的资源，并在再次请求它们之前等待更新它们。如果 \n<code>installMode</code> 也是 \n<code>lazy</code>，则 \n<code>updateMode</code> 为 \n<code>lazy</code> 才是有效的。</p>\n</li>\n</ul>\n<h3 id=\"resources\"><code>resources</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3l3nq6oh6z5qhhggn6d3pktll\">此部分描述了要缓存的资源，分为三个组。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2b3actvts0zgb9hm76aw1zwye\"><code>files</code> 列出了与分发目录中的文件匹配的模式。这些可以是单个文件，也可以是与多个文件匹配的类似 glob 的模式。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"646ldbc6qn85n7rp9sfb1b7h6\"><code>versionedFiles</code> 与 \n<code>files</code> 相似，但应用于已在文件名中包含哈希的构建工件，这些哈希用于缓存清除。如果 Angular 服务工作者可以假设文件内容是不可变的，它可以优化其操作的某些方面。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4tyt23kmm96imkwe6id3yukf4\"><code>urls</code> 包括将在运行时匹配的 URL 和 URL 模式。这些资源不会直接获取，并且没有内容哈希，但它们将根据其 HTTP 标头进行缓存。这对于 CDN（如 Google Fonts 服务）最有用。</p>\n</li>\n</ul>\n<h2 id=\"datagroups\"><code>dataGroups</code></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1liwao8vto0tdrv1z40lqjywr\">与资产资源不同，数据请求不会与应用一起进行版本控制。它们根据手动配置的策略进行缓存，这些策略更适合 API 请求和其他数据依赖项等情况。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2znl13r1uxaihn1fyg1atkdn9\">数据组遵循下列 TypeScript 接口：</p>\n<code-example language=\"typescript\">\nexport interface DataGroup {\n  name: string;\n  urls: string[];\n  version?: number;\n  cacheConfig: {\n    maxSize: number;\n    maxAge: string;\n    timeout?: string;\n    strategy?: 'freshness' | 'performance';\n  };\n}\n</code-example>\n<h3 id=\"name-1\"><code>name</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2iklz5oz51cczset112nchql1\">和 <code>assetGroups</code> 下类似，每个数据组也都有一个 <code>name</code>，用作它的唯一标识。</p>\n<h3 id=\"urls\"><code>urls</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amt6ccdkq2gz83b1iytibd13z\">URL 模式的列表。与这些模式匹配的 URL 将根据此数据组的策略进行缓存。</p>\n<h3 id=\"version\"><code>version</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8fi60y5gqo5c8ih5z0ctlf8yb\">有时，API 会以不向后兼容的方式更改格式。新版本的应用可能与旧的 API 格式不兼容，因此可能与来自该 API 的现有缓存资源不兼容。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsr4a7ylx932bpvg4kouxczfg\"><code>version</code> 提供了一种机制来指示正在缓存的资源已以不向后兼容的方式更新，并且应丢弃旧的缓存条目——来自先前版本的条目。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dji0f15i3fjavk1lgctxkfk3b\"><code>version</code> 是一个整数字段，默认为 \n<code>0</code>。</p>\n<h3 id=\"cacheconfig\"><code>cacheConfig</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ev9jo41e0177bn9gmegvt1hm1\">此部分定义了匹配请求将被缓存的策略。</p>\n<h4 id=\"maxsize\"><code>maxSize</code></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sxolcobl777lru4wxz7puo5s\">(必需) 缓存中条目的最大数量或响应。开放式缓存可以无限制地增长，最终超过存储配额，需要进行逐出。</p>\n<h4 id=\"maxage\"><code>maxAge</code></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dxq808gx73lisdfjv7cp8n2vs\">(必需) \n<code>maxAge</code> 参数指示响应在被视为无效并逐出之前允许在缓存中保留多长时间。\n<code>maxAge</code> 是一个持续时间字符串，使用以下单位后缀：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csngglypk230ggk13dbby8uy9\"><code>d</code>: 天</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8za5z25sh7md4i8eoordcm2xf\"><code>h</code>: 小时</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ctr9cwf11sfae56vn6s096owb\"><code>m</code>: 分钟</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82qnbcm5te3byuz06rpih55x7\"><code>s</code>: 秒</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1lkmv15sdo7qquk0c2f6d1ka4\"><code>u</code>: 毫秒</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zy6ydo9byv32sxslg06auun6\">例如，字符串 \n<code>3d12h</code> 将缓存内容最多三天半。</p>\n<h4 id=\"timeout\"><code>timeout</code></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5m5r1mhtekzk0rn9vy86k2cdz\">此持续时间字符串指定网络超时时间。网络超时时间是指 Angular 服务工作者在使用缓存响应（如果已配置）之前等待网络响应的时间。</p>\n<h4 id=\"strategy\"><code>strategy</code></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"cw4f35rkafgr2jkd3gt9khcsg\">Angular Service Worker 可以使用两种缓存策略之一来获取数据资源。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dku00xt30bwv6bku2uxj5etpn\"><code>performance</code>（默认）针对尽可能快的响应进行优化。如果缓存中存在资源，则使用缓存版本。这允许一定程度的陈旧性（取决于 \n<code>maxAge</code>），以换取更好的性能。这适用于不经常更改的资源；例如，用户头像图像。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"456g3kixb2dogh66vcab78lpy\"><code>freshness</code> 针对数据的最新性进行优化，优先从网络获取请求的数据。只有在网络超时（根据 \n<code>timeout</code>）时，请求才会回退到缓存。这适用于经常更改的资源；例如，帐户余额。</p>\n</li>\n</ul>\n\n</div>\n<!-- links to this doc:\n - guide/service-worker-devops\n-->\n<!-- links from this doc:\n - api/service-worker/SwUpdate\n - guide/service-worker-config#appdata\n - guide/service-worker-config#assetgroups\n - guide/service-worker-config#cacheconfig\n - guide/service-worker-config#datagroups\n - guide/service-worker-config#index\n - guide/service-worker-config#installmode\n - guide/service-worker-config#maxage\n - guide/service-worker-config#maxsize\n - guide/service-worker-config#name\n - guide/service-worker-config#name-1\n - guide/service-worker-config#prerequisites\n - guide/service-worker-config#resources\n - guide/service-worker-config#service-worker-configuration\n - guide/service-worker-config#strategy\n - guide/service-worker-config#timeout\n - guide/service-worker-config#updatemode\n - guide/service-worker-config#urls\n - guide/service-worker-config#version\n - guide/service-worker-devops\n-->"
}