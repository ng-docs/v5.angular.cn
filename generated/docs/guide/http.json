{
  "id" : "guide/http",
  "title" : "HttpClient",
  "contents" : "<div class=\"content\">\n<h1 id=\"httpclient\">HttpClient</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du59a5lajvgctexfkt4b98gzj\">大多数前端应用程序通过 HTTP 协议与后端服务通信。现代浏览器支持两种不同的 API 来发出 HTTP 请求：\n<code>XMLHttpRequest</code> 接口和 \n<code>fetch()</code> API。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vkzizq9bfi380786fv76uaem\"><code>@angular/common/http</code> 中的 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 为 Angular 应用程序提供了一个简化的客户端 HTTP API，它基于浏览器公开的 \n<code>XMLHttpRequest</code> 接口。\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的其他优势包括可测试性功能、类型化的请求和响应对象、请求和响应拦截、\n<code>Observable</code> API 以及简化的错误处理。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqenzz09iqzkk7fi6ioos6ccn\">你可以运行与本指南配套的 \n<live-example></live-example>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egbherlw42lttuee7acguw35\">示例应用程序不需要数据服务器。它依赖于 \n<a href=\"https://github.com/angular/in-memory-web-api/blob/master/README.md\">Angular <em>in-memory-web-api</em></a>， 它替换了 \n<em>HttpClient</em> 模块的 \n<code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>。 替换服务模拟了类似 REST 的后端的行为。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7us96wwm852g7awbe1zdhda7u\">查看 \n<code>AppModule</code> 的\n<em>导入</em>，以了解它是如何配置的。</p>\n</div>\n<h2 id=\"setup\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a90a9lk5ukrzn7bkuyktmp1zv\"><i class=\"material-icons\">link</i>设置</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rqxh0ole0v38u1juev4227m5\">在你可以使用 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 之前，你需要导入 Angular 的 \n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>。 大多数应用程序在根 \n<code>AppModule</code> 中这样做。</p>\n<code-example path=\"http/src/app/app.module.ts\" region=\"sketch\" title=\"app/app.module.ts (excerpt)\" linenums=\"false\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }         from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }    from '@angular/platform-browser';\nimport { <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> } from '@angular/common/http';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    // import <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a> after BrowserModule.\n    <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  ],\n  declarations: [\n    AppComponent,\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71uuiups6uaqa95r2377yrlof\">将 \n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 导入到 \n<code>AppModule</code> 后，你就可以将 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 注入到应用程序类中，如下面的 \n<code>ConfigService</code> 示例所示。</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"proto\" title=\"app/config/config.service.ts (excerpt)\" linenums=\"false\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> } from '@angular/common/http';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class ConfigService {\n  constructor(private http: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>) { }\n}\n\n</code-example>\n<h2 id=\"getting-json-data\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ds5e5cxmzq4uyprvmquddt0fw\"><i class=\"material-icons\">link</i>获取 JSON 数据</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5c3gsdn5p59c9k29z6boijs9r\">应用程序通常从服务器请求 JSON 数据。例如，该应用程序可能需要服务器上的配置文件 \n<code>config.json</code>， 它指定资源 URL。</p>\n<code-example path=\"http/src/assets/config.json\" title=\"assets/config.json\" linenums=\"false\">\n{\n  \"heroesUrl\": \"api/heroes\",\n  \"textfile\": \"assets/textfile.txt\"\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"coyahkcpmg089dmmu3gamzwn\"><code>ConfigService</code> 使用 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 上的 \n<code>get()</code> 方法获取此文件。</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfig_1\" title=\"app/config/config.service.ts (getConfig v.1)\" linenums=\"false\">\nconfigUrl = 'assets/config.json';\n\ngetConfig() {\n  return this.http.get(this.configUrl);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nb9vryff35divg0dhbffwmkc\">组件（例如 \n<code>ConfigComponent</code>）注入 \n<code>ConfigService</code> 并调用 \n<code>getConfig</code> 服务方法。</p>\n<code-example path=\"http/src/app/config/config.component.ts\" region=\"v1\" title=\"app/config/config.component.ts (showConfig v.1)\" linenums=\"false\">\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(data =&gt; this.config = {\n        heroesUrl: data['heroesUrl'],\n        textfile:  data['textfile']\n    });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3dqrbthfv6jb8v0p5lf6vwi5n\">由于服务方法返回配置数据的 \n<code>Observable</code>， 因此该组件\n<strong>订阅</strong>了该方法的返回值。 订阅回调将数据字段复制到组件的 \n<code>config</code> 对象中， 该对象在组件模板中进行数据绑定以供显示。</p>\n<h3 id=\"why-write-a-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cptqbuwt6a3l2hjsghbwmab5b\"><i class=\"material-icons\">link</i>为什么要编写服务</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fcss8h4bjl7y87ng30qa5j5s\">此示例非常简单，以至于很想直接在 组件本身中编写 \n<code><a href=\"api/http/Http#get\" class=\"code-anchor\">Http.get()</a></code> 并跳过服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8b4i3yamstwu1dkvogi0i5z8e\">但是，数据访问很少保持这种简单性。你通常会对数据进行后处理，添加错误处理，以及可能的一些重试逻辑来 应对间歇性连接。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kdxbwya4oufj1b4gv1tp0w4t\">该组件很快就会因数据访问细节而变得杂乱无章。该组件变得难以理解，难以测试，并且数据访问逻辑无法重用或标准化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ucrqpg6vovn1dohaua74phv0\">这就是为什么将数据呈现与数据访问分离，通过 将数据访问封装在单独的服务中并在 组件中委托给该服务，即使在像这样简单的案例中也是最佳实践。</p>\n<h3 id=\"type-checking-the-response\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"95r55gbfv4vhysppao8ht6n2m\"><i class=\"material-icons\">link</i>类型检查响应</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"xmh3t3nhovv3wcqxe3pxay9i\">上面的订阅回调需要使用方括号表示法来提取数据值。</p>\n<code-example path=\"http/src/app/config/config.component.ts\" region=\"v1_callback\" linenums=\"false\">\n.subscribe(data =&gt; this.config = {\n    heroesUrl: data['heroesUrl'],\n    textfile:  data['textfile']\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsm4orkwxshp2qkdilbcgmhsq\">你不能写 \n<code>data.heroesUrl</code>，因为 TypeScript 正确地抱怨服务中的 \n<code>data</code> 对象没有 \n<code>heroesUrl</code> 属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2f9r5j56rr6v9sm01ejdrmtsb\"><code><a href=\"\" class=\"code-anchor\">HttpClient.get()</a></code> 方法将 JSON 服务器响应解析为匿名 \n<code>Object</code> 类型。它不知道该对象的形状是什么。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fbhans9vh441sv1lqwmzgffj\">你可以告诉 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 响应的类型，以使使用输出更容易、更明显。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9un9kf53mb3u63vqamvyfg153\">首先，定义一个具有正确形状的接口：</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"config-interface\" linenums=\"false\">\nexport interface Config {\n  heroesUrl: string;\n  textfile: string;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjf4x5h0sdilapgnzwsb79y20\">然后，在服务中将该接口指定为 \n<code><a href=\"\" class=\"code-anchor\">HttpClient.get()</a></code> 调用的类型参数：</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfig_2\" title=\"app/config/config.service.ts (getConfig v.2)\" linenums=\"false\">\ngetConfig() {\n  // now returns an Observable of Config\n  return this.http.get&lt;Config&gt;(this.configUrl);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eyadenb50ghu6k9qmilv8sb9q\">更新后的组件方法中的回调接收一个类型化的数据对象，该对象 更容易、更安全地使用：</p>\n<code-example path=\"http/src/app/config/config.component.ts\" region=\"v2\" title=\"app/config/config.component.ts (showConfig v.2)\" linenums=\"false\">\nconfig: Config;\n\nshowConfig() {\n  this.configService.getConfig()\n    // clone the data object, using its known Config shape\n    .subscribe(data =&gt; this.config = { ...data });\n}\n\n</code-example>\n<h3 id=\"reading-the-full-response\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"577uv3zv9fpcd3mn40yo8niz9\"><i class=\"material-icons\">link</i>读取完整响应</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36k1idu94r1rg2ortob3fpc2c\">响应主体不会返回你可能需要的所有数据。有时服务器会返回特殊的标头或状态码，以指示对应用程序工作流程很重要的某些条件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aprthcdd3cg44a0tuiyg1xm2l\">告诉 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 你想要使用 \n<code>observe</code> 选项获取完整的响应：</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfigResponse\" linenums=\"false\">\ngetConfigResponse(): Observable&lt;<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;&gt; {\n  return this.http.get&lt;Config&gt;(\n    this.configUrl, { observe: 'response' });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93gtbzpemcf1bgpf5is1qxzng\">现在 \n<code><a href=\"\" class=\"code-anchor\">HttpClient.get()</a></code> 返回一个类型为 \n<code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 的可观察者，而不是仅仅返回 JSON 数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efe0aypg6w12eecx77by282oi\">组件的 \n<code>showConfigResponse()</code> 方法会显示响应标头以及配置：</p>\n<code-example path=\"http/src/app/config/config.component.ts\" region=\"showConfigResponse\" title=\"app/config/config.component.ts (showConfigResponse)\" linenums=\"false\">\nshowConfigResponse() {\n  this.configService.getConfigResponse()\n    // resp is of type `<a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;Config&gt;`\n    .subscribe(resp =&gt; {\n      // display its headers\n      const keys = resp.headers.keys();\n      this.headers = keys.map(key =&gt;\n        `${key}: ${resp.headers.get(key)}`);\n\n      // access the body directly, which is typed as `Config`.\n      this.config = { ... resp.body };\n    });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwtspcanbqzl0h2qirj0q20iz\">如你所见，响应对象具有一个类型正确的 \n<code>body</code> 属性。</p>\n<h2 id=\"error-handling\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad0cx4y7txhii62pgdd0mpma9\"><i class=\"material-icons\">link</i>错误处理</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yb3md5v700zpbsudhi1vugna\">如果请求在服务器上失败，或者网络连接不良导致请求无法到达服务器，会发生什么？\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 会返回一个\n<em>错误</em>对象，而不是成功的响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wjeyrymmvb0tq2yzrd674uwu\">你\n<em>可以</em>通过在 \n<code>.subscribe()</code> 中添加第二个回调来处理它：</p>\n<code-example path=\"http/src/app/config/config.component.ts\" region=\"v3\" title=\"app/config/config.component.ts (showConfig v.3 with error handling)\" linenums=\"false\">\nshowConfig() {\n  this.configService.getConfig()\n    .subscribe(\n      data =&gt; this.config = { ...data }, // success path\n      error =&gt; this.error = error // error path\n    );\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4nynhjlu5lkseeopwl9hw1yjk\">当数据访问失败时，向用户提供某种反馈当然是一个好主意。 但是，显示 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 返回的原始错误对象远非最佳做法。</p>\n<a id=\"error-details\"></a>\n<h3 id=\"getting-error-details\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cdetyz85wywdpa5mjokblbx1z\"><i class=\"material-icons\">link</i>获取错误详细信息</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2z62ly3ohdnbu1opxndyxt6t4\">检测到错误是一回事。 解释该错误并编写用户友好的响应则更复杂一些。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5stiso3enb9de5aoqtunsoz6f\">可能会发生两种类型的错误。服务器后端可能会拒绝请求，返回一个带有状态码（例如 404 或 500）的 HTTP 响应。这些是错误\n<em>响应</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5f043hlxgsz4iqk7pgs6dneby\">或者，客户端可能会出现问题，例如阻止请求成功完成的网络错误，或者在 RxJS 操作符中抛出的异常。这些错误会生成 JavaScript \n<code>ErrorEvent</code> 对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b3s81bf7dis90l1uk5ur29wui\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 会在其 \n<code><a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a></code> 中捕获这两种类型的错误，你可以检查该响应以找出真正发生了什么。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bxpk8huh3u63o5968uthstg3x\">错误检查、解释和解决是在\n<em>服务</em>中进行的， 而不是在\n<em>组件</em>中进行的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aka0ull3rzhmvlb16mlxsay8p\">你可能首先会设计一个像这样的错误处理程序：</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"handleError\" title=\"app/config/config.service.ts (handleError)\" linenums=\"false\">\nprivate handleError(error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) {\n  if (error.error instanceof ErrorEvent) {\n    // A client-side or network error occurred. Handle it accordingly.\n    console.error('An error occurred:', error.error.message);\n  } else {\n    // The backend returned an unsuccessful response code.\n    // The response body may contain clues as to what went wrong,\n    console.error(\n      `Backend returned code ${error.status}, ` +\n      `body was: ${error.error}`);\n  }\n  // return an ErrorObservable with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> user-facing error message\n  return new ErrorObservable(\n    'Something bad happened; please try again later.');\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebutwjf4fioqpotzikxusjzxj\">请注意，此处理程序会返回一个带有用户友好的错误消息的 RxJS \n<a href=\"guide/http#rxjs\"><code>ErrorObservable</code></a>。 服务的使用者希望服务方法返回某种类型的可观察者， 即使是“错误”的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zkge1p4i03w52mjv72poblja\">现在，你将 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法返回的可观察者 \n<em>通过管道</em>传递到错误处理程序。</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfig_3\" title=\"app/config/config.service.ts (getConfig v.3 with error handler)\" linenums=\"false\">\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl)\n    .pipe(\n      catchError(this.handleError)\n    );\n}\n\n</code-example>\n<h3 id=\"retry\"><code>retry()</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13hsuc3prgu0cg0hx22f4n1i3\">有时错误是暂时的，如果你重试，它会自动消失。 例如，网络中断在移动场景中很常见，重试 可能会产生成功的结果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8v9iabwhfrgiro02vqx0rz9ic\"><a href=\"guide/http#rxjs\">RxJS 库</a> 提供了几个值得探索的\n<em>重试</em>操作符。 最简单的一个叫做 \n<code>retry()</code>，它会自动重新订阅失败的可观察者指定次数。\n<em>重新订阅</em> \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法调用的结果会重新发出 HTTP 请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4md4hd3990v383o2u5qy7hld5\">在错误处理程序之前，将其\n<em>管道</em>连接到 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法结果上。</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"getConfig\" title=\"app/config/config.service.ts (getConfig with retry)\" linenums=\"false\">\ngetConfig() {\n  return this.http.get&lt;Config&gt;(this.configUrl)\n    .pipe(\n      retry(3), // retry <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> failed request up to 3 times\n      catchError(this.handleError) // then handle the error\n    );\n}\n\n</code-example>\n<a id=\"rxjs\"></a>\n<h2 id=\"observables-and-operators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vc2pa3lbofnqatac7h3cwk4f\"><i class=\"material-icons\">link</i>可观察者和操作符</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvucyn8d33fr47902e7nxlocu\">本指南的前面部分提到了 RxJS \n<code>Observables</code> 和操作符，例如 \n<code>catchError</code> 和 \n<code>retry</code>。 当你继续往下看时，你会遇到更多 RxJS 构件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ars5ecct0zc7sfzrh3ofhqsdr\"><a href=\"http://reactivex.io/rxjs/\">RxJS</a> 是一个用于以\n<em>函数式、响应式风格</em>编写异步和基于回调的代码的库。 许多 Angular API（包括 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>）都会生成和使用 RxJS \n<code>Observables</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"834twqf9gbkc2nubge4ffsuvs\">RxJS 本身不在本指南的范围内。你可以在网上找到许多学习资源。 虽然你可以用最少的 RxJS 知识来应付，但随着时间的推移，你需要提高 RxJS 技能，才能有效地使用 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"btjdmx2ntvenb69mugiwdi5xx\">如果你正在按照这些代码片段进行操作，请注意，你必须导入这些代码片段中出现的 RxJS 可观察者和操作符符号。这些 \n<code>ConfigService</code> 导入是典型的。</p>\n<code-example path=\"http/src/app/config/config.service.ts\" region=\"rxjs-imports\" title=\"app/config/config.service.ts (RxJS imports)\" linenums=\"false\">\nimport { Observable } from 'rxjs/Observable';\nimport { ErrorObservable } from 'rxjs/observable/ErrorObservable';\nimport { catchError, retry } from 'rxjs/operators';\n\n</code-example>\n<h2 id=\"requesting-non-json-data\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2liweikz0qti118vp2vze6gwn\"><i class=\"material-icons\">link</i>请求非 JSON 数据</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c03azcqcoiha5iy6qtp4iuy06\">并非所有 API 都返回 JSON 数据。在下一个示例中， \n<code>DownloaderService</code> 方法从服务器读取一个文本文件， 并记录文件内容，然后将这些内容作为 \n<code>Observable&lt;string&gt;</code> 返回给调用者。</p>\n<code-example path=\"http/src/app/downloader/downloader.service.ts\" region=\"getTextFile\" title=\"app/downloader/downloader.service.ts (getTextFile)\" linenums=\"false\">\ngetTextFile(filename: string) {\n  // The Observable returned by get() is of type Observable&lt;string&gt;\n  // because <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> text response was specified.\n  // There's no need to pass <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> &lt;string&gt; type parameter to get().\n  return this.http.get(filename, {responseType: 'text'})\n    .pipe(\n      tap( // Log the result or error\n        data =&gt; this.log(filename, data),\n        error =&gt; this.logError(filename, error)\n      )\n    );\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6g5bny9zko49n411walpgj3e\">由于 \n<code>responseType</code> 选项，\n<code><a href=\"\" class=\"code-anchor\">HttpClient.get()</a></code> 返回一个字符串，而不是默认的 JSON。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e97obg2sbdftn97yytkut6uwr\">RxJS \n<code>tap</code> 操作符（如“窃听”）允许代码检查通过可观察者传递的良好值和错误值，而不会干扰它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ny1ciobxw199jkqh7rjg3ndg\"><code>DownloaderComponent</code> 中的 \n<code>download()</code> 方法通过订阅服务方法来启动请求。</p>\n<code-example path=\"http/src/app/downloader/downloader.component.ts\" region=\"download\" title=\"app/downloader/downloader.component.ts (download)\" linenums=\"false\">\ndownload() {\n  this.downloaderService.getTextFile('assets/textfile.txt')\n    .subscribe(results =&gt; this.contents = results);\n}\n\n</code-example>\n<h2 id=\"sending-data-to-the-server\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9pgxqgq0omgaoj5zb672gjo0x\"><i class=\"material-icons\">link</i>向服务器发送数据</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d75p358ow0nf3ecezfcfogx7\">除了从服务器获取数据之外，\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 还支持修改请求，即使用其他 HTTP 方法（如 PUT、POST 和 DELETE）向服务器发送数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5m4hganp7tl2tsksue4dv0uim\">本指南的示例应用程序包含“英雄之旅”示例的简化版本， 该示例会获取英雄，并允许用户添加、删除和更新英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7oedvknrsu9a22h27j19886d8\">以下部分摘录了示例 \n<code>HeroesService</code> 的方法。</p>\n<h3 id=\"adding-headers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7i6ogpz39sojdt92lx2v815vm\"><i class=\"material-icons\">link</i>添加标头</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"w1jedhra7rg93abbr24o750x\">许多服务器需要额外的标头才能执行保存操作。 例如，它们可能需要一个“Content-Type”标头来明确声明 请求主体的 MIME 类型。 或者，服务器可能需要一个授权令牌。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hz7y05grtic9m14pd1o0ucxm\"><code>HeroesService</code> 在一个 \n<code>httpOptions</code> 对象中定义了这些标头，这些标头将传递 给每个 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 保存方法。</p>\n<code-example path=\"http/src/app/heroes/heroes.service.ts\" region=\"http-options\" title=\"app/heroes/heroes.service.ts (httpOptions)\" linenums=\"false\">\nimport { <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a> } from '@angular/common/http';\n\nconst httpOptions = {\n  headers: new <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a>({\n    'Content-Type':  'application/json',\n    'Authorization': 'my-auth-token'\n  })\n};\n\n</code-example>\n<h3 id=\"making-a-post-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0og7yx67e9jud9m87y89ryjg\"><i class=\"material-icons\">link</i>发出 POST 请求</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"deewhxfgo39po7ts7u4lujrf5\">应用程序通常会将数据 POST 到服务器。它们在提交表单时会 POST。 在以下示例中，\n<code>HeroService</code> 在将英雄添加到数据库时会 POST。</p>\n<code-example path=\"http/src/app/heroes/heroes.service.ts\" region=\"addHero\" title=\"app/heroes/heroes.service.ts (addHero)\" linenums=\"false\">\n/** POST: add <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> new hero to the database */\naddHero (hero: Hero): Observable&lt;Hero&gt; {\n  return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, httpOptions)\n    .pipe(\n      catchError(this.handleError('addHero', hero))\n    );\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rh7y9aroqkq1oqjrgl8d1or6\"><code><a href=\"\" class=\"code-anchor\">HttpClient.post()</a></code> 方法类似于 \n<code>get()</code>，因为它有一个类型参数 （你希望服务器返回新的英雄） 并且它接受一个资源 URL。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"512n5yx0diyqtz6ohk2mhc6yd\">它接受两个额外的参数：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c9zyjqjy8l6q7ujbwq4ole95a\"><code>hero</code> - 要在请求主体中 POST 的数据。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"269hedm37orfjzhdmuogdc05p\"><code>httpOptions</code> - 方法选项，在本例中，\n<a href=\"guide/http#adding-headers\">指定了所需的标头</a>。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2kr9aghqmorhli91gznqplscm\">当然，它会以与\n<a href=\"guide/http#error-details\">上面描述的</a>相同的方式捕获错误。 它还会\n<em>窃听</em>返回的可观察者，以便记录成功的 POST。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jd4bu30rb1lj0fm8mfjehxov\"><code>HeroesComponent</code> 通过订阅 此服务方法返回的可观察者来启动实际的 POST 操作。</p>\n<code-example path=\"http/src/app/heroes/heroes.component.ts\" region=\"add-hero-subscribe\" title=\"app/heroes/heroes.component.ts (addHero)\" linenums=\"false\">\nthis.heroesService.addHero(newHero)\n  .subscribe(hero =&gt; this.heroes.push(hero));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rqxl83k0qmxqrko8kkq9qxpt\">当服务器成功响应并返回新添加的英雄时，组件会将 该英雄添加到显示的 \n<code>heroes</code> 列表中。</p>\n<h3 id=\"making-a-delete-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9plwwe780r0ouyvfyzgjg9zwm\"><i class=\"material-icons\">link</i>发出 DELETE 请求</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0ikl6dw1ek84w2uu8d3l084i\">此应用程序通过在请求 URL 中传递英雄的 ID 来使用 \n<code>HttpClient.delete</code> 方法删除英雄。</p>\n<code-example path=\"http/src/app/heroes/heroes.service.ts\" region=\"deleteHero\" title=\"app/heroes/heroes.service.ts (deleteHero)\" linenums=\"false\">\n/** DELETE: delete the hero from the server */\ndeleteHero (id: number): Observable&lt;{}&gt; {\n  const url = `${this.heroesUrl}/${id}`; // DELETE api/heroes/42\n  return this.http.delete(url, httpOptions)\n    .pipe(\n      catchError(this.handleError('deleteHero'))\n    );\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"11bpcqydklzhsozl34oai3bmv\"><code>HeroesComponent</code> 通过订阅此服务方法返回的 \n<code>Observable</code> 来启动实际的 DELETE 操作。</p>\n<code-example path=\"http/src/app/heroes/heroes.component.ts\" region=\"delete-hero-subscribe\" title=\"app/heroes/heroes.component.ts (deleteHero)\" linenums=\"false\">\nthis.heroesService.deleteHero(hero.id).subscribe();\n\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bewh8y8of5ovu2su38f0fq8ap\">你必须调用 \n<em>subscribe()</em>，否则什么都不会发生！</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dpz83tjdgry12gjc2kbchxprp\">此组件不期望从删除操作中获得结果，并且在没有回调的情况下订阅。 仅仅 \n<code>.subscribe()</code> \n<em>看起来</em>毫无意义。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66s1na58ydlzsu9ke2vhdq8lq\">事实上，它至关重要。 仅仅调用 \n<code>HeroService.deleteHero()</code> \n<strong>不会启动 DELETE 请求。</strong></p>\n<code-example path=\"http/src/app/heroes/heroes.component.ts\" region=\"delete-hero-no-subscribe\" linenums=\"false\">\n// oops ... subscribe() is missing so nothing happens\nthis.heroesService.deleteHero(hero.id);\n\n</code-example>\n<a id=\"always-subscribe\"></a>\n<h3 id=\"always-subscribe\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fayifp5rrvpv47lb821ya65g\"><i class=\"material-icons\">link</i>始终 \n<em>订阅</em>！</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azocda0wwhlrozesk02dgwhq5\"><code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法只有在你调用该方法返回的可观察者上的 \n<code>subscribe()</code> 时才会开始其 HTTP 请求。这对于 \n<em>所有</em> \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> \n<em>方法</em> 都是如此。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlw6gbf8wkl9a9l7qsj5wav67\"><a href=\"api/common/AsyncPipe\"><code>AsyncPipe</code></a> 会自动为你订阅（和取消订阅）。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6krza6fun3jngv7sh80mlcogy\">从 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法返回的所有可观察者在设计上都是 \n<em>冷的</em>。 HTTP 请求的执行是 \n<em>延迟的</em>，允许你在实际发生任何事情之前，使用 \n<code>tap</code> 和 \n<code>catchError</code> 等附加操作来扩展可观察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"140mbdcp2l5pe4i1ydo7eqxe8\">调用 \n<code>subscribe(...)</code> 会触发可观察者的执行，并导致 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 编写并发送 HTTP 请求到服务器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzeoaoyq7jj1us4w1p3l4m07q\">你可以将这些可观察者视为实际 HTTP 请求的 \n<em>蓝图</em>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41urw8apt765irjkf3ton8x1\">事实上，每个 \n<code>subscribe()</code> 都会启动可观察者的独立执行。 订阅两次会导致两个 HTTP 请求。</p>\n<code-example language=\"javascript\">\nconst req = http.get&lt;Heroes&gt;('/api/heroes');\n// 0 requests made - .subscribe() not called.\nreq.subscribe();\n// 1 request made.\nreq.subscribe();\n// 2 requests made.\n</code-example>\n</div>\n<h3 id=\"making-a-put-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ectguozdew4vznri7rn4pc0s\"><i class=\"material-icons\">link</i>发出 PUT 请求</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nk7ld2lyea6v3t16hhbk5hwt\">应用会发送 PUT 请求，以用更新的数据完全替换资源。 以下 \n<code>HeroService</code> 示例与 POST 示例类似。</p>\n<code-example path=\"http/src/app/heroes/heroes.service.ts\" region=\"updateHero\" title=\"app/heroes/heroes.service.ts (updateHero)\" linenums=\"false\">\n/** PUT: update the hero on the server. Returns the updated hero upon success. */\nupdateHero (hero: Hero): Observable&lt;Hero&gt; {\n  return this.http.put&lt;Hero&gt;(this.heroesUrl, hero, httpOptions)\n    .pipe(\n      catchError(this.handleError('updateHero', hero))\n    );\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7d82c5glzemhdxcchvgp43rsy\">由于 \n<a href=\"guide/http#always-subscribe\">上述原因</a>，调用者（在本例中为 \n<code>HeroesComponent.update()</code>）必须 \n<code>subscribe()</code> 到从 \n<code><a href=\"\" class=\"code-anchor\">HttpClient.put()</a></code> 返回的可观察者，以便启动请求。</p>\n<h2 id=\"advanced-usage\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gd65ch73e5dlt8vvl62cb4wy\"><i class=\"material-icons\">link</i>高级用法</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"clrd0lcmj8h3sxmzgs5rqyeau\">以上部分详细介绍了如何在 \n<code>@angular/common/http</code> 中使用基本的 HTTP 功能，但有时你需要做的不仅仅是发出简单的请求并获取数据。</p>\n<h3 id=\"configuring-the-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chy3p7flmjz8glhvpbw9s3km4\"><i class=\"material-icons\">link</i>配置请求</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ca8hy6qlmsarm92t2ub5qnk9o\">可以通过作为最后一个参数传递给 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法的选项对象来配置传出请求的其他方面。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nktplasdv0luzksgoiu1o3j2\">你 \n<a href=\"guide/http#adding-headers\">之前看到过</a>，\n<code>HeroService</code> 通过 将选项对象（\n<code>httpOptions</code>）传递给其保存方法来设置默认标头。 你可以做更多。</p>\n<h4 id=\"update-headers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"abw9q21wk4xi7hqk8aohoq8b0\"><i class=\"material-icons\">link</i>更新标头</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1srs7b76rwxmoe7gayrxnxuzi\">你不能直接修改先前选项对象中的现有标头，因为 \n<code><a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a></code> 类的实例是不可变的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvztnsgqvg13wy9yzmsn9sama\">改用 \n<code>set()</code> 方法。 它会返回当前实例的克隆，并应用新的更改。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7bhkxmoc1vpr5rghbem3yeq4o\">以下是如何在发出下一个请求之前更新授权标头（在旧令牌过期后）。</p>\n<code-example path=\"http/src/app/heroes/heroes.service.ts\" region=\"update-headers\" linenums=\"false\">\nhttpOptions.headers =\n  httpOptions.headers.set('Authorization', 'my-new-auth-token');\n\n</code-example>\n<h4 id=\"url-parameters\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3etsuh4f4xnjxd1ao7jcc83xs\"><i class=\"material-icons\">link</i>URL 参数</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jzk7gjo0gg01adght9apexoe\">添加 URL 搜索参数的工作方式类似。 以下是一个 \n<code>searchHeroes</code> 方法，它查询名称包含搜索词的英雄。</p>\n<code-example path=\"http/src/app/heroes/heroes.service.ts\" region=\"searchHeroes\" linenums=\"false\">\n/* GET heroes whose name contains search term */\nsearchHeroes(term: string): Observable&lt;Hero[]&gt; {\n  term = term.trim();\n\n  // Add safe, URL encoded search parameter if there is <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> search term\n  const options = term ?\n   { params: new <a href=\"api/common/http/HttpParams\" class=\"code-anchor\">HttpParams</a>().set('name', term) } : {};\n\n  return this.http.get&lt;Hero[]&gt;(this.heroesUrl, options)\n    .pipe(\n      catchError(this.handleError&lt;Hero[]&gt;('searchHeroes', []))\n    );\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6skiyzwhe4mxtk3ys5qz1y4qp\">如果有搜索词，代码会使用 HTML URL 编码的搜索参数构造一个选项对象。如果该词为“foo”，则 GET 请求 URL 将为 \n<code>api/heroes/?name=foo</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6bvjl2b39lezj6jtn1racv1p2\"><code>HttpParms</code> 是不可变的，因此你必须使用 \n<code>set()</code> 方法来更新选项。</p>\n<h3 id=\"debouncing-requests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"294al60e5i5rclod3i3j6z9me\"><i class=\"material-icons\">link</i>对请求进行去抖动</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3s92xf062khfybvyjt5n7wzb\">该示例包含一个 \n<em>npm 包搜索</em> 功能。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wu366ddxqwsetsfpk59ao9w9\">当用户在搜索框中输入名称时，\n<code>PackageSearchComponent</code> 会 向 NPM 网页 API 发送一个包含该名称的包的搜索请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2l4w038ceg7j0r9n2qlz4vj6w\">以下是模板中的相关摘录：</p>\n<code-example path=\"http/src/app/package-search/package-search.component.html\" region=\"search\" title=\"app/package-search/package-search.component.html (search)\">\n&lt;input (keyup)=\"search($event.target.value)\" id=\"name\" placeholder=\"Search\"/&gt;\n\n&lt;ul&gt;\n  &lt;li *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let package of packages$ | <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>\"&gt;\n    &lt;b&gt;{{package.name}} v.{{package.version}}&lt;/b&gt; -\n    &lt;i&gt;{{package.description}}&lt;/i&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6rdynzq9djv93taoojfz3388\"><code>(keyup)</code> 事件绑定会将每个按键发送到组件的 \n<code>search()</code> 方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4n94gla1te22xocuk2hrpr0am\">对每个按键都发送请求可能会很昂贵。 最好等到用户停止输入后再发送请求。 这很容易用 RxJS 操作符实现，如以下摘录所示。</p>\n<code-example path=\"http/src/app/package-search/package-search.component.ts\" region=\"debounce\" title=\"app/package-search/package-search.component.ts (excerpt))\">\nwithRefresh = false;\npackages$: Observable&lt;NpmPackageInfo[]&gt;;\nprivate searchText$ = new Subject&lt;string&gt;();\n\nsearch(packageName: string) {\n  this.searchText$.next(packageName);\n}\n\nngOnInit() {\n  this.packages$ = this.searchText$.pipe(\n    debounceTime(500),\n    distinctUntilChanged(),\n    switchMap(packageName =&gt;\n      this.searchService.search(packageName, this.withRefresh))\n  );\n}\n\nconstructor(private searchService: PackageSearchService) { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ees6pbvqi6y19podg622dz00g\"><code>searchText$</code> 是来自用户的搜索框值的序列。 它被定义为 RxJS \n<code>Subject</code>，这意味着它是一个 \n<code>Observable</code>， 它也可以通过调用 \n<code>next(value)</code> 为自身生成值， 就像在 \n<code>search()</code> 方法中一样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kyq5zi9zk28mfbaboekjz0sy\">代码在 \n<code>ngOnInit()</code> 中没有直接将每个 \n<code>searchText</code> 值转发到注入的 \n<code>PackageSearchService</code>， 而是通过三个操作符 \n<em>管道</em> 传递搜索值：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b31yedibny1x8vacfoodclhjw\"><code>debounceTime(500)</code> - 等待用户停止输入（在本例中为 1/2 秒）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bg65103kpzmqa58q6b8hk991v\"><code>distinctUntilChanged()</code> - 等待搜索文本发生更改。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vujqnww4fx664rbpg8e893au\"><code>switchMap()</code> - 将搜索请求发送到服务。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"atnetwzpk2maodyrsfemkr1v7\">代码将 \n<code>packages$</code> 设置为此重新组合的搜索结果 \n<code>Observable</code>。 模板使用 \n<a href=\"api/common/AsyncPipe\">AsyncPipe</a> 订阅 \n<code>packages$</code>， 并在搜索结果到达时显示它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e393r8hktw41c4fbcp8864ier\">只有当搜索值为新值且用户已停止输入时，搜索值才会到达服务。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6jr9jqz0b916e048gqk9vjutx\"><code>withRefresh</code> 选项将在 \n<a href=\"guide/http#cache-refresh\">下面</a> 解释。</p>\n</div>\n<h4 id=\"switchmap\"><em>switchMap()</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38ugm5zigyuhjg53ekfhr6m69\"><code>switchMap()</code> 操作符具有三个重要特征。</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bt997kepwrx2mau82xwca1whr\">它接受一个返回 \n<code>Observable</code> 的函数参数。 \n<code>PackageSearchService.search</code> 返回一个 \n<code>Observable</code>，就像其他数据服务方法一样。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9p5j0z23ghzning0wbi9e59gw\">如果先前的搜索请求仍在 \n<em>进行中</em>（例如，当连接不良时）， 它会取消该请求并发送一个新的请求。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nyq1e0aohu255dpyo8lcghck\">它会按原始请求顺序返回服务响应，即使服务器以不同顺序返回它们。</p>\n</li>\n</ol>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6dl1f7hmrb8agb1bof643wf\">如果你认为你会重复使用此去抖动逻辑， 请考虑将其移到实用程序函数或 \n<code>PackageSearchService</code> 本身中。</p>\n</div>\n<h3 id=\"intercepting-requests-and-responses\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1szr5kcshvbhrx1ocr5v7rkp2\"><i class=\"material-icons\">link</i>拦截请求和响应</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"by7d7q4tgyozek1kc9wv43wg6\"><em>HTTP 拦截</em> 是 \n<code>@angular/common/http</code> 的一项主要功能。 通过拦截，你可以声明 \n<em>拦截器</em>，这些拦截器会检查和转换来自你的应用到服务器的 HTTP 请求。 相同的拦截器也可以检查和转换服务器响应，这些响应在返回到应用的途中。 多个拦截器形成一个 \n<em>向前和向后</em> 的请求/响应处理程序链。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efiorg6fqlv32p7l1x5wtobhm\">拦截器可以以常规的标准方式，为每个 HTTP 请求/响应执行各种\n<em>隐式</em>任务，从身份验证到日志记录。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c30j5kvpqvdg7htl160edrie7\">如果没有拦截，开发人员就必须为每个 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法调用\n<em>显式</em>实现这些任务。</p>\n<h4 id=\"write-an-interceptor\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6hs5o0k6qes19lgb31jsmg06x\"><i class=\"material-icons\">link</i>编写拦截器</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5zpizc1itoc7ljr0gs6z3kqw7\">要实现拦截器，请声明一个实现 \n<code><a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a></code> 接口的 \n<code>intercept()</code> 方法的类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhiqdy1r4pwy3l55r77676jbk\">这是一个什么也不做的\n<em>空操作</em>拦截器，它只是将请求原样传递，不做任何处理： \n<code-example path=\"http/src/app/http-interceptors/noop-interceptor.ts\" title=\"app/http-interceptors/noop-interceptor.ts\" linenums=\"false\">\n  import { \n <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core'; import { \n <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>, \n <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a>, \n <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>, \n <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a> } from '@angular/common/http'; import { Observable } from 'rxjs/Observable'; /** Pass untouched request through to the next request handler. */ @\n <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>() export class NoopInterceptor implements \n <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> { intercept(req: \n <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: \n <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>): Observable&lt;\n <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; { return next.handle(req); } } \n</code-example></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6clzbrgjlgpxs81va2wnwt4nq\"><code>intercept</code> 方法将请求转换为一个 \n<code>Observable</code>，最终返回 HTTP 响应。 从这个意义上说，每个拦截器都完全有能力独立处理请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zjviznggnoh3wfhxlwqj57nu\">大多数拦截器会检查传入的请求，并将（可能已修改的）请求转发到实现 \n<code><a href=\"api/common/http/HttpHandler\"><code>HttpHandler</code></a></code> 接口的 \n<code>next</code> 对象的 \n<code>handle()</code> 方法。</p>\n<code-example language=\"javascript\">\nexport abstract class <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a> {\n  abstract handle(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt;;\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aws66pvk9fnvlv60qa2wj2jgp\">与 \n<code>intercept()</code> 一样，\n<code>handle()</code> 方法将 HTTP 请求转换为 \n<code><a href=\"guide/http#httpevents\"><code>HttpEvents</code></a></code> 的 \n<code>Observable</code>，最终包含服务器的响应。\n<code>intercept()</code> 方法可以检查该可观察者，并在将其返回给调用者之前对其进行修改。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2obmq8nim3d9gmdxij3ibdc0f\">这个\n<em>空操作</em>拦截器只是用原始请求调用 \n<code>next.handle()</code>，并返回可观察者，不做任何操作。</p>\n<h4 id=\"the-next-object\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7izbszxamilphpzcpp1wjhc86\"><i class=\"material-icons\">link</i><em>next</em> 对象</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0ra18qxqthwojnp1thndj6vz\"><code>next</code> 对象表示拦截器链中的下一个拦截器。 链中的最后一个 \n<code>next</code> 是 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 后端处理程序，它将请求发送到服务器并接收服务器的响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17ylyl8r5kjc1s2pe2tyft3uo\">大多数拦截器调用 \n<code>next.handle()</code>，以便请求流经下一个拦截器，最终流经后端处理程序。 拦截器\n<em>可以</em>跳过调用 \n<code>next.handle()</code>，短路链，并\n<a href=\"guide/http#caching\">返回它自己的 <code>Observable</code></a>，其中包含一个人工服务器响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xh8lq43pubu6mah38n3dx6hy\">这是一种常见的中间件模式，在 Express.js 等框架中很常见。</p>\n<h4 id=\"provide-the-interceptor\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zybw5cnvn25ppp43bnknrzvp\"><i class=\"material-icons\">link</i>提供拦截器</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chdcd6zyu0o4t5ngs5bt82dcp\"><code>NoopInterceptor</code> 是由 Angular 的 \n<a href=\"guide/dependency-injection\">依赖注入 (DI)</a> 系统管理的服务。 与其他服务一样，你必须在应用可以使用它之前提供拦截器类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5jdemm6qtyotscdgkznz38n4o\">因为拦截器是 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务的（可选）依赖项， 所以你必须在提供 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的同一个注入器（或注入器的父级）中提供它们。 在 DI 创建 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> \n<em>之后</em>提供的拦截器将被忽略。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1q2z6kyssh3vx27kj15sf5m6e\">此应用在应用的根注入器中提供 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>，作为在 \n<code>AppModule</code> 中导入 \n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 的副作用。 你应该在 \n<code>AppModule</code> 中也提供拦截器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4t561pioamwlipsasolcf1gaf\">在从 \n<code>@angular/common/http</code> 导入 \n<code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> 注入令牌后， 请像这样编写 \n<code>NoopInterceptor</code> 提供者：</p>\n<code-example path=\"http/src/app/http-interceptors/index.ts\" region=\"noop-provider\" linenums=\"false\">\n{ provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3o6u5xsmdthqxzg3kk9i39do8\">请注意 \n<code>multi: true</code> 选项。 此必需设置告诉 Angular \n<code><a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a></code> 是一个\n<em>多提供者</em>的令牌， 它注入一个值数组，而不是单个值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"914ak1p2trzeq0vq3tankw5fu\">你\n<em>可以</em>将此提供者直接添加到 \n<code>AppModule</code> 的提供者数组中。 但是，这相当冗长，而且很有可能 你会创建更多拦截器，并以相同的方式提供它们。 你必须密切注意\n<a href=\"guide/http#interceptor-order\">提供这些拦截器的顺序</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bfoe6kbyiypfz9kvhfq3dxaz\">考虑创建一个“桶”文件，将所有拦截器提供者收集到一个 \n<code>httpInterceptorProviders</code> 数组中，从第一个 \n<code>NoopInterceptor</code> 开始。</p>\n<code-example path=\"http/src/app/http-interceptors/index.ts\" region=\"interceptor-providers\" title=\"app/http-interceptors/index.ts\" linenums=\"false\">\n/* \"Barrel\" of <a href=\"api/http/Http\" class=\"code-anchor\">Http</a> Interceptors */\nimport { <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a> } from '@angular/common/http';\n\nimport { NoopInterceptor } from './noop-interceptor';\n\n/** <a href=\"api/http/Http\" class=\"code-anchor\">Http</a> interceptor providers in outside-in order */\nexport const httpInterceptorProviders = [\n  { provide: <a href=\"api/common/http/HTTP_INTERCEPTORS\" class=\"code-anchor\">HTTP_INTERCEPTORS</a>, useClass: NoopInterceptor, multi: true },\n];\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17fhze416dlfgo92j5xio0go5\">然后导入它并将其添加到 \n<code>AppModule</code> 的\n<em>提供者数组</em>中，如下所示：</p>\n<code-example path=\"http/src/app/app.module.ts\" region=\"interceptor-providers\" title=\"app/app.module.ts (interceptor providers)\" linenums=\"false\">\nproviders: [\n  httpInterceptorProviders\n],\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6vkt2ywvj5of3l1nmno2qj4ai\">当你创建新的拦截器时，将它们添加到 \n<code>httpInterceptorProviders</code> 数组中， 你就不必再访问 \n<code>AppModule</code> 了。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aur57wei2phs046ww36vtlw79\">完整的示例代码中还有许多其他拦截器。</p>\n</div>\n<h4 id=\"interceptor-order\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6dc909apclh4hqh85pfad2evt\"><i class=\"material-icons\">link</i>拦截器顺序</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"81iys8ppyi4i8m8zqps26sf0f\">Angular 按你提供它们的顺序应用拦截器。 如果你提供拦截器\n<em>A</em>，然后是\n<em>B</em>，然后是\n<em>C</em>，请求将按\n<em>A-&gt;B-&gt;C</em> 的顺序流动， 响应将按\n<em>C-&gt;B-&gt;A</em> 的顺序流动。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c17pbvxqxphoz2emus359mil4\">你不能更改顺序或稍后删除拦截器。 如果你需要动态启用和禁用拦截器，你必须在拦截器本身中构建该功能。</p>\n<h4 id=\"httpevents\"><em>HttpEvents</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ckblol32bajj4bmujy98kyawl\">你可能期望 \n<code>intercept()</code> 和 \n<code>handle()</code> 方法返回 \n<code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>&lt;any&gt;</code> 的可观察者，就像大多数 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法一样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lq1tl0kvf9l59f4r3so91ri1\">相反，它们返回 \n<code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;</code> 的可观察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4n7awpxj74yxw5e0acifs3bdf\">这是因为拦截器的工作级别低于这些 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 方法。单个 HTTP 请求可以生成多个\n<em>事件</em>，包括上传和下载进度事件。\n<code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 类本身实际上是一个事件，其类型为 \n<code>HttpEventType.HttpResponseEvent</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3bmxwjxxbm008pg1snb4nngyn\">许多拦截器只关心传出的请求，并且只是返回 \n<code>next.handle()</code> 的事件流，而不修改它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1wi0ed9u3mksfjy4d1zdslijf\">但是，检查和修改 \n<code>next.handle()</code> 返回的响应的拦截器 将看到所有这些事件。 你的拦截器应该返回\n<em>所有未修改的事件</em>，除非它有\n<em>充分的理由这样做</em>。</p>\n<h4 id=\"immutability\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1zbfvlnkls9mrgrtou1m9qxnu\"><i class=\"material-icons\">link</i>不可变性</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6etm9xij4r5n7i2xj0dy8j3z\">虽然拦截器能够修改请求和响应， 但 \n<code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 和 \n<code><a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a></code> 实例属性是 \n<code>readonly</code>， 使它们在很大程度上不可变。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ct4ry4zxebnuojney4q4ttelt\">它们不可变是有充分理由的：应用可能在成功之前多次重试请求，这意味着拦截器链可能多次重新处理同一个请求。 如果拦截器可以修改原始请求对象，则重试操作将从修改后的请求开始，而不是从原始请求开始。不可变性确保拦截器在每次尝试时都看到相同的请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1k0n4er2prbdgbfluwdmkz91i\">TypeScript 将阻止你设置 \n<code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 只读属性。</p>\n<code-example language=\"javascript\">\n  // Typescript disallows the following assignment because req.url is readonly\n  req.url = req.url.replace('http://', 'https://');\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"caxesfxhmngh2uye7ft4yo4ig\">要更改请求，请先克隆它，然后修改克隆，再将其传递给 \n<code>next.handle()</code>。 你可以在一步中克隆和修改请求，如以下示例所示。</p>\n<code-example path=\"http/src/app/http-interceptors/ensure-https-interceptor.ts\" region=\"excerpt\" title=\"app/http-interceptors/ensure-https-interceptor.ts (excerpt)\" linenums=\"false\">\n// clone request and replace 'http://' with 'https://' at the same time\nconst secureReq = req.clone({\n  url: req.url.replace('http://', 'https://')\n});\n// send the cloned, \"secure\" request to the next handler.\nreturn next.handle(secureReq);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"sdxnueyn5npjkgv3novyi0b8\"><code>clone()</code> 方法的哈希参数允许你在复制其他属性的同时修改请求的特定属性。</p>\n<h5 id=\"the-request-body\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwaz5v4x8rfkswdwpn5srqrmx\"><i class=\"material-icons\">link</i>请求主体</h5>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b48gyapj7gxqxi7umudkub0jk\"><code>readonly</code> 赋值保护无法阻止深度更新，尤其是 它无法阻止你修改请求主体对象的属性。</p>\n<code-example language=\"javascript\">\n  req.body.name = req.body.name.trim(); // bad idea!\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6668vwzfnjy4p70o4ptbc6a8y\">如果你必须修改请求主体，请先复制它，更改副本， \n<code>clone()</code> 请求，并使用新的主体设置克隆的主体，如以下示例所示。</p>\n<code-example path=\"http/src/app/http-interceptors/trim-name-interceptor.ts\" region=\"excerpt\" title=\"app/http-interceptors/trim-name-interceptor.ts (excerpt)\" linenums=\"false\">\n// copy the body and trim whitespace from the name property\nconst newBody = { ...body, name: body.name.trim() };\n// clone request and set its body\nconst newReq = req.clone({ body: newBody });\n// send the cloned request to the next handler.\nreturn next.handle(newReq);\n\n</code-example>\n<h5 id=\"clearing-the-request-body\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5lwk5bjhbasi6a8sy7gbnn68\"><i class=\"material-icons\">link</i>清除请求主体</h5>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ezeov6vluhf9ef1sqvmqh5kl\">有时你需要清除请求主体，而不是替换它。 如果你将克隆的请求主体设置为 \n<code>undefined</code>，Angular 会假设你打算保留主体原样。 这不是你想要的。 如果你将克隆的请求主体设置为 \n<code>null</code>，Angular 会知道你打算清除请求主体。</p>\n<code-example language=\"javascript\">\n  newReq = req.clone({ ... }); // body not mentioned =&gt; preserve original body\n  newReq = req.clone({ body: undefined }); // preserve original body\n  newReq = req.clone({ body: null }); // clear the body\n</code-example>\n<h4 id=\"set-default-headers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"thvcjoxxz9h4cbommv13wru4\"><i class=\"material-icons\">link</i>设置默认标头</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dff42cnauimi1cdjl5cxn4u5m\">应用通常使用拦截器在传出的请求上设置默认标头。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wneow24moqkc79pqfzn3dzor\">示例应用有一个 \n<code>AuthService</code>，它生成授权令牌。 以下是它的 \n<code>AuthInterceptor</code>，它注入该服务以获取令牌， 并将带有该令牌的授权标头添加到每个传出的请求中：</p>\n<code-example path=\"http/src/app/http-interceptors/auth-interceptor.ts\" title=\"app/http-interceptors/auth-interceptor.ts\">\nimport { AuthService } from '../auth.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class AuthInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n\n  constructor(private auth: AuthService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // Get the auth token from the service.\n    const authToken = this.auth.getAuthorizationToken();\n\n    // Clone the request and replace the original headers with\n    // cloned headers, updated with the authorization.\n    const authReq = req.clone({\n      headers: req.headers.set('Authorization', authToken)\n    });\n\n    // send cloned request with header to the next handler.\n    return next.handle(authReq);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3kz6e6hgouoh4ylolcd1v4v1c\">克隆请求以设置新标头的做法非常普遍，因此 有一个 \n<code>setHeaders</code> 快捷方式：</p>\n<code-example path=\"http/src/app/http-interceptors/auth-interceptor.ts\" region=\"set-header-shortcut\">\n// Clone the request and set the new header in one step.\nconst authReq = req.clone({ setHeaders: { Authorization: authToken } });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3oqai83t3kpk251hif3bjzoz\">修改标头的拦截器可用于许多不同的操作，包括：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmy3wyk05d2kl2h5o7b2ioss3\">身份验证/授权</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cejx62u0zoa1rvza5w0n0eagh\">缓存行为；例如，\n<code>If-Modified-Since</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"boavr5z03onajogritmvn7uce\">跨站请求伪造（XSRF）保护</li>\n</ul>\n<h4 id=\"logging\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8e1isytq0raoy4qu3v9xzdd5w\"><i class=\"material-icons\">link</i>日志记录</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97c6fz5626zsijalgp3ar4tg0\">因为拦截器可以\n<em>一起</em>处理请求和响应，所以它们可以做一些事情，比如计时和记录整个 HTTP 操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3mxcikqltg5jmp4q807bmhlkv\">考虑以下 \n<code>LoggingInterceptor</code>，它捕获请求的时间、响应的时间，并使用注入的 \n<code>MessageService</code> 记录结果和经过的时间。</p>\n<code-example path=\"http/src/app/http-interceptors/logging-interceptor.ts\" region=\"excerpt\" title=\"app/http-interceptors/logging-interceptor.ts)\">\nimport { finalize, tap } from 'rxjs/operators';\nimport { MessageService } from '../message.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class LoggingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private messenger: MessageService) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    const started = Date.now();\n    let ok: string;\n\n    // extend server response observable with logging\n    return next.handle(req)\n      .pipe(\n        tap(\n          // Succeeds when there is <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> response; ignore other events\n          event =&gt; ok = event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a> ? 'succeeded' : '',\n          // Operation failed; error is an <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>\n          error =&gt; ok = 'failed'\n        ),\n        // Log when response observable either completes or errors\n        finalize(() =&gt; {\n          const elapsed = Date.now() - started;\n          const msg = `${req.method} \"${req.urlWithParams}\"\n             ${ok} in ${elapsed} ms.`;\n          this.messenger.add(msg);\n        })\n      );\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5lauu1vo8p3809rrme4zfors5\">RxJS 的 \n<code>tap</code> 操作符捕获请求是成功还是失败。 RxJS 的 \n<code>finalize</code> 操作符在响应可观察者发生错误或完成时（它必须完成）被调用，并将结果报告给 \n<code>MessageService</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"10lij6woplguwcru7i5c18fu5\"><code>tap</code> 和 \n<code>finalize</code> 都不触及返回给调用者的可观察者流的值。</p>\n<h4 id=\"caching\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61f2ystm8bkzg8jtx5agyrre\"><i class=\"material-icons\">link</i>缓存</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"377p789zjj9oszva52u03xe83\">拦截器可以自行处理请求，而无需转发到 \n<code>next.handle()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"beb2io7kslb7wpwyqpjdx7zk1\">例如，你可能决定缓存某些请求和响应以提高性能。 你可以将缓存委托给拦截器，而不会干扰你现有的数据服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uq3kxckcyo39i4hpbqzmlp91\"><code>CachingInterceptor</code> 演示了这种方法。</p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"v1\" title=\"app/http-interceptors/caching-interceptor.ts)\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class CachingInterceptor implements <a href=\"api/common/http/HttpInterceptor\" class=\"code-anchor\">HttpInterceptor</a> {\n  constructor(private cache: RequestCache) {}\n\n  intercept(req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;, next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>) {\n    // continue if not cachable.\n    if (!isCachable(req)) { return next.handle(req); }\n\n    const cachedResponse = this.cache.get(req);\n    return cachedResponse ?\n      of(cachedResponse) : sendRequest(req, next, this.cache);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"895zbhpkhym2st3mcowrs2xco\"><code>isCachable()</code> 函数确定请求是否可缓存。 在此示例中，只有对 npm 包搜索 API 的 GET 请求是可缓存的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6mha67pq3j8dssu7w251fewaz\">如果请求不可缓存，拦截器会简单地将请求转发到链中的下一个处理程序。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejt4muu29ccwvx6agexo860bd\">如果在缓存中找到可缓存的请求，拦截器会返回一个带有缓存响应的 \n<code>of()</code> \n<em>可观察者</em>，绕过 \n<code>next</code> 处理程序（以及所有下游的拦截器）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6swfgayqb5onctx3qkple97k0\">如果可缓存的请求不在缓存中，代码会调用 \n<code>sendRequest</code>。</p>\n<a id=\"send-request\"></a>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"send-request\">\n/**\n * Get server response observable by sending request to `next()`.\n * Will add the response to the cache on the way out.\n */\nfunction sendRequest(\n  req: <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>&lt;any&gt;,\n  next: <a href=\"api/common/http/HttpHandler\" class=\"code-anchor\">HttpHandler</a>,\n  cache: RequestCache): Observable&lt;<a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;&gt; {\n\n  // No headers allowed in npm search request\n  const noHeaderReq = req.clone({ headers: new <a href=\"api/common/http/HttpHeaders\" class=\"code-anchor\">HttpHeaders</a>() });\n\n  return next.handle(noHeaderReq).pipe(\n    tap(event =&gt; {\n      // There may be other events besides the response.\n      if (event instanceof <a href=\"api/common/http/HttpResponse\" class=\"code-anchor\">HttpResponse</a>) {\n        cache.put(req, event); // Update the cache.\n      }\n    })\n  );\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qsrt6a0q03f4d8lkif9kbwfu\"><code>sendRequest</code> 函数创建一个 \n<a href=\"guide/http#immutability\">请求克隆</a>，不带标头，因为 npm API 禁止它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2pjarj6dfzcbr0jfvhgz34l6v\">它将该请求转发到 \n<code>next.handle()</code>，最终调用服务器并返回服务器的响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qet3aiim5e7y1edy5r05fhr1\">注意 \n<code>sendRequest</code> 如何在返回应用程序的途中\n<em>拦截响应</em>。 它通过 \n<code>tap()</code> 操作符\n<em>管道</em>响应，其回调将响应添加到缓存中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"45w889rye0i7qidvtxe3xt202\">原始响应继续不受影响地向上通过拦截器链返回到应用程序调用者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ap0bssc664jggya4330zbynd\">数据服务，例如 \n<code>PackageSearchService</code>，不知道它们的一些 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 请求实际上返回的是缓存的响应。</p>\n<a id=\"cache-refresh\"></a>\n<h4 id=\"return-a-multi-valued-observable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"exbunzo4be18tdg911l81wa30\"><i class=\"material-icons\">link</i>返回一个多值\n<em>可观察者</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bk54ga78u9uur3qpzuflxxtzw\"><code><a href=\"\" class=\"code-anchor\">HttpClient.get()</a></code> 方法通常返回一个\n<em>可观察者</em>，它要么发出数据，要么发出错误。 有些人将其描述为“\n<em>一次性</em>”可观察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5adgn02uw18p1bs3to7voikmy\">但拦截器可以将其更改为一个发出多次的\n<em>可观察者</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6v6fvblknc7l2shv9erilkus2\"><code>CachingInterceptor</code> 的修订版本可以选择返回一个\n<em>可观察者</em>，该\n<em>可观察者</em>立即发出缓存的响应，无论如何将请求发送到 npm 网页 API，并在稍后再次发出更新的搜索结果。</p>\n<code-example path=\"http/src/app/http-interceptors/caching-interceptor.ts\" region=\"intercept-refresh\">\n// cache-then-refresh\nif (req.headers.get('x-refresh')) {\n  const results$ = sendRequest(req, next, this.cache);\n  return cachedResponse ?\n    results$.pipe( startWith(cachedResponse) ) :\n    results$;\n}\n// cache-or-fetch\nreturn cachedResponse ?\n  of(cachedResponse) : sendRequest(req, next, this.cache);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bbbhrtn6qgvry6l56zks54nd5\"><em>缓存然后刷新</em>选项由\n<strong>自定义 <code>x-refresh</code> 标头</strong>的存在触发。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mm2yn7mirmogs8gln62n3s5w\"><code>PackageSearchComponent</code> 上的复选框切换 \n<code>withRefresh</code> 标志，它是 \n<code>PackageSearchService.search()</code> 的参数之一。 该 \n<code>search()</code> 方法创建自定义 \n<code>x-refresh</code> 标头，并在调用 \n<code><a href=\"\" class=\"code-anchor\">HttpClient.get()</a></code> 之前将其添加到请求中。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6mgd8rngg4bxzgjy2zkloy02i\">修订后的 \n<code>CachingInterceptor</code> 设置了一个服务器请求，无论是否有缓存值，都使用上面 \n<a href=\"guide/http#send-request\">描述的</a> 相同的 \n<code>sendRequest()</code> 方法。 \n<code>results$</code> 可观察者将在订阅时发出请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwxh7dohmpvp9401w7v227lse\">如果没有缓存值，拦截器会返回 \n<code>results$</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78q8rjhasmde8x38t5hzzi0s1\">如果有缓存值，代码会将缓存的响应\n<em>管道</em>到 \n<code>results$</code> 上，生成一个重新组合的可观察者，它发出两次，首先是缓存的响应（并且立即），然后是来自服务器的响应。 订阅者会看到\n<em>两个</em>响应的序列。</p>\n<h3 id=\"listening-to-progress-events\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9a8cw9hn84prf2mukbsdcttwl\"><i class=\"material-icons\">link</i>监听进度事件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"686sl8s7smbzw78f8b3lbn5wk\">有时应用程序会传输大量数据，这些传输可能需要很长时间。 文件上传就是一个典型的例子。 通过提供有关此类传输进度的反馈，为用户提供更好的体验。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3uh3e5g41wo34enhluzxivkr5\">要使用启用进度事件的请求，你可以创建一个 \n<code><a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a></code> 实例，并将 \n<code>reportProgress</code> 选项设置为 true 以启用进度事件的跟踪。</p>\n<code-example path=\"http/src/app/uploader/uploader.service.ts\" region=\"upload-request\" title=\"app/uploader/uploader.service.ts (upload request)\">\nconst req = new <a href=\"api/common/http/HttpRequest\" class=\"code-anchor\">HttpRequest</a>('POST', '/upload/file', file, {\n  reportProgress: true\n});\n\n</code-example>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61d8fkl0orvu5y3hhing2hjqu\">每个进度事件都会触发变更检测，因此只有在你真正打算在 UI 中报告进度时才启用它们。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"alnx16sgktkktnptppbc6l4bk\">接下来，将此请求对象传递给 \n<code><a href=\"\" class=\"code-anchor\">HttpClient.request()</a></code> 方法，该方法返回一个 \n<code>HttpEvents</code> 的 \n<code>Observable</code>，与拦截器处理的相同事件：</p>\n<code-example path=\"http/src/app/uploader/uploader.service.ts\" region=\"upload-body\" title=\"app/uploader/uploader.service.ts (upload body)\" linenums=\"false\">\n// The `HttpClient.request` API produces <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> raw event stream\n// which includes start (sent), progress, and response events.\nreturn this.http.request(req).pipe(\n  map(event =&gt; this.getEventMessage(event, file)),\n  tap(message =&gt; this.showProgress(message)),\n  last(), // return last (completed) message to caller\n  catchError(this.handleError(file))\n);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8c7qxifhhekrghi8iiw9xyiks\"><code>getEventMessage</code> 方法解释事件流中每种类型的 \n<code><a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a></code>。</p>\n<code-example path=\"http/src/app/uploader/uploader.service.ts\" region=\"getEventMessage\" title=\"app/uploader/uploader.service.ts (getEventMessage)\" linenums=\"false\">\n/** Return distinct message for sent, upload progress, &amp; response events */\nprivate getEventMessage(event: <a href=\"api/common/http/HttpEvent\" class=\"code-anchor\">HttpEvent</a>&lt;any&gt;, file: File) {\n  switch (event.type) {\n    case <a href=\"api/common/http/HttpEventType#Sent\" class=\"code-anchor\">HttpEventType.Sent</a>:\n      return `Uploading file \"${file.name}\" of size ${file.size}.`;\n\n    case <a href=\"api/common/http/HttpEventType#UploadProgress\" class=\"code-anchor\">HttpEventType.UploadProgress</a>:\n      // Compute and show the % done:\n      const percentDone = Math.round(100 * event.loaded / event.total);\n      return `File \"${file.name}\" is ${percentDone}% uploaded.`;\n\n    case <a href=\"api/common/http/HttpEventType#Response\" class=\"code-anchor\">HttpEventType.Response</a>:\n      return `File \"${file.name}\" was completely uploaded!`;\n\n    default:\n      return `File \"${file.name}\" surprising upload event: ${event.type}.`;\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"esrw51h4f5f9wult52ke23jf0\">本指南的示例应用程序没有接受上传文件的服务器。 \n<code>app/http-interceptors/upload-interceptor.ts</code> 中的 \n<code>UploadInterceptor</code> 拦截并通过返回模拟事件的可观察者来短路上传请求。</p>\n</div>\n<h2 id=\"security-xsrf-protection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"doms425a2cbypfwc9gshmeimi\"><i class=\"material-icons\">link</i>安全：XSRF 保护</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2bs25y68y5x7cvckumxcdbco\"><a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery\">跨站请求伪造 (XSRF)</a> 是一种攻击技术，攻击者可以通过它欺骗经过身份验证的用户在不知情的情况下在你的网站上执行操作。\n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 支持一种 \n<a href=\"https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-Header_Token\">常用机制</a> 用于防止 XSRF 攻击。在执行 HTTP 请求时，拦截器从 cookie 中读取一个标记，默认情况下为 \n<code>XSRF-TOKEN</code>，并将其设置为 HTTP 标头 \n<code>X-XSRF-TOKEN</code>。由于只有在你的域上运行的代码才能读取 cookie，因此后端可以确定 HTTP 请求来自你的客户端应用程序，而不是攻击者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5prdeoikwkodh9kst64fbckok\">默认情况下，拦截器会将此 cookie 发送到所有对相对 URL 的修改请求（POST 等），但不会发送到 GET/HEAD 请求或具有绝对 URL 的请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"518i3sf5dn07ywlll61lno9pp\">为了利用这一点，你的服务器需要在页面加载或第一个 GET 请求时在 JavaScript 可读的会话 cookie 中设置一个名为 \n<code>XSRF-TOKEN</code> 的标记。在随后的请求中，服务器可以验证 cookie 是否与 \n<code>X-XSRF-TOKEN</code> HTTP 标头匹配，因此可以确定只有在你的域上运行的代码才能发送请求。该标记必须对每个用户都是唯一的，并且必须可由服务器验证；这可以防止客户端编造自己的标记。将标记设置为你的网站身份验证 cookie 的摘要，并添加一个盐以提高安全性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tw7rjb8bqi839oic9hvxv2tj\">为了防止在多个 Angular 应用程序共享同一个域或子域的环境中发生冲突，请为每个应用程序提供一个唯一的 cookie 名称。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7d2j9cp4dz46xrgppeyg45e01\"><em>请注意，<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 仅支持 XSRF 保护方案的客户端部分。</em> 你的后端服务必须配置为为你的页面设置 cookie，并验证标头是否出现在所有符合条件的请求中。 如果没有，Angular 的默认保护将无效。</p>\n</div>\n<h3 id=\"configuring-custom-cookieheader-names\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"xi3kpcq5wjpes17zesfxii6c\"><i class=\"material-icons\">link</i>配置自定义 cookie/标头名称</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"19m7jlu5mzl81kwww9262yxq7\">如果你的后端服务使用不同的 XSRF 标记 cookie 或标头名称， 请使用 \n<code><a href=\"api/common/http/HttpClientXsrfModule#withOptions\" class=\"code-anchor\">HttpClientXsrfModule.withOptions()</a></code> 覆盖默认值。</p>\n<code-example path=\"http/src/app/app.module.ts\" region=\"xsrf\" linenums=\"false\">\nimports: [\n  <a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a>,\n  HttpClientXsrfModule.withOptions({\n    cookieName: 'My-Xsrf-Cookie',\n    headerName: 'My-Xsrf-Header',\n  }),\n],\n\n</code-example>\n<h2 id=\"testing-http-requests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ees3bftz11nk9k6vqvrwj917o\"><i class=\"material-icons\">link</i>测试 HTTP 请求</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsj5nfrmq8aq19e1sn7bdjthh\">与任何外部依赖项一样，HTTP 后端需要被模拟， 以便你的测试可以模拟与远程服务器的交互。 \n<code>@angular/common/http/testing</code> 库使 设置这种模拟变得简单明了。</p>\n<h3 id=\"mocking-philosophy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"86q6v099l986ngkmj79spaw8p\"><i class=\"material-icons\">link</i>模拟理念</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c7t4788wcly1hekuen1zrjrfq\">Angular 的 HTTP 测试库是为一种测试模式而设计的，在这种模式中， 应用程序首先执行代码并发出请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4o6dl5zfz26ynsqrclprl9tbg\">然后，测试会预期某些请求已发出或未发出， 对这些请求执行断言， 最后通过“刷新”每个预期请求来提供响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2fjh67joksfwk0w8ag8sef20v\">最后，测试可以验证应用程序是否没有发出任何意外请求。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"m3nx5q7b53jo1c0cggnvc6x5\">你可以在动态代码环境中运行 \n<live-example stackblitz=\"specs\">\n 这些示例测试\n</live-example>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8acewvrl0x4aazm7q0x9w561w\">本指南中描述的测试位于 \n<code>src/testing/http-client.spec.ts</code> 中。 在 \n<code>src/app/heroes/heroes.service.spec.ts</code> 中，还有一些应用程序数据服务的测试，这些测试调用了 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code>。</p>\n</div>\n<h3 id=\"setup-1\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a90a9lk5ukrzn7bkuyktmp1zv\"><i class=\"material-icons\">link</i>设置</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98iu8jd43vtjiwbyhzp5d5dnw\">要开始测试对 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 的调用， 请导入 \n<code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 和模拟控制器 \n<code><a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a></code>， 以及测试所需的其它符号。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"imports\" title=\"app/testing/http-client.spec.ts (imports)\" linenums=\"false\">\n// <a href=\"api/http/Http\" class=\"code-anchor\">Http</a> testing module and mocking controller\nimport { <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a>, <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a> } from '@angular/common/http/testing';\n\n// Other imports\nimport { <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>, <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a> } from '@angular/common/http';\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cfhwj5ndeqc113f9u9l22x7p3\">然后将 \n<code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 添加到 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 中，并继续设置\n<em>被测服务</em>。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"setup\" title=\"app/testing/http-client.spec.ts(setup)\" linenums=\"false\">\ndescribe('<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> testing', () =&gt; {\n  let httpClient: <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>;\n  let httpTestingController: <a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      imports: [ <a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a> ]\n    });\n\n    // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> the http service and test controller for each test\n    httpClient = TestBed.get(<a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>);\n    httpTestingController = TestBed.get(<a href=\"api/common/http/testing/HttpTestingController\" class=\"code-anchor\">HttpTestingController</a>);\n  });\n  /// Tests begin ///\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dgjvfafcauuv06damga03e35u\">现在，在测试过程中发出的请求将命中测试后端，而不是正常后端。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzsqnrqsxy3b2vdmacpik93pq\">此设置还会调用 \n<code>TestBed.get()</code> 来注入 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务和模拟控制器， 以便在测试期间可以引用它们。</p>\n<h3 id=\"expecting-and-answering-requests\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"22dsiylysj00lm4p0kwhgo1ym\"><i class=\"material-icons\">link</i>期待并回复请求</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"boe7zaqgl1brnz11vwm4zgfrh\">现在，你可以编写一个测试，该测试期望发生一个 GET 请求，并提供一个模拟响应。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"get-test\" title=\"app/testing/http-client.spec.ts(httpClient.get)\" linenums=\"false\">\nit('can test HttpClient.get', () =&gt; {\n  const testData: <a href=\"api/router/Data\" class=\"code-anchor\">Data</a> = {name: 'Test <a href=\"api/router/Data\" class=\"code-anchor\">Data</a>'};\n\n  // Make an HTTP GET request\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>&gt;(testUrl)\n    .subscribe(data =&gt;\n      // When observable resolves, result should match test data\n      expect(data).toEqual(testData)\n    );\n\n  // The following `expectOne()` will match the request's URL.\n  // If no requests or <a href=\"api/forms/SelectMultipleControlValueAccessor\" class=\"code-anchor\">multiple</a> requests matched that URL\n  // `expectOne()` would throw.\n  const req = httpTestingController.expectOne('/data');\n\n  // Assert that the request is <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> GET.\n  expect(req.request.method).toEqual('GET');\n\n  // Respond with mock data, causing Observable to resolve.\n  // Subscribe callback asserts that correct data was returned.\n  req.flush(testData);\n\n  // Finally, assert that there are no outstanding requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5xp1fhhvp6l5ue5w4cx6mtqw8\">最后一步，验证没有发起过预期之外的请求，足够通用，因此你可以把它移到 <code>afterEach()</code> 中：</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"afterEach\" linenums=\"false\">\nafterEach(() =&gt; {\n  // After every test, assert that there are no more pending requests.\n  httpTestingController.verify();\n});\n\n</code-example>\n<h4 id=\"custom-request-expectations\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ec7cvqaervzaxn9jg2j77vjte\"><i class=\"material-icons\">link</i>自定义请求期望</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"baml57jl6hg2kjletztu16hx8\">如果仅通过 URL 匹配还不够，则可以实现自己的匹配函数。 例如，你可以查找具有授权标头的传出请求：</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"predicate\" linenums=\"false\">\n// Expect one request with an authorization header\nconst req = httpTestingController.expectOne(\n  req =&gt; req.headers.has('Authorization')\n);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0ped5jpebxcime4nf2wb07wn\">与之前的 \n<code>expectOne()</code> 一样， 如果 0 个或 2 个以上请求满足此谓词，则测试将失败。</p>\n<h4 id=\"handling-more-than-one-request\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e3bn71j2zztxy5logrw2wmjeo\"><i class=\"material-icons\">link</i>处理多个请求</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eqlikcts5z5scjxpix625u35f\">如果需要在测试中响应重复请求，请使用 \n<code>match()</code> API 而不是 \n<code>expectOne()</code>。 它接受相同的参数，但返回一个匹配请求的数组。 返回后，这些请求将从将来的匹配中移除， 并且你需要负责刷新和验证它们。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"multi-request\" linenums=\"false\">\n// get all pending requests that match the given URL\nconst requests = httpTestingController.match(testUrl);\nexpect(requests.length).toEqual(3);\n\n// Respond to each request with different results\nrequests[0].flush([]);\nrequests[1].flush([testData[0]]);\nrequests[2].flush(testData);\n\n</code-example>\n<h3 id=\"testing-for-errors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ca29zem45uz2bn8rgi2jijt2\"><i class=\"material-icons\">link</i>测试错误</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9tspntsrkmdixdnkivdvqfmh4\">你应该测试应用程序防御失败的 HTTP 请求的能力。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehjda3g3znrnlxh0kqc59uciz\">使用 \n<code>ErrorEvent</code> 调用 \n<code>request.error()</code> 而不是 \n<code>request.flush()</code>，如本例所示。</p>\n<code-example path=\"http/src/testing/http-client.spec.ts\" region=\"404\" linenums=\"false\">\nit('can test for 404 error', () =&gt; {\n  const emsg = 'deliberate 404 error';\n\n  httpClient.get&lt;<a href=\"api/router/Data\" class=\"code-anchor\">Data</a>[]&gt;(testUrl).subscribe(\n    data =&gt; fail('should have failed with the 404 error'),\n    (error: <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>) =&gt; {\n      expect(error.status).toEqual(404, 'status');\n      expect(error.error).toEqual(emsg, 'message');\n    }\n  );\n\n  const req = httpTestingController.expectOne(testUrl);\n\n  // Respond with mock error\n  req.flush(emsg, { status: 404, statusText: 'Not Found' });\n});\n\n</code-example>\n\n</div>\n<!-- links to this doc:\n - guide/architecture-next-steps\n - guide/browser-support\n - guide/npm-packages\n - guide/pipes\n - guide/testing\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - api/common/AsyncPipe\n - api/common/NgForOf\n - api/common/http/HTTP_INTERCEPTORS\n - api/common/http/HttpBackend\n - api/common/http/HttpClient\n - api/common/http/HttpClientModule\n - api/common/http/HttpClientXsrfModule#withOptions\n - api/common/http/HttpErrorResponse\n - api/common/http/HttpEvent\n - api/common/http/HttpEventType#Response\n - api/common/http/HttpEventType#Sent\n - api/common/http/HttpEventType#UploadProgress\n - api/common/http/HttpHandler\n - api/common/http/HttpHeaders\n - api/common/http/HttpInterceptor\n - api/common/http/HttpParams\n - api/common/http/HttpRequest\n - api/common/http/HttpResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/common/http/testing/HttpTestingController\n - api/core/Inject\n - api/core/Injectable\n - api/core/NgModule\n - api/core/testing/TestBed\n - api/core/testing/async\n - api/forms/SelectMultipleControlValueAccessor\n - api/http/Http\n - api/http/Http#get\n - api/platform-browser/BrowserModule\n - api/router/Data\n - api/router/RouterLinkWithHref\n - guide/dependency-injection\n - guide/http#adding-headers\n - guide/http#advanced-usage\n - guide/http#always-subscribe\n - guide/http#cache-refresh\n - guide/http#caching\n - guide/http#clearing-the-request-body\n - guide/http#configuring-custom-cookieheader-names\n - guide/http#configuring-the-request\n - guide/http#custom-request-expectations\n - guide/http#debouncing-requests\n - guide/http#error-details\n - guide/http#error-handling\n - guide/http#expecting-and-answering-requests\n - guide/http#getting-error-details\n - guide/http#getting-json-data\n - guide/http#handling-more-than-one-request\n - guide/http#httpclient\n - guide/http#httpevents\n - guide/http#immutability\n - guide/http#intercepting-requests-and-responses\n - guide/http#interceptor-order\n - guide/http#listening-to-progress-events\n - guide/http#logging\n - guide/http#making-a-delete-request\n - guide/http#making-a-post-request\n - guide/http#making-a-put-request\n - guide/http#mocking-philosophy\n - guide/http#observables-and-operators\n - guide/http#provide-the-interceptor\n - guide/http#reading-the-full-response\n - guide/http#requesting-non-json-data\n - guide/http#retry\n - guide/http#return-a-multi-valued-observable\n - guide/http#rxjs\n - guide/http#security-xsrf-protection\n - guide/http#send-request\n - guide/http#sending-data-to-the-server\n - guide/http#set-default-headers\n - guide/http#setup\n - guide/http#setup-1\n - guide/http#switchmap\n - guide/http#testing-for-errors\n - guide/http#testing-http-requests\n - guide/http#the-next-object\n - guide/http#the-request-body\n - guide/http#type-checking-the-response\n - guide/http#update-headers\n - guide/http#url-parameters\n - guide/http#why-write-a-service\n - guide/http#write-an-interceptor\n - http://reactivex.io/rxjs/\n - https://en.wikipedia.org/wiki/Cross-site_request_forgery\n - https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-Header_Token\n - https://github.com/angular/in-memory-web-api/blob/master/README.md\n-->"
}