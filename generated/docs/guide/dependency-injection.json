{
  "id": "guide/dependency-injection",
  "title": "Angular Dependency Injection",
  "contents": "\n<div class=\"content\">\n<h1 id=\"angular-dependency-injection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#angular-dependency-injection\"><i class=\"material-icons\">link</i></a>Angular Dependency Injection</h1>\n<p><strong>Dependency Injection (DI)</strong> is a way to create objects that depend upon other objects.\nA Dependency Injection system supplies the dependent objects (called the <em>dependencies</em>)\nwhen it creates an instance of an object.</p>\n<p>The <a href=\"guide/dependency-injection-pattern\">Dependency Injection pattern</a> page describes this general approach.\n<em>The guide you're reading now</em> explains how Angular's own Dependency Injection system works.</p>\n<h2 id=\"di-by-example\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#di-by-example\"><i class=\"material-icons\">link</i></a>DI by example</h2>\n<p>You'll learn Angular Dependency Injection through a discussion of the sample app that accompanies this guide.\nRun the <live-example></live-example> anytime.</p>\n<p>Start by reviewing this simplified version of the <em>heroes</em> feature\nfrom the <a href=\"tutorial/\">The Tour of Heroes</a>.</p>\n<code-tabs>\n  <code-pane title=\"src/app/heroes/heroes.component.ts\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"v1\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero-list.component.ts\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { HEROES }      from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero.ts\" path=\"dependency-injection/src/app/heroes/hero.ts\">\nexport class Hero {\n  id: number;\n  name: string;\n  isSecret = false;\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/mock-heroes.ts\" path=\"dependency-injection/src/app/heroes/mock-heroes.ts\">\nimport { Hero } from './hero';\n\nexport const HEROES: Hero[] = [\n  { id: 11, isSecret: false, name: 'Mr. Nice' },\n  { id: 12, isSecret: false, name: 'Narco' },\n  { id: 13, isSecret: false, name: 'Bombasto' },\n  { id: 14, isSecret: false, name: 'Celeritas' },\n  { id: 15, isSecret: false, name: 'Magneta' },\n  { id: 16, isSecret: false, name: 'RubberMan' },\n  { id: 17, isSecret: false, name: 'Dynama' },\n  { id: 18, isSecret: true,  name: 'Dr IQ' },\n  { id: 19, isSecret: true,  name: 'Magma' },\n  { id: 20, isSecret: true,  name: 'Tornado' }\n];\n\n\n</code-pane>\n\n</code-tabs>\n<p>The <code>HeroesComponent</code> is the top-level heroes component.\nIt's only purpose is to display the <code>HeroListComponent</code>\nwhich displays a list of hero names.</p>\n<p>This version of the <code>HeroListComponent</code> gets its <code>heroes</code> from the <code>HEROES</code> array, an in-memory collection\ndefined in a separate <code>mock-heroes</code> file.</p>\n<code-example title=\"src/app/heroes/hero-list.component.ts (class)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\" region=\"class\">\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n</code-example>\n<p>That may suffice in the early stages of development, but it's far from ideal.\nAs soon as you try to test this component or get heroes from a remote server,\nyou'll have to change the implementation of <code>HerosListComponent</code> and\nreplace every other use of the <code>HEROES</code> mock data.</p>\n<p>It's better to hide these details inside a <em>service</em> class,\n<a href=\"guide/dependency-injection#one-class-per-file\">defined in its own file</a>.</p>\n<h2 id=\"create-an-injectable-heroservice\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#create-an-injectable-heroservice\"><i class=\"material-icons\">link</i></a>Create an injectable <em>HeroService</em></h2>\n<p>The <a href=\"https://cli.angular.io/\"><strong>Angular CLI</strong></a> can generate a new <code>HeroService</code> class in the <code>src/app/heroes</code> folder with this command.</p>\n<code-example language=\"sh\" class=\"code-shell\">\nng generate service heroes/hero\n</code-example>\n<p>That command creates the following <code>HeroService</code> skeleton.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.0.ts\" title=\"src/app/heroes/hero.service.ts (CLI-generated)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n  constructor() { }\n}\n\n\n</code-example>\n<p>Assume for now that the <a href=\"guide/dependency-injection#injectable\"><code>@Injectable</code> decorator</a> is an essential ingredient in every Angular service definition.\nThe rest of the class has been rewritten to expose a <code>getHeroes</code> method\nthat returns the same mock data as before.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.1.ts\" title=\"src/app/heroes/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-example>\n<p>Of course, this isn't a real data service.\nIf the app were actually getting data from a remote server,\nthe <code>getHeroes</code> method signature would have to be asynchronous.</p>\n<p>That's a defect we can safely ignore in this guide where our focus is on\n<em>injecting the service</em> into the <code>HeroList</code> component.</p>\n<a id=\"injector-config\"></a>\n<a id=\"bootstrap\"></a>\n<h2 id=\"register-a-service-provider\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#register-a-service-provider\"><i class=\"material-icons\">link</i></a>Register a service provider</h2>\n<p>A <em>service</em> is just a class in Angular until you register it with an Angular dependency injector.</p>\n<p>An Angular injector is responsible for creating service instances and injecting them into classes like the <code>HeroListComponent</code>.</p>\n<p>You rarely create an Angular injector yourself.\nAngular creates injectors for you as it executes the app,\nstarting with the <em>root injector</em> that it creates during the <a href=\"guide/bootstrapping\">bootstrap process</a>.</p>\n<p>You do have to register <em>providers</em> with an injector\nbefore the injector can create that service.</p>\n<p><strong>Providers</strong> tell the injector <em>how to create the service</em>.\nWithout a provider, the injector would not know\nthat it is responsible for injecting the service\nnor be able to create the service.</p>\n<div class=\"l-sub-section\">\n<p>You'll learn much more about <em>providers</em> <a href=\"guide/dependency-injection#providers\">below</a>.\nFor now it is sufficient to know that they create services\nand must be registered with an injector.</p>\n</div>\n<p>You can register a provider with any Angular decorator that supports the  <strong><code>providers</code> array property</strong>.</p>\n<p>Many Angular decorators accept metadata with a <code>providers</code> property.\nThe two most important examples are <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> and <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>.</p>\n<a id=\"register-providers-component\"></a>\n<h3 id=\"component-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#component-providers\"><i class=\"material-icons\">link</i></a><em>@Component</em> providers</h3>\n<p>Here's a revised <code>HeroesComponent</code> that registers the <code>HeroService</code> in its <code>providers</code> array.</p>\n<code-example path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" title=\"src/app/heroes/heroes.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ HeroService ],\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-example>\n<a id=\"register-providers-ngmodule\"></a>\n<h3 id=\"ngmodule-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#ngmodule-providers\"><i class=\"material-icons\">link</i></a><em>@NgModule</em> providers</h3>\n<p>In the following excerpt, the root <code>AppModule</code> registers two providers in its <code>providers</code> array.</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" linenums=\"false\" title=\"src/app/app.module.ts (providers)\" region=\"providers\">\nproviders: [\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<p>The first entry registers the <code>UserService</code> class (<em>not shown</em>) under the <code>UserService</code> <em>injection token</em>.\nThe second registers a value (<code>HERO_DI_CONFIG</code>) under the <code>APP_CONFIG</code> <em>injection token</em>.</p>\n<p>Thanks to these registrations, Angular can inject the <code>UserService</code> or the <code>HERO_DI_CONFIG</code> value\ninto any class that it creates.</p>\n<div class=\"l-sub-section\">\n<p>You'll learn about <em>injection tokens</em> and <em>provider</em> syntax <a href=\"guide/dependency-injection#providers\">below</a>.</p>\n</div>\n<a id=\"ngmodule-vs-comp\"></a>\n<h3 id=\"ngmodule-or-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#ngmodule-or-component\"><i class=\"material-icons\">link</i></a><em>@NgModule</em> or <em>@Component</em>?</h3>\n<p>Should you register a service with an Angular module or with a component?\nThe two choices lead to differences in service <em>scope</em> and service <em>lifetime</em>.</p>\n<p><strong>Angular module providers</strong> (<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>) are registered with the application's root injector.\nAngular can inject the corresponding services in any class it creates.\nOnce created, a service instance lives for the life of the app and Angular injects this one service instance in every class that needs it.</p>\n<p>You're likely to inject the <code>UserService</code> in many places throughout the app\nand will want to inject the same service instance every time.\nProviding the <code>UserService</code> with an Angular module is a good choice.</p>\n<div class=\"l-sub-section\">\n<p>To be precise, Angular module providers are registered with the root injector\n<em>unless the module is</em> <a href=\"guide/lazy-loading-ngmodules\">lazy loaded</a>.\nIn this sample, all modules are <em>eagerly loaded</em> when the application starts,\nso all module providers are registered with the app's root injector.</p>\n</div><br>\n<hr>\n<p><strong>A component's providers</strong> (<code>@Component.providers</code>) are registered with each component instance's own injector.</p>\n<p>Angular can only inject the corresponding services in that component instance or one of its descendant component instances.\nAngular cannot inject the same service instance anywhere else.</p>\n<p>Note that a component-provided service may have a limited lifetime. Each new instance of the component gets its own instance of the service\nand, when the component instance is destroyed, so is that service instance.</p>\n<p>In this sample app, the <code>HeroComponent</code> is created when the application starts\nand is never destroyed so the <code>HeroService</code> created for the <code>HeroComponent</code> also live for the life of the app.</p>\n<p>If you want to restrict <code>HeroService</code> access to the <code>HeroComponent</code> and its nested <code>HeroListComponent</code>,\nproviding the <code>HeroService</code> in the <code>HeroComponent</code> may be a good choice.</p>\n<div class=\"l-sub-section\">\n<p>The scope and lifetime of component-provided services is a consequence of <a href=\"guide/dependency-injection#component-child-injectors\">the way Angular creates component instances</a>. </p>\n</div>\n<h2 id=\"inject-a-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#inject-a-service\"><i class=\"material-icons\">link</i></a>Inject a service</h2>\n<p>The <code>HeroListComponent</code> should get heroes from the <code>HeroService</code>.</p>\n<p>The component shouldn't create the <code>HeroService</code> with <code>new</code>.\nIt should ask for the <code>HeroService</code> to be injected.</p>\n<p>You can tell Angular to inject a dependency in the component's constructor by specifying a <strong>constructor parameter with the dependency type</strong>.\nHere's the <code>HeroListComponent</code> constructor, asking for the <code>HeroService</code> to be injected.</p>\n<code-example title=\"src/app/heroes/hero-list.component (constructor signature)\" path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p>Of course, the <code>HeroListComponent</code> should do something with the injected <code>HeroService</code>.\nHere's the revised component, making use of the injected service, side-by-side with the previous version for comparison.</p>\n<code-tabs>\n  <code-pane title=\"hero-list.component (with DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.2.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { Hero }        from './hero';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes: Hero[];\n\n  constructor(heroService: HeroService) {\n    this.heroes = heroService.getHeroes();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"hero-list.component (without DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { HEROES }      from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &#x3C;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\">\n      {{hero.id}} - {{hero.name}}\n    &#x3C;/div>\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n</code-tabs>\n<p>Notice that the <code>HeroListComponent</code> doesn't know where the <code>HeroService</code> comes from.\n<em>You</em> know that it comes from the parent <code>HeroesComponent</code>.\nBut if you decided instead to provide the <code>HeroService</code> in the <code>AppModule</code>,\nthe <code>HeroListComponent</code> wouldn't change at all.\nThe <em>only thing that matters</em> is that the <code>HeroService</code> is provided in some parent injector.</p>\n<a id=\"singleton-services\"></a>\n<h2 id=\"singleton-services\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#singleton-services\"><i class=\"material-icons\">link</i></a>Singleton services</h2>\n<p>Services are singletons <em>within the scope of an injector</em>.\nThere is at most one instance of a service in a given injector.</p>\n<p>There is only one root injector and the <code>UserService</code> is registered with that injector.\nTherefore, there can be just one <code>UserService</code> instance in the entire app\nand every class that injects <code>UserService</code> get this service instance.</p>\n<p>However, Angular DI is a\n<a href=\"guide/hierarchical-dependency-injection\">hierarchical injection system</a>,\nwhich means that nested injectors can create their own service instances.\nAngular creates nested injectors all the time.</p>\n<a id=\"component-child-injectors\"></a>\n<h2 id=\"component-child-injectors\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#component-child-injectors\"><i class=\"material-icons\">link</i></a>Component child injectors</h2>\n<p>For example, when Angular creates a new instance of a component that has <code>@Component.providers</code>,\nit also creates a new <em>child injector</em> for that instance.</p>\n<p>Component injectors are independent of each other and\neach of them creates its own instances of the component-provided services.</p>\n<p>When Angular destroys one of these component instance, it also destroys the\ncomponent's injector and that injector's service instances. </p>\n<p>Thanks to <a href=\"guide/hierarchical-dependency-injection\">injector inheritance</a>,\nyou can still inject application-wide services into these components.\nA component's injector is a child of its parent component's injector,\nand a descendent of its parent's parent's injector, and so on all the way back to the application's <em>root</em> injector.\nAngular can inject a service provided by any injector in that lineage.</p>\n<p>For example, Angular could inject a <code>HeroListComponent</code>\nwith both the <code>HeroService</code> provided in <code>HeroComponent</code>\nand the <code>UserService</code> provided in <code>AppModule</code>.</p>\n<a id=\"testing-the-component\"></a>\n<h2 id=\"testing-the-component\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#testing-the-component\"><i class=\"material-icons\">link</i></a>Testing the component</h2>\n<p>Earlier you saw that designing a class for dependency injection makes the class easier to test.\nListing dependencies as constructor parameters may be all you need to test application parts effectively.</p>\n<p>For example, you can create a new <code>HeroListComponent</code> with a mock service that you can manipulate\nunder test:</p>\n<code-example path=\"dependency-injection/src/app/test.component.ts\" region=\"spec\" title=\"src/app/test.component.ts\" linenums=\"false\">\nconst expectedHeroes = [{name: 'A'}, {name: 'B'}]\nconst mockService = &#x3C;HeroService> {getHeroes: () => expectedHeroes }\n\nit('should have heroes when HeroListComponent created', () => {\n  // Pass the mock to the constructor as the Angular injector would\n  const component = new HeroListComponent(mockService);\n  expect(component.heroes.length).toEqual(expectedHeroes.length);\n});\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>Learn more in the <a href=\"guide/testing\">Testing</a> guide.</p>\n</div>\n<a id=\"service-needs-service\"></a>\n<h2 id=\"when-the-service-needs-a-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#when-the-service-needs-a-service\"><i class=\"material-icons\">link</i></a>When the service needs a service</h2>\n<p>The <code>HeroService</code> is very simple. It doesn't have any dependencies of its own.</p>\n<p>What if it had a dependency? What if it reported its activities through a logging service?\nYou'd apply the same <em>constructor injection</em> pattern,\nadding a constructor that takes a <code>Logger</code> parameter.</p>\n<p>Here is the revised <code>HeroService</code> that injects the <code>Logger</code>, side-by-side with the previous service for comparison.</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/hero.service (v2)\" path=\"dependency-injection/src/app/heroes/hero.service.2.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\nimport { Logger }     from '../logger.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero.service (v1)\" path=\"dependency-injection/src/app/heroes/hero.service.1.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p>The constructor asks for an injected instance of a <code>Logger</code> and stores it in a private field called <code>logger</code>.\nThe <code>getHeroes()</code> method logs a message when asked to fetch heroes.</p>\n<a id=\"logger-service\"></a>\n<h4 id=\"the-dependent-logger-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#the-dependent-logger-service\"><i class=\"material-icons\">link</i></a>The dependent <em>Logger</em> service</h4>\n<p>The sample app's <code>Logger</code> service is quite simple:</p>\n<code-example path=\"dependency-injection/src/app/logger.service.ts\" title=\"src/app/logger.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Logger {\n  logs: string[] = []; // capture logs for testing\n\n  log(message: string) {\n    this.logs.push(message);\n    console.log(message);\n  }\n}\n\n\n</code-example>\n<p>If the app didn't provide this <code>Logger</code>,\nAngular would throw an exception when it looked for a <code>Logger</code> to inject\ninto the <code>HeroService</code>.</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ERROR Error: No provider for Logger!\n</code-example>\n<p>Because a singleton logger service is useful everywhere,\nit's provided in the root <code>AppModule</code>.</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" linenums=\"false\" title=\"src/app/app.module.ts (providers)\" region=\"providers-2\">\nproviders: [\n  Logger,\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<a id=\"injectable\"></a>\n<h2 id=\"injectable\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injectable\"><i class=\"material-icons\">link</i></a><em>@Injectable()</em></h2>\n<p>The <strong><a href=\"api/core/Injectable\">@Injectable()</a></strong> decorator identifies a service class\nthat <em>might</em> require injected dependencies.</p>\n<p>The <code>HeroService</code> must be annotated with <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> because it requires an injected <code>Logger</code>.</p>\n<div class=\"alert is-important\">\n<p>Always write <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> with parentheses, not just <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code>.</p>\n</div>\n<p>When Angular creates a class whose constructor has parameters,\nit looks for type and injection metadata about those parameters\nso that it can inject the right service.</p>\n<p>If Angular can't find that parameter information, it throws an error.</p>\n<p>Angular can only find the parameter information <em>if the class has a decorator of some kind</em>.\nWhile <em>any</em> decorator will do,\nthe <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator is the standard decorator for service classes.</p>\n<div class=\"l-sub-section\">\nThe decorator requirement is imposed by TypeScript.\n<p>TypeScript normally discards parameter type information when it <em>transpiles</em> the code to JavaScript.\nIt preserves this information if the class has a decorator\nand the <code>emitDecoratorMetadata</code> compiler option is set <code>true</code>\nin TypeScript's <code>tsconfig.json</code> configuration file, .</p>\n<p>The CLI configures <code>tsconfig.json</code> with <code>emitDecoratorMetadata: true</code>\nIt's your job to put <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> on your service classes.</p>\n</div>\n<p>The <code>Logger</code> service is annotated with <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator too,\nalthough it has no constructor and no dependencies.</p>\n<p>In fact, <em>every</em> Angular service class in this app is annotated with the <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> decorator, whether or not it has a constructor and dependencies.\n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> is a required coding style for services.</p>\n<a id=\"providers\"></a>\n<h2 id=\"providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#providers\"><i class=\"material-icons\">link</i></a>Providers</h2>\n<p>A service provider <em>provides</em> the concrete, runtime version of a dependency value.\nThe injector relies on <strong>providers</strong> to create instances of the services\nthat the injector injects into components, directives, pipes, and other services.</p>\n<p>You must register a service <em>provider</em> with an injector, or it won't know how to create the service.</p>\n<p>The next few sections explain the many ways you can specify a provider.</p>\n<p>Almost all of the accompanying code snippets are extracts from the sample app's <code>providers.component.ts</code> file.</p>\n<h3 id=\"the-class-as-its-own-provider\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#the-class-as-its-own-provider\"><i class=\"material-icons\">link</i></a>The class as its own provider</h3>\n<p>There are many ways to <em>provide</em> something that looks and behaves like a <code>Logger</code>.\nThe <code>Logger</code> class itself is an obvious and natural provider.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p>But it's not the only way.</p>\n<p>You can configure the injector with alternative providers that can deliver an object that behaves like a <code>Logger</code>.\nYou could provide a substitute class. You could provide a logger-like object.\nYou could give it a provider that calls a logger factory function.\nAny of these approaches might be a good choice under the right circumstances.</p>\n<p>What matters is that the injector has a provider to go to when it needs a <code>Logger</code>.</p>\n<a id=\"provide\"></a>\n<h3 id=\"the-provide-object-literal\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#the-provide-object-literal\"><i class=\"material-icons\">link</i></a>The <em>provide</em> object literal</h3>\n<p>Here's the class-provider syntax again.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p>This is actually a shorthand expression for a provider registration\nusing a <em>provider</em> object literal with two properties:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\">\n[{ provide: Logger, useClass: Logger }]\n\n</code-example>\n<p>The <code>provide</code> property holds the <a href=\"guide/dependency-injection#token\">token</a> that serves as the key for both locating a dependency value\nand registering the provider.</p>\n<p>The second property is always a provider definition object,\nwhich you can think of as a <em>recipe</em> for creating the dependency value.\nThere are many ways to create dependency values just as there are many ways to write a recipe.</p>\n<a id=\"class-provider\"></a>\n<h3 id=\"alternative-class-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#alternative-class-providers\"><i class=\"material-icons\">link</i></a>Alternative class providers</h3>\n<p>Occasionally you'll ask a different class to provide the service.\nThe following code tells the injector\nto return a <code>BetterLogger</code> when something asks for the <code>Logger</code>.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\">\n[{ provide: Logger, useClass: BetterLogger }]\n\n</code-example>\n<a id=\"class-provider-dependencies\"></a>\n<h3 id=\"class-provider-with-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#class-provider-with-dependencies\"><i class=\"material-icons\">link</i></a>Class provider with dependencies</h3>\n<p>Maybe an <code>EvenBetterLogger</code> could display the user name in the log message.\nThis logger gets the user from the injected <code>UserService</code>,\nwhich is also injected at the application level.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class EvenBetterLogger extends Logger {\n  constructor(private userService: UserService) { super(); }\n\n  log(message: string) {\n    let name = this.userService.user.name;\n    super.log(`Message to ${name}: ${message}`);\n  }\n}\n\n</code-example>\n<p>Configure it like <code>BetterLogger</code>.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\" linenums=\"false\">\n[ UserService,\n  { provide: Logger, useClass: EvenBetterLogger }]\n\n</code-example>\n<a id=\"aliased-class-providers\"></a>\n<h3 id=\"aliased-class-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#aliased-class-providers\"><i class=\"material-icons\">link</i></a>Aliased class providers</h3>\n<p>Suppose an old component depends upon an <code>OldLogger</code> class.\n<code>OldLogger</code> has the same interface as the <code>NewLogger</code>, but for some reason\nyou can't update the old component to use it.</p>\n<p>When the <em>old</em> component logs a message with <code>OldLogger</code>,\nyou'd like the singleton instance of <code>NewLogger</code> to handle it instead.</p>\n<p>The dependency injector should inject that singleton instance\nwhen a component asks for either the new or the old logger.\nThe <code>OldLogger</code> should be an alias for <code>NewLogger</code>.</p>\n<p>You certainly do not want two different <code>NewLogger</code> instances in your app.\nUnfortunately, that's what you get if you try to alias <code>OldLogger</code> to <code>NewLogger</code> with <code>useClass</code>.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6a\" linenums=\"false\">\n[ NewLogger,\n  // Not aliased! Creates two instances of `NewLogger`\n  { provide: OldLogger, useClass: NewLogger}]\n\n</code-example>\n<p>The solution: alias with the <code>useExisting</code> option.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\" linenums=\"false\">\n[ NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger}]\n\n</code-example>\n<a id=\"value-provider\"></a>\n<h3 id=\"value-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#value-providers\"><i class=\"material-icons\">link</i></a>Value providers</h3>\n<p>Sometimes it's easier to provide a ready-made object rather than ask the injector to create it from a class.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"silent-logger\" linenums=\"false\">\n// An object in the shape of the logger service\nexport function SilentLoggerFn() {}\n\nconst silentLogger = {\n  logs: ['Silent logger says \"Shhhhh!\". Provided via \"useValue\"'],\n  log: SilentLoggerFn\n};\n\n</code-example>\n<p>Then you register a provider with the <code>useValue</code> option,\nwhich makes this object play the logger role.</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-7\" linenums=\"false\">\n[{ provide: Logger, useValue: silentLogger }]\n\n</code-example>\n<p>See more <code>useValue</code> examples in the\n<a href=\"guide/dependency-injection#non-class-dependencies\">Non-class dependencies</a> and\n<a href=\"guide/dependency-injection#injection-token\">InjectionToken</a> sections.</p>\n<a id=\"factory-provider\"></a>\n<h3 id=\"factory-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#factory-providers\"><i class=\"material-icons\">link</i></a>Factory providers</h3>\n<p>Sometimes you need to create the dependent value dynamically,\nbased on information you won't have until the last possible moment.\nMaybe the information changes repeatedly in the course of the browser session.</p>\n<p>Suppose also that the injectable service has no independent access to the source of this information.</p>\n<p>This situation calls for a <strong>factory provider</strong>.</p>\n<p>To illustrate the point, add a new business requirement:\nthe <code>HeroService</code> must hide <em>secret</em> heroes from normal users.\nOnly authorized users should see secret heroes.</p>\n<p>Like the <code>EvenBetterLogger</code>, the <code>HeroService</code> needs a fact about the user.\nIt needs to know if the user is authorized to see secret heroes.\nThat authorization can change during the course of a single application session,\nas when you log in a different user.</p>\n<p>Unlike <code>EvenBetterLogger</code>, you can't inject the <code>UserService</code> into the <code>HeroService</code>.\nThe <code>HeroService</code> won't have direct access to the user information to decide\nwho is authorized and who is not.</p>\n<p>Instead, the <code>HeroService</code> constructor takes a boolean flag to control display of secret heroes.</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" title=\"src/app/heroes/hero.service.ts (excerpt)\" linenums=\"false\">\nconstructor(\n  private logger: Logger,\n  private isAuthorized: boolean) { }\n\ngetHeroes() {\n  let auth = this.isAuthorized ? 'authorized ' : 'unauthorized';\n  this.logger.log(`Getting heroes for ${auth} user.`);\n  return HEROES.filter(hero => this.isAuthorized || !hero.isSecret);\n}\n\n</code-example>\n<p>You can inject the <code>Logger</code>, but you can't inject the  boolean <code>isAuthorized</code>.\nYou'll have to take over the creation of new instances of this <code>HeroService</code> with a factory provider.</p>\n<p>A factory provider needs a factory function:</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" title=\"src/app/heroes/hero.service.provider.ts (excerpt)\" linenums=\"false\">\nlet heroServiceFactory = (logger: Logger, userService: UserService) => {\n  return new HeroService(logger, userService.user.isAuthorized);\n};\n\n</code-example>\n<p>Although the <code>HeroService</code> has no access to the <code>UserService</code>, the factory function does.</p>\n<p>You inject both the <code>Logger</code> and the <code>UserService</code> into the factory provider\nand let the injector pass them along to the factory function:</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" title=\"src/app/heroes/hero.service.provider.ts (excerpt)\" linenums=\"false\">\nexport let heroServiceProvider =\n  { provide: HeroService,\n    useFactory: heroServiceFactory,\n    deps: [Logger, UserService]\n  };\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>The <code>useFactory</code> field tells Angular that the provider is a factory function\nwhose implementation is the <code>heroServiceFactory</code>.</p>\n<p>The <code>deps</code> property is an array of <a href=\"guide/dependency-injection#token\">provider tokens</a>.\nThe <code>Logger</code> and <code>UserService</code> classes serve as tokens for their own class providers.\nThe injector resolves these tokens and injects the corresponding services into the matching factory function parameters.</p>\n</div>\n<p>Notice that you captured the factory provider in an exported variable, <code>heroServiceProvider</code>.\nThis extra step makes the factory provider reusable.\nYou can register the <code>HeroService</code> with this variable wherever you need it.</p>\n<p>In this sample, you need it only in the <code>HeroesComponent</code>,\nwhere it replaces the previous <code>HeroService</code> registration in the metadata <code>providers</code> array.\nHere you see the new and the old implementation side-by-side:</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/heroes.component (v3)\" path=\"dependency-injection/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }          from '@angular/core';\nimport { heroServiceProvider } from './hero.service.provider';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ heroServiceProvider ],\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/heroes.component (v2)\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ HeroService ],\n  template: `\n    &#x3C;h2>Heroes&#x3C;/h2>\n    &#x3C;app-hero-list>&#x3C;/app-hero-list>\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n</code-tabs>\n<a id=\"token\"></a>\n<h2 id=\"dependency-injection-tokens\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#dependency-injection-tokens\"><i class=\"material-icons\">link</i></a>Dependency injection tokens</h2>\n<p>When you register a provider with an injector, you associate that provider with a dependency injection token.\nThe injector maintains an internal <em>token-provider</em> map that it references when\nasked for a dependency. The token is the key to the map.</p>\n<p>In all previous examples, the dependency value has been a class <em>instance</em>, and\nthe class <em>type</em> served as its own lookup key.\nHere you get a <code>HeroService</code> directly from the injector by supplying the <code>HeroService</code> type as the token:</p>\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" title=\"src/app/injector.component.ts\" linenums=\"false\">\nheroService: HeroService;\n\n</code-example>\n<p>You have similar good fortune when you write a constructor that requires an injected class-based dependency.\nWhen you define a constructor parameter with the <code>HeroService</code> class type,\nAngular knows to inject the\nservice associated with that <code>HeroService</code> class token:</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" title=\"src/app/heroes/hero-list.component.ts\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p>This is especially convenient when you consider that most dependency values are provided by classes.</p>\n<a id=\"non-class-dependencies\"></a>\n<h3 id=\"non-class-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#non-class-dependencies\"><i class=\"material-icons\">link</i></a>Non-class dependencies</h3>\n<p>What if the dependency value isn't a class? Sometimes the thing you want to inject is a\nstring, function, or object.</p>\n<p>Applications often define configuration objects with lots of small facts\n(like the title of the application or the address of a web API endpoint)\nbut these configuration objects aren't always instances of a class.\nThey can be object literals such as this one:</p>\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"config\" title=\"src/app/app.config.ts (excerpt)\" linenums=\"false\">\nexport const HERO_DI_CONFIG: AppConfig = {\n  apiEndpoint: 'api.heroes.com',\n  title: 'Dependency Injection'\n};\n\n\n</code-example>\n<p>What if you'd like to make this configuration object available for injection?\nYou know you can register an object with a <a href=\"guide/dependency-injection#value-provider\">value provider</a>.</p>\n<p>But what should you use as the token?\nYou don't have a class to serve as a token.\nThere is no <code>AppConfig</code> class.</p>\n<div class=\"l-sub-section\">\n<h3 id=\"typescript-interfaces-arent-valid-tokens\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#typescript-interfaces-arent-valid-tokens\"><i class=\"material-icons\">link</i></a>TypeScript interfaces aren't valid tokens</h3>\n<p>The <code>HERO_DI_CONFIG</code> constant conforms to the <code>AppConfig</code> interface.\nUnfortunately, you cannot use a TypeScript interface as a token:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\" linenums=\"false\">\n// FAIL! Can't use interface as provider token\n[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\" linenums=\"false\">\n// FAIL! Can't <a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a> using the interface as the parameter type\nconstructor(private config: AppConfig){ }\n\n</code-example>\n<p>That seems strange if you're used to dependency injection in strongly typed languages, where\nan interface is the preferred dependency lookup key.</p>\n<p>It's not Angular's doing. An interface is a TypeScript design-time artifact. JavaScript doesn't have interfaces.\nThe TypeScript interface disappears from the generated JavaScript.\nThere is no interface type information left for Angular to find at runtime.</p>\n</div>\n<a id=\"injection-token\"></a>\n<h3 id=\"injectiontoken\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#injectiontoken\"><i class=\"material-icons\">link</i></a><em>InjectionToken</em></h3>\n<p>One solution to choosing a provider token for non-class dependencies is\nto define and use an <a href=\"api/core/InjectionToken\"><em>InjectionToken</em></a>.\nThe definition of such a token looks like this:</p>\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"token\" title=\"src/app/app.config.ts\" linenums=\"false\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const APP_CONFIG = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&#x3C;AppConfig>('app.config');\n\n</code-example>\n<p>The type parameter, while optional, conveys the dependency's type to developers and tooling.\nThe token description is another developer aid.</p>\n<p>Register the dependency provider using the <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> object:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9\" linenums=\"false\">\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]\n\n</code-example>\n<p>Now you can inject the configuration object into any constructor that needs it, with\nthe help of an <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> decorator:</p>\n<code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" title=\"src/app/app.component.ts\" linenums=\"false\">\nconstructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(APP_CONFIG) config: AppConfig) {\n  this.title = config.title;\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>Although the <code>AppConfig</code> interface plays no role in dependency injection,\nit supports typing of the configuration object within the class.</p>\n</div>\n<p>Alternatively, you can provide and inject the configuration object in an ngModule like <code>AppModule</code>.</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" region=\"providers\" title=\"src/app/app.module.ts (providers)\">\nproviders: [\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<a id=\"optional\"></a>\n<h2 id=\"optional-dependencies\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#optional-dependencies\"><i class=\"material-icons\">link</i></a>Optional dependencies</h2>\n<p>The <code>HeroService</code> <em>requires</em> a <code>Logger</code>, but what if it could get by without\na <code>logger</code>?\nYou can tell Angular that the dependency is optional by annotating the\nconstructor argument with <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>:</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"import-optional\">\nimport { <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> } from '@angular/core';\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-10-ctor\" linenums=\"false\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() private logger: Logger) {\n  if (this.logger) {\n    this.logger.log(some_message);\n  }\n}\n\n</code-example>\n<p>When using <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>, your code must be prepared for a null value. If you\ndon't register a <code>logger</code> somewhere up the line, the injector will set the\nvalue of <code>logger</code> to null.</p>\n<h2 id=\"summary\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#summary\"><i class=\"material-icons\">link</i></a>Summary</h2>\n<p>You learned the basics of Angular dependency injection in this page.\nYou can register various kinds of providers,\nand you know how to ask for an injected object (such as a service) by\nadding a parameter to a constructor.</p>\n<p>Angular dependency injection is more capable than this guide has described.\nYou can learn more about its advanced features, beginning with its support for\nnested injectors, in\n<a href=\"guide/hierarchical-dependency-injection\">Hierarchical Dependency Injection</a>.</p>\n<a id=\"explicit-injector\"></a>\n<h2 id=\"appendix-working-with-injectors-directly\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#appendix-working-with-injectors-directly\"><i class=\"material-icons\">link</i></a>Appendix: Working with injectors directly</h2>\n<p>Developers rarely work directly with an injector, but\nhere's an <code>InjectorComponent</code> that does.</p>\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"injector\" title=\"src/app/injector.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-injectors',\n  template: `\n  &#x3C;h2>Other Injections&#x3C;/h2>\n  &#x3C;div id=\"car\">{{car.drive()}}&#x3C;/div>\n  &#x3C;div id=\"hero\">{{hero.name}}&#x3C;/div>\n  &#x3C;div id=\"rodent\">{{rodent}}&#x3C;/div>\n  `,\n  providers: [Car, Engine, Tires, heroServiceProvider, Logger]\n})\nexport class InjectorComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  car: Car;\n\n  heroService: HeroService;\n  hero: Hero;\n\n  constructor(private injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) { }\n\n  ngOnInit() {\n    this.car = this.injector.get(Car);\n    this.heroService = this.injector.get(HeroService);\n    this.hero = this.heroService.getHeroes()[0];\n  }\n\n  get rodent() {\n    let rousDontExist = `R.O.U.S.'s? I don't think they exist!`;\n    return this.injector.get(ROUS, rousDontExist);\n  }\n}\n\n</code-example>\n<p>An <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> is itself an injectable service.</p>\n<p>In this example, Angular injects the component's own <code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> into the component's constructor.\nThe component then asks the injected injector for the services it wants in <code>ngOnInit()</code>.</p>\n<p>Note that the services themselves are not injected into the component.\nThey are retrieved by calling <code>injector.get()</code>.</p>\n<p>The <code>get()</code> method throws an error if it can't resolve the requested service.\nYou can call <code>get()</code> with a second parameter, which is the value to return if the service\nis not found. Angular can't find the service if it's not registered with this or any ancestor injector.</p>\n<div class=\"l-sub-section\">\n<p>The technique is an example of the\n<a href=\"https://en.wikipedia.org/wiki/Service_locator_pattern\">service locator pattern</a>.</p>\n<p><strong>Avoid</strong> this technique unless you genuinely need it.\nIt encourages a careless grab-bag approach such as you see here.\nIt's difficult to explain, understand, and test.\nYou can't know by inspecting the constructor what this class requires or what it will do.\nIt could acquire services from any ancestor component, not just its own.\nYou're forced to spelunk the implementation to discover what it does.</p>\n<p>Framework developers may take this approach when they\nmust acquire services generically and dynamically.</p>\n</div>\n<a id=\"one-class-per-file\"></a>\n<h2 id=\"appendix-one-class-per-file\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection#appendix-one-class-per-file\"><i class=\"material-icons\">link</i></a>Appendix: one class per file</h2>\n<p>Having multiple classes in the same file is confusing and best avoided.\nDevelopers expect one class per file. Keep them happy.</p>\n<p>If you combine the <code>HeroService</code> class with\nthe <code>HeroesComponent</code> in the same file,\n<strong>define the component last</strong>.\nIf you define the component before the service,\nyou'll get a runtime null reference error.</p>\n<div class=\"l-sub-section\">\n<p>You actually can define the component first with the help of the <code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> method as explained\nin this <a href=\"http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\">blog post</a>.</p>\n<p>But it's best to avoid the problem altogether by defining components and services in separate files.</p>\n</div>\n\n</div>\n<!-- links to this doc:\n - api/core/ClassProvider\n - api/core/ExistingProvider\n - api/core/FactoryProvider\n - api/core/Host\n - api/core/HostDecorator\n - api/core/Inject\n - api/core/InjectDecorator\n - api/core/Injectable\n - api/core/InjectableDecorator\n - api/core/Injector\n - api/core/Optional\n - api/core/OptionalDecorator\n - api/core/Provider\n - api/core/Self\n - api/core/SelfDecorator\n - api/core/SkipSelf\n - api/core/SkipSelfDecorator\n - api/core/StaticProvider\n - api/core/TypeProvider\n - api/core/ValueProvider\n - guide/architecture-services\n - guide/attribute-directives\n - guide/dependency-injection-in-action\n - guide/dependency-injection-pattern\n - guide/glossary\n - guide/hierarchical-dependency-injection\n - guide/http\n - guide/router\n - guide/sharing-ngmodules\n - guide/testing\n - guide/upgrade\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/core/Component\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Injector\n - api/core/NgModule\n - api/core/NgModule#providers\n - api/core/OnInit\n - api/core/Optional\n - api/core/forwardRef\n - api/core/testing/inject\n - guide/bootstrapping\n - guide/dependency-injection#aliased-class-providers\n - guide/dependency-injection#alternative-class-providers\n - guide/dependency-injection#angular-dependency-injection\n - guide/dependency-injection#appendix-one-class-per-file\n - guide/dependency-injection#appendix-working-with-injectors-directly\n - guide/dependency-injection#class-provider-with-dependencies\n - guide/dependency-injection#component-child-injectors\n - guide/dependency-injection#component-providers\n - guide/dependency-injection#create-an-injectable-heroservice\n - guide/dependency-injection#dependency-injection-tokens\n - guide/dependency-injection#di-by-example\n - guide/dependency-injection#factory-providers\n - guide/dependency-injection#inject-a-service\n - guide/dependency-injection#injectable\n - guide/dependency-injection#injection-token\n - guide/dependency-injection#injectiontoken\n - guide/dependency-injection#ngmodule-or-component\n - guide/dependency-injection#ngmodule-providers\n - guide/dependency-injection#non-class-dependencies\n - guide/dependency-injection#one-class-per-file\n - guide/dependency-injection#optional-dependencies\n - guide/dependency-injection#providers\n - guide/dependency-injection#register-a-service-provider\n - guide/dependency-injection#singleton-services\n - guide/dependency-injection#summary\n - guide/dependency-injection#testing-the-component\n - guide/dependency-injection#the-class-as-its-own-provider\n - guide/dependency-injection#the-dependent-logger-service\n - guide/dependency-injection#the-provide-object-literal\n - guide/dependency-injection#token\n - guide/dependency-injection#typescript-interfaces-arent-valid-tokens\n - guide/dependency-injection#value-provider\n - guide/dependency-injection#value-providers\n - guide/dependency-injection#when-the-service-needs-a-service\n - guide/dependency-injection-pattern\n - guide/hierarchical-dependency-injection\n - guide/lazy-loading-ngmodules\n - guide/testing\n - tutorial/\n - http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\n - https://cli.angular.io/\n - https://en.wikipedia.org/wiki/Service_locator_pattern\n-->"
}