{
  "id" : "guide/dependency-injection",
  "title" : "Angular 依赖注入",
  "contents" : "<div class=\"content\">\n<h1 id=\"angular-dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tbhv2c49ywkecq2jeuxqcoqy\"><i class=\"material-icons\">link</i>Angular 依赖注入</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2eun8enq6nc603ihbg5huvkes\"><strong>依赖注入 (DI)</strong> 是一种创建依赖于其他对象的类的机制。 依赖注入系统在创建对象实例时提供依赖对象（称为\n<em>依赖项</em>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rio3mrzbrl9df3zz1n8fiis9\"><a href=\"guide/dependency-injection-pattern\">依赖注入模式</a> 页面描述了这种通用方法。 \n<em>你正在阅读的指南</em>解释了 Angular 自己的依赖注入系统的工作原理。</p>\n<h2 id=\"di-by-example\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cabaepfdjflvkihzbj8y70ph4\"><i class=\"material-icons\">link</i>通过示例了解 DI</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5gldtm9cxvsew3eh0oq2kgf7h\">你将通过讨论本指南附带的示例应用程序来学习 Angular 依赖注入。 随时运行 \n<live-example></live-example>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"852t5zkv9ug3k9yxgxta5nylo\">首先，回顾一下来自 \n<a href=\"tutorial/\">英雄之旅</a> 的\n<em>英雄</em>特性的简化版本。</p>\n<code-tabs>\n  <code-pane title=\"src/app/heroes/heroes.component.ts\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" region=\"v1\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  template: `\n    &lt;h2&gt;Heroes&lt;/h2&gt;\n    &lt;app-hero-list&gt;&lt;/app-hero-list&gt;\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero-list.component.ts\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { HEROES }      from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;\n      {{hero.id}} - {{hero.name}}\n    &lt;/div&gt;\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero.ts\" path=\"dependency-injection/src/app/heroes/hero.ts\">\nexport class Hero {\n  id: number;\n  name: string;\n  isSecret = false;\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/mock-heroes.ts\" path=\"dependency-injection/src/app/heroes/mock-heroes.ts\">\nimport { Hero } from './hero';\n\nexport const HEROES: Hero[] = [\n  { id: 11, isSecret: false, name: 'Mr. Nice' },\n  { id: 12, isSecret: false, name: 'Narco' },\n  { id: 13, isSecret: false, name: 'Bombasto' },\n  { id: 14, isSecret: false, name: 'Celeritas' },\n  { id: 15, isSecret: false, name: 'Magneta' },\n  { id: 16, isSecret: false, name: 'RubberMan' },\n  { id: 17, isSecret: false, name: 'Dynama' },\n  { id: 18, isSecret: true,  name: 'Dr IQ' },\n  { id: 19, isSecret: true,  name: 'Magma' },\n  { id: 20, isSecret: true,  name: 'Tornado' }\n];\n\n\n</code-pane>\n\n</code-tabs>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tsuc7abw48zmqj9ehe63h71b\"><code>HeroesComponent</code> 是顶级的英雄组件。 它的唯一目的是显示 \n<code>HeroListComponent</code>， 它显示一个英雄名称列表。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8lkgdo1w7quhk77582a1qvkcb\">此版本的 \n<code>HeroListComponent</code> 从 \n<code>HEROES</code> 数组中获取其 \n<code>heroes</code>，这是一个在单独的 \n<code>mock-heroes</code> 文件中定义的内存集合。</p>\n<code-example title=\"src/app/heroes/hero-list.component.ts (class)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\" region=\"class\">\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zhtcjq6um9kfgiztypzbxwge\">这在开发的早期阶段可能就足够了，但它远非理想。 一旦你尝试测试此组件或从远程服务器获取英雄， 你就必须更改 \n<code>HerosListComponent</code> 的实现， 并替换 \n<code>HEROES</code> 模拟数据的其他所有使用方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9fjgjop8ie8kaeawnirpwrzbv\">最好将这些细节隐藏在一个\n<em>服务</em>类中， \n<a href=\"guide/dependency-injection#one-class-per-file\">在它自己的文件中定义</a>。</p>\n<h2 id=\"create-an-injectable-heroservice\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2t9m23oecd9m18xmlmtafchk0\"><i class=\"material-icons\">link</i>创建一个可注入的 \n<em>HeroService</em></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4sjsigiutocfbuw2i11l4z8ua\"><a href=\"https://cli.angular.io/\"><strong>Angular CLI</strong></a> 可以使用以下命令在 \n<code>src/app/heroes</code> 文件夹中生成一个新的 \n<code>HeroService</code> 类。</p>\n<code-example language=\"sh\" class=\"code-shell\">\nng generate service heroes/hero\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"anntrwqrhmq03koqbts1ated9\">该命令创建了以下 \n<code>HeroService</code> 骨架。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.0.ts\" title=\"src/app/heroes/hero.service.ts (CLI-generated)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n  constructor() { }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4at1qa6w7hsds0b7key17em89\">现在假设 \n<a href=\"guide/dependency-injection#injectable\"><code>@Injectable</code> 装饰器</a> 是每个 Angular 服务定义中必不可少的元素。 该类的其余部分已被重写，以公开一个 \n<code>getHeroes</code> 方法， 该方法返回与以前相同的模拟数据。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.1.ts\" title=\"src/app/heroes/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7u0cuierk8z8rlam29x0igeeq\">当然，这不是一个真正的数据服务。 如果应用程序实际上是从远程服务器获取数据， \n<code>getHeroes</code> 方法签名必须是异步的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wkzrt80qhjwqwnhyehwgvrrk\">在本指南中，我们可以安全地忽略这个缺陷，因为我们的重点是 \n<em>将服务注入</em>到 \n<code>HeroList</code> 组件中。</p>\n<a id=\"injector-config\"></a>\n<a id=\"bootstrap\"></a>\n<h2 id=\"register-a-service-provider\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cojze3hbnsqaytiq4emqx0ezj\"><i class=\"material-icons\">link</i>注册一个服务提供者</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99nvnstmcopxmp82esy8i9rny\">在 Angular 中，\n<em>服务</em>只是一个类，直到你将其注册到 Angular 依赖注入器中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d21jxgki7y6xdjh9ikzp0i8n3\">Angular 注入器负责创建服务实例并将它们注入到像 \n<code>HeroListComponent</code> 这样的类中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yl2bc62d98ywd5b7v0bj03wv\">你很少自己创建 Angular 注入器。 Angular 在执行应用程序时为你创建注入器， 从它在 \n<a href=\"guide/bootstrapping\">引导过程</a> 中创建的\n<em>根注入器</em>开始。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35mtireu65kcsj3bh4bfscn37\">你确实必须向注入器注册\n<em>提供者</em>， 这样注入器才能创建该服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e40xizkvspqr4ll914ugtugcn\"><strong>提供者</strong>告诉注入器\n<em>如何创建服务</em>。 如果没有提供者，注入器将不知道 它负责注入服务， 也无法创建服务。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"enoo42ptdik9vn7l7qf6fpix5\">你将在 \n<a href=\"guide/dependency-injection#providers\">下方</a> 了解有关 \n<em>提供者</em> 的更多信息。 现在，你只需要知道它们创建服务，并且必须在注入器中注册。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"11k4vnhtdreu83r1ftnqd2gyw\">你可以在支持 \n<strong><code>providers</code> 数组属性</strong> 的任何 Angular 装饰器中注册提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5nh8cpxyktmwokku4mn6d17q8\">许多 Angular 装饰器接受带有 \n<code>providers</code> 属性的元数据。 两个最重要的示例是 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 和 \n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>。</p>\n<a id=\"register-providers-component\"></a>\n<h3 id=\"component-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15widtvplwc0nqk41jsqn2gy0\"><i class=\"material-icons\">link</i><em>@Component</em> 提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5dz9e4mr3c3swd585sya3y69\">以下是一个修改后的 \n<code>HeroesComponent</code>，它在 \n<code>providers</code> 数组中注册了 \n<code>HeroService</code>。</p>\n<code-example path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\" title=\"src/app/heroes/heroes.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ HeroService ],\n  template: `\n    &lt;h2&gt;Heroes&lt;/h2&gt;\n    &lt;app-hero-list&gt;&lt;/app-hero-list&gt;\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-example>\n<a id=\"register-providers-ngmodule\"></a>\n<h3 id=\"ngmodule-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aysbnnx2zauywvar3kb6zsf3v\"><i class=\"material-icons\">link</i><em>@NgModule</em> 提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59iwpygphves9m0b9y666h2b8\">在以下摘录中，根 \n<code>AppModule</code> 在其 \n<code>providers</code> 数组中注册了两个提供者。</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" linenums=\"false\" title=\"src/app/app.module.ts (providers)\" region=\"providers\">\nproviders: [\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9q5cd0bjxb85g40n4hgpn6gn4\">第一个条目在 \n<code>UserService</code> \n<em>注入令牌</em> 下注册 \n<code>UserService</code> 类（\n<em>未显示</em>）。 第二个在 \n<code>APP_CONFIG</code> \n<em>注入令牌</em> 下注册一个值（\n<code>HERO_DI_CONFIG</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzl96sliq6fmioda7etdqf44m\">由于这些注册，Angular 可以将 \n<code>UserService</code> 或 \n<code>HERO_DI_CONFIG</code> 值 注入到它创建的任何类中。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8956afllsqoziepa5qczxhnxv\">你将在 \n<a href=\"guide/dependency-injection#providers\">下方</a> 了解有关 \n<em>注入令牌</em> 和 \n<em>提供者</em> 语法的更多信息。</p>\n</div>\n<a id=\"ngmodule-vs-comp\"></a>\n<h3 id=\"ngmodule-or-component\"><em>@NgModule</em> or <em>@Component</em>?</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1s7jcnqyunm82s6fe3epwgda4\">你应该在 Angular 模块中注册服务还是在组件中注册服务？ 这两种选择会导致服务 \n<em>作用域</em> 和服务 \n<em>生命周期</em> 的差异。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eb9vxf6s7d67rfc96cjo9mog7\"><strong>Angular 模块提供者</strong>（\n<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>）在应用程序的根注入器中注册。 Angular 可以将相应的服务注入到它创建的任何类中。 创建后，服务实例将持续存在于应用程序的生命周期中，并且 Angular 会将此服务实例注入到需要它的每个类中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bxt6l8dfegsh857j0tsqm7eop\">你可能需要在整个应用程序的许多地方注入 \n<code>UserService</code>，并且每次都希望注入相同的服务实例。 在 Angular 模块中提供 \n<code>UserService</code> 是一个不错的选择。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c51wne72e4fxpkj23s3u7no9a\">准确地说，Angular 模块提供者在根注入器中注册， \n<em>除非该模块是</em> \n<a href=\"guide/lazy-loading-ngmodules\">惰性加载的</a>。 在此示例中，所有模块在应用程序启动时都是 \n<em>急性加载的</em>， 因此所有模块提供者都在应用程序的根注入器中注册。</p>\n</div><br>\n<hr>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2twfd9gt50xhbo8y0j1qitin\"><strong>组件的提供者</strong>（\n<code>@Component.providers</code>）在每个组件实例的自身注入器中注册。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34ag5mapmqyhoqffa6dbs5sbv\">Angular 只能将相应的服务注入到该组件实例或其任何后代组件实例中。 Angular 无法将相同的服务实例注入到其他任何地方。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"elrij1akd4rgdzal6r9vopcpy\">请注意，组件提供的服务可能具有有限的生命周期。组件的每个新实例都会获得服务自身的实例，并且当组件实例被销毁时，该服务实例也会被销毁。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"br1tdnis6520ij25yp4m5fczc\">在此示例应用程序中，\n<code>HeroComponent</code> 在应用程序启动时创建，并且永远不会被销毁，因此为 \n<code>HeroComponent</code> 创建的 \n<code>HeroService</code> 也将持续存在于应用程序的生命周期中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76t74cv72xzgpwcjk1tzks4fx\">如果你想将 \n<code>HeroService</code> 的访问权限限制在 \n<code>HeroComponent</code> 及其嵌套的 \n<code>HeroListComponent</code> 中， 那么在 \n<code>HeroComponent</code> 中提供 \n<code>HeroService</code> 可能是一个不错的选择。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"baqu96y6nw7pwcom9xykk3kja\">组件提供的服务的范围和生命周期是 \n<a href=\"guide/dependency-injection#component-child-injectors\">Angular 创建组件实例的方式</a> 的结果。</p>\n</div>\n<h2 id=\"inject-a-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54xzyjesagxjzrws3tvcm0bsu\"><i class=\"material-icons\">link</i>注入服务</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bf4gkoryyx6tv40ujcgswmtfd\"><code>HeroListComponent</code> 应该从 \n<code>HeroService</code> 获取英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsuccze4dr8th9yptjgyv0k4f\">组件不应该使用 \n<code>new</code> 创建 \n<code>HeroService</code>。 它应该请求注入 \n<code>HeroService</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahvai43dq4x9a104zcm0a023p\">你可以通过指定一个 \n<strong>带有依赖类型</strong> 的构造函数参数来告诉 Angular 在组件的构造函数中注入依赖项。 以下是 \n<code>HeroListComponent</code> 构造函数，它请求注入 \n<code>HeroService</code>。</p>\n<code-example title=\"src/app/heroes/hero-list.component (constructor signature)\" path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3d0wdotqg5sicjj3y8m1mz4zo\">当然，\n<code>HeroListComponent</code> 应该对注入的 \n<code>HeroService</code> 做点什么。 以下是修改后的组件，它使用注入的服务，并与之前的版本并排比较。</p>\n<code-tabs>\n  <code-pane title=\"hero-list.component (with DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.2.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { Hero }        from './hero';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;\n      {{hero.id}} - {{hero.name}}\n    &lt;/div&gt;\n  `\n})\nexport class HeroListComponent {\n  heroes: Hero[];\n\n  constructor(heroService: HeroService) {\n    this.heroes = heroService.getHeroes();\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"hero-list.component (without DI)\" path=\"dependency-injection/src/app/heroes/hero-list.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }   from '@angular/core';\nimport { HEROES }      from './mock-heroes';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;\n      {{hero.id}} - {{hero.name}}\n    &lt;/div&gt;\n  `\n})\nexport class HeroListComponent {\n  heroes = HEROES;\n}\n\n\n</code-pane>\n</code-tabs>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2w8yyzez7e7jrec5bqez6pl5m\">请注意，\n<code>HeroListComponent</code> 不知道 \n<code>HeroService</code> 来自哪里。 \n<em>你</em>知道它来自父 \n<code>HeroesComponent</code>。 但是，如果你决定在 \n<code>AppModule</code> 中提供 \n<code>HeroService</code>， \n<code>HeroListComponent</code> 根本不会改变。 \n<em>唯一重要的事情</em> 是 \n<code>HeroService</code> 在某个父注入器中提供。</p>\n<a id=\"singleton-services\"></a>\n<h2 id=\"singleton-services\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"essl9gfrqg45g47n7kl5z0gxp\"><i class=\"material-icons\">link</i>单例服务</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4tz0hegt887poh0dw67szg7mr\">服务在 \n<em>注入器范围内</em> 是单例的。 在给定的注入器中，最多只有一个服务实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2tqb13ou0hz8pnlecb54gsq7\">只有一个根注入器，并且 \n<code>UserService</code> 在该注入器中注册。 因此，整个应用程序中只能有一个 \n<code>UserService</code> 实例，并且每个注入 \n<code>UserService</code> 的类都会获得此服务实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du2lg8xjhxkwup0r4rjsg8y92\">但是，Angular DI 是一个 \n<a href=\"guide/hierarchical-dependency-injection\">分层注入系统</a>， 这意味着嵌套注入器可以创建自己的服务实例。 Angular 一直在创建嵌套注入器。</p>\n<a id=\"component-child-injectors\"></a>\n<h2 id=\"component-child-injectors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2witjbg0khogcdn9tt387sojs\"><i class=\"material-icons\">link</i>组件子注入器</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46vekl4b5tf2bj9n4qs2yd57j\">例如，当 Angular 创建一个具有 \n<code>@Component.providers</code> 的组件的新实例时， 它还会为该实例创建一个新的 \n<em>子注入器</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1w5492gdqpspo5cieew2vwmb9\">组件注入器彼此独立，并且 它们中的每一个都会创建组件提供的服务的自身实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60mavfsd9bx6fixwurtp3xzhb\">当 Angular 销毁这些组件实例之一时，它也会销毁 组件的注入器以及该注入器的服务实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2lofnox0uo7b0664etv8ei9mt\">由于 \n<a href=\"guide/hierarchical-dependency-injection\">注入器继承</a>， 你仍然可以将应用程序范围的服务注入到这些组件中。 组件的注入器是其父组件注入器的子级， 并且是其父级的父级注入器的后代，依此类推，一直回到应用程序的 \n<em>根</em> 注入器。 Angular 可以注入由该继承链中的任何注入器提供的服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56fjxqclxq26ak4vl0qfmqms2\">例如，Angular 可以将 \n<code>HeroListComponent</code> 注入 \n<code>HeroComponent</code> 中提供的 \n<code>HeroService</code> 以及 \n<code>AppModule</code> 中提供的 \n<code>UserService</code>。</p>\n<a id=\"testing-the-component\"></a>\n<h2 id=\"testing-the-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26x0t284ru8wgnszz1tey6cjq\"><i class=\"material-icons\">link</i>测试组件</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6obs6foliwmg1mq13rsyg350n\">之前你看到，为依赖注入设计一个类可以使该类更容易测试。 将依赖项列为构造函数参数可能是有效测试应用程序部分所需的一切。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8pnmrxy4h7ys34zhtlu1fkdm\">例如，你可以使用一个模拟服务创建一个新的 \n<code>HeroListComponent</code>，你可以在测试中操纵该服务：</p>\n<code-example path=\"dependency-injection/src/app/test.component.ts\" region=\"spec\" title=\"src/app/test.component.ts\" linenums=\"false\">\nconst expectedHeroes = [{name: 'A'}, {name: 'B'}]\nconst mockService = &lt;HeroService&gt; {getHeroes: () =&gt; expectedHeroes }\n\nit('should have heroes when HeroListComponent created', () =&gt; {\n  // Pass the mock to the constructor as the Angular injector would\n  const component = new HeroListComponent(mockService);\n  expect(component.heroes.length).toEqual(expectedHeroes.length);\n});\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2l7lnsla89tyr17h6ch2xqf5c\">在 \n<a href=\"guide/testing\">测试</a> 指南中了解更多信息。</p>\n</div>\n<a id=\"service-needs-service\"></a>\n<h2 id=\"when-the-service-needs-a-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cpgu4g2ux12t2ldol5dvh8mru\"><i class=\"material-icons\">link</i>当服务需要服务时</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amle129uu5cskjybe6top8gh0\"><code>HeroService</code> 非常简单。它本身没有任何依赖项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1sic8oplekzb1ja63bwgzqid4\">如果它有依赖项怎么办？如果它通过日志服务报告其活动怎么办？ 你会应用相同的 \n<em>构造函数注入</em> 模式， 添加一个接受 \n<code>Logger</code> 参数的构造函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15mc14djdl4gxq9jxxauzw7ep\">以下是修改后的 \n<code>HeroService</code>，它注入 \n<code>Logger</code>，并与之前的服务并排比较。</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/hero.service (v2)\" path=\"dependency-injection/src/app/heroes/hero.service.2.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\nimport { Logger }     from '../logger.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n\n  constructor(private logger: Logger) {  }\n\n  getHeroes() {\n    this.logger.log('Getting heroes ...');\n    return HEROES;\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/hero.service (v1)\" path=\"dependency-injection/src/app/heroes/hero.service.1.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { HEROES }     from './mock-heroes';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n  getHeroes() { return HEROES; }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1tgvhn2ewgudt80fnk21m5usg\">构造函数请求注入 \n<code>Logger</code> 的实例，并将其存储在一个名为 \n<code>logger</code> 的私有字段中。 \n<code>getHeroes()</code> 方法在被要求获取英雄时记录一条消息。</p>\n<a id=\"logger-service\"></a>\n<h4 id=\"the-dependent-logger-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9r00ywciw7932mkjkqilficlh\"><i class=\"material-icons\">link</i>依赖的 \n<em>Logger</em> 服务</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bmi3zt517mzpil9x1v6s7fjg\">示例应用程序的 \n<code>Logger</code> 服务非常简单：</p>\n<code-example path=\"dependency-injection/src/app/logger.service.ts\" title=\"src/app/logger.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Logger {\n  logs: string[] = []; // capture logs for testing\n\n  log(message: string) {\n    this.logs.push(message);\n    console.log(message);\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bb0ql0soxao89b9a4zoortg8g\">如果应用程序没有提供此 \n<code>Logger</code>， Angular 会在查找要注入到 \n<code>HeroService</code> 中的 \n<code>Logger</code> 时抛出异常。</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ERROR Error: No provider for Logger!\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xwl46gbnmwtpgvecq60zle1w\">因为单例日志服务在任何地方都有用， 所以它在根 \n<code>AppModule</code> 中提供。</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" linenums=\"false\" title=\"src/app/app.module.ts (providers)\" region=\"providers-2\">\nproviders: [\n  Logger,\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<a id=\"injectable\"></a>\n<h2 id=\"injectable\"><em>@Injectable()</em></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b09xr75h1e7pmn112khrautli\"><strong><a href=\"api/core/Injectable\">@Injectable()</a></strong> 装饰器标识一个可能需要注入依赖项的服务类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsu3is12sb9gdxsdchlvt7w20\"><code>HeroService</code> 必须用 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 注解，因为它需要注入 \n<code>Logger</code>。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ac4a2pkmfayg3xytcmupf8tqu\">始终使用带括号的 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>，而不是 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eogckf6y81d7kfqalnb7znq57\">当 Angular 创建一个构造函数带有参数的类时，它会查找这些参数的类型和注入元数据，以便注入正确的服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4nhic9youcvsmnhuj9hdn2zee\">如果 Angular 找不到该参数信息，它会抛出一个错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4l5iiqknpk4qt7gzfx44ataha\">Angular 只有在\n<em>类具有某种装饰器</em>的情况下才能找到参数信息。虽然\n<em>任何</em>装饰器都可以，但 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器是服务类的标准装饰器。</p>\n<div class=\"l-sub-section\">\nThe decorator requirement is imposed by TypeScript.\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rl6b3cnktekrtq0ssdinumkp\">TypeScript 通常在将代码\n<em>转译</em>为 JavaScript 时会丢弃参数类型信息。如果类具有装饰器，并且 TypeScript 的 \n<code>tsconfig.json</code> 配置文件中的 \n<code>emitDecoratorMetadata</code> 编译器选项设置为 \n<code>true</code>，它会保留此信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ceerfyyys9plwhaviz0z2cq33\">CLI 使用 \n<code>emitDecoratorMetadata: true</code> 配置 \n<code>tsconfig.json</code>。你需要在服务类上添加 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37kdfsakkn30nd9cosg1tszrs\"><code>Logger</code> 服务也用 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器注解，尽管它没有构造函数和依赖项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewn4wfql5vl5g3patlgnz2qtc\">事实上，此应用中的\n<em>每个</em> Angular 服务类都用 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器注解，无论它是否有构造函数和依赖项。\n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 是服务所需的编码风格。</p>\n<a id=\"providers\"></a>\n<h2 id=\"providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dycvc6pm27ridqfrosy8bqn88\"><i class=\"material-icons\">link</i>提供者</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59i9g9fcunkuziicr1cux7qqg\">服务提供者\n<em>提供</em>依赖值的具体运行时版本。注入器依赖于\n<strong>提供者</strong>来创建服务实例，这些服务实例被注入器注入到组件、指令、管道和其他服务中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epcx9ytz74e35hmt505kgu616\">你必须在注入器中注册一个服务\n<em>提供者</em>，否则它将不知道如何创建该服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6wy500pq0ay1aovwwxlnl8jjq\">接下来的几节将解释你可以指定提供者的多种方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"999zskbjb7lcqihxabes4nepp\">几乎所有附带的代码片段都是从示例应用的 \n<code>providers.component.ts</code> 文件中提取的。</p>\n<h3 id=\"the-class-as-its-own-provider\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"kdyvcbseehal8jo2qzrss78c\"><i class=\"material-icons\">link</i>类作为其自身的提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4p9yjxi5e849np9ort8pnfcok\">有许多方法可以\n<em>提供</em>看起来和行为都像 \n<code>Logger</code> 的东西。\n<code>Logger</code> 类本身是一个显而易见且自然的提供者。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b1pecjd5fjos8nx9ckxh13wkj\">但这并不是唯一的方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74mg8u81s5wvm1c0dyjxbdv7\">你可以使用替代提供者配置注入器，这些提供者可以提供一个行为类似于 \n<code>Logger</code> 的对象。你可以提供一个替代类。你可以提供一个类似于日志记录器的对象。你可以提供一个调用日志记录器工厂函数的提供者。在适当的情况下，任何一种方法都可能是不错的选择。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2rds2mnjm42v6x0cpqzjgz4tf\">重要的是，注入器在需要 \n<code>Logger</code> 时有一个提供者可以访问。</p>\n<a id=\"provide\"></a>\n<h3 id=\"the-provide-object-literal\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rp7x0wdfhfd6a5pbg1jk8vwf\"><i class=\"material-icons\">link</i><em>provide</em> 对象字面量</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d95jsg4ttxu7gpv01wu862pko\">以下是类提供者语法：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-logger\">\nproviders: [Logger]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1u0oqnp029cq96qa67zmzjcou\">这实际上是使用带有两个属性的\n<em>提供者</em>对象字面量注册提供者的简写表达式：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-3\">\n[{ provide: Logger, useClass: Logger }]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ovmfxcmsyg09jhafng6k1uwh\"><code>provide</code> 属性保存用作定位依赖值和注册提供者的键的\n<a href=\"guide/dependency-injection#token\">令牌</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1cl47pflpf5p0dt9rshax8fng\">第二个属性始终是一个提供者定义对象，你可以将其视为创建依赖值的\n<em>配方</em>。创建依赖值的方法有很多，就像编写配方的方式有很多一样。</p>\n<a id=\"class-provider\"></a>\n<h3 id=\"alternative-class-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9p5vaw003380j7ukv29z64lj1\"><i class=\"material-icons\">link</i>替代类提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejjrbloalvy9wz979nghnq7zk\">有时你会要求另一个类提供服务。以下代码告诉注入器在需要 \n<code>Logger</code> 时返回 \n<code>BetterLogger</code>。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-4\">\n[{ provide: Logger, useClass: BetterLogger }]\n\n</code-example>\n<a id=\"class-provider-dependencies\"></a>\n<h3 id=\"class-provider-with-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d21uxh453bdvn07pa894slbbm\"><i class=\"material-icons\">link</i>带有依赖项的类提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8lgmxxru7ozmtk5raiq26k7xo\">也许 \n<code>EvenBetterLogger</code> 可以将用户名显示在日志消息中。此日志记录器从注入的 \n<code>UserService</code> 获取用户，该服务也在应用程序级别注入。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"EvenBetterLogger\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class EvenBetterLogger extends Logger {\n  constructor(private userService: UserService) { super(); }\n\n  log(message: string) {\n    let name = this.userService.user.name;\n    super.log(`Message to ${name}: ${message}`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xd0kdzsu3bgta8t0xk4votdg\">像 \n<code>BetterLogger</code> 一样配置它。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-5\" linenums=\"false\">\n[ UserService,\n  { provide: Logger, useClass: EvenBetterLogger }]\n\n</code-example>\n<a id=\"aliased-class-providers\"></a>\n<h3 id=\"aliased-class-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6hptpas9o9ugljwftcoe2vm8\"><i class=\"material-icons\">link</i>别名类提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4um4o4j8qsjv63rux4hd86n8x\">假设一个旧组件依赖于 \n<code>OldLogger</code> 类。\n<code>OldLogger</code> 与 \n<code>NewLogger</code> 具有相同的接口，但由于某种原因，你无法更新旧组件以使用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34j8vrkol09ttnwdrs1fuu8y3\">当\n<em>旧</em>组件使用 \n<code>OldLogger</code> 记录消息时，你希望 \n<code>NewLogger</code> 的单例实例来处理它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5oqc26bi1q4bu5w7zur2xl4yh\">当组件请求新日志记录器或旧日志记录器时，依赖注入器应该注入该单例实例。\n<code>OldLogger</code> 应该是 \n<code>NewLogger</code> 的别名。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"xsr8as7s4h6nn8c0itqov86o\">你当然不希望在你的应用中出现两个不同的 \n<code>NewLogger</code> 实例。不幸的是，如果你尝试使用 \n<code>useClass</code> 将 \n<code>OldLogger</code> 设为 \n<code>NewLogger</code> 的别名，就会出现这种情况。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6a\" linenums=\"false\">\n[ NewLogger,\n  // Not aliased! Creates two instances of `NewLogger`\n  { provide: OldLogger, useClass: NewLogger}]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"donakq1g82foeiyd5c2u8bzlo\">解决方案：使用 \n<code>useExisting</code> 选项设置别名。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-6b\" linenums=\"false\">\n[ NewLogger,\n  // Alias OldLogger w/ reference to NewLogger\n  { provide: OldLogger, useExisting: NewLogger}]\n\n</code-example>\n<a id=\"value-provider\"></a>\n<h3 id=\"value-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9r97xrntha3wunmpf9ijtjrew\"><i class=\"material-icons\">link</i>值提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eh5hla6vf50012o3d437jk3fp\">有时提供一个现成的对象比要求注入器从类中创建它更容易。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"silent-logger\" linenums=\"false\">\n// An object in the shape of the logger service\nexport function SilentLoggerFn() {}\n\nconst silentLogger = {\n  logs: ['Silent logger says \"Shhhhh!\". Provided via \"useValue\"'],\n  log: SilentLoggerFn\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4n0vrbap3nehsjliex4bgly2\">然后，你使用 \n<code>useValue</code> 选项注册一个提供者，这使得此对象可以扮演日志记录器的角色。</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-7\" linenums=\"false\">\n[{ provide: Logger, useValue: silentLogger }]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azynobm7c93yr70h1g8taeu37\">在\n<a href=\"guide/dependency-injection#non-class-dependencies\">非类依赖项</a> 和\n<a href=\"guide/dependency-injection#injection-token\">注入令牌</a> 部分查看更多 \n<code>useValue</code> 示例。</p>\n<a id=\"factory-provider\"></a>\n<h3 id=\"factory-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ck50269zm1fp9f2aekx0zwp5x\"><i class=\"material-icons\">link</i>工厂提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcivkakpqd8r06cbq1is4pemz\">有时你需要动态创建依赖值，这取决于你直到最后一刻才会有的信息。也许该信息在浏览器会话过程中会反复更改。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5tj0cc6blkv1w1pckkzr0hhal\">假设可注入服务也无法独立访问此信息源。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60txgh9i4udxbguo5ey2tlxib\">这种情况需要一个\n<strong>工厂提供者</strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5frzjl4pclxsmjvavvb6l5n76\">为了说明这一点，添加一个新的业务需求：\n<code>HeroService</code> 必须向普通用户隐藏\n<em>秘密</em>英雄。只有授权用户才能看到秘密英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1prafx9t8p3pn05j9o3010an4\">与 \n<code>EvenBetterLogger</code> 一样，\n<code>HeroService</code> 需要关于用户的事实。它需要知道用户是否有权查看秘密英雄。该授权可以在单个应用程序会话过程中更改，例如当你登录不同的用户时。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cu3cji4jlcesokhrnfk39snif\">与 \n<code>EvenBetterLogger</code> 不同，你无法将 \n<code>UserService</code> 注入到 \n<code>HeroService</code> 中。\n<code>HeroService</code> 将无法直接访问用户信息来决定谁有权访问，谁没有权访问。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7j3tenl1hlb9o7lo6udjj1u5g\">相反，\n<code>HeroService</code> 构造函数接受一个布尔标志来控制秘密英雄的显示。</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.ts\" region=\"internals\" title=\"src/app/heroes/hero.service.ts (excerpt)\" linenums=\"false\">\nconstructor(\n  private logger: Logger,\n  private isAuthorized: boolean) { }\n\ngetHeroes() {\n  let auth = this.isAuthorized ? 'authorized ' : 'unauthorized';\n  this.logger.log(`Getting heroes for ${auth} user.`);\n  return HEROES.filter(hero =&gt; this.isAuthorized || !hero.isSecret);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ejhctpksffirvgc0hmydbnf3\">你可以注入 \n<code>Logger</code>，但你无法注入布尔值 \n<code>isAuthorized</code>。你必须使用工厂提供者接管此 \n<code>HeroService</code> 的新实例的创建。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1r6zzmwsugcwfygc0zayn1bid\">工厂提供者需要一个工厂函数：</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"factory\" title=\"src/app/heroes/hero.service.provider.ts (excerpt)\" linenums=\"false\">\nlet heroServiceFactory = (logger: Logger, userService: UserService) =&gt; {\n  return new HeroService(logger, userService.user.isAuthorized);\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38udc7wlqf6zplqcl3wsajjaa\">虽然 \n<code>HeroService</code> 无法访问 \n<code>UserService</code>，但工厂函数可以。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4v3g69a3fhoro4kyja8nz9x4t\">你将 \n<code>Logger</code> 和 \n<code>UserService</code> 都注入到工厂提供者中，并让注入器将它们传递给工厂函数：</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero.service.provider.ts\" region=\"provider\" title=\"src/app/heroes/hero.service.provider.ts (excerpt)\" linenums=\"false\">\nexport let heroServiceProvider =\n  { provide: HeroService,\n    useFactory: heroServiceFactory,\n    deps: [Logger, UserService]\n  };\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1cim4hmlxkvest4cw042xp9ui\"><code>useFactory</code> 字段告诉 Angular 此提供者是一个工厂函数，其实现为 \n<code>heroServiceFactory</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fl1d0v6cbbngxg3lanuu112i\"><code>deps</code> 属性是一个 \n<a href=\"guide/dependency-injection#token\">提供者令牌</a> 数组。 \n<code>Logger</code> 和 \n<code>UserService</code> 类充当其自身类提供者的令牌。 注入器解析这些令牌并将相应的服务注入到匹配的工厂函数参数中。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dgtnvg9701jobdswc1s59s9ce\">注意，你将工厂提供者捕获到一个导出的变量 \n<code>heroServiceProvider</code> 中。 此额外步骤使工厂提供者可重用。 你可以在需要的地方使用此变量注册 \n<code>HeroService</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dj5v2unx5ds480tgxr06fervo\">在此示例中，你只需要在 \n<code>HeroesComponent</code> 中使用它， 它在元数据 \n<code>providers</code> 数组中替换了之前的 \n<code>HeroService</code> 注册。 这里你可以看到新旧实现并排显示：</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/heroes/heroes.component (v3)\" path=\"dependency-injection/src/app/heroes/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }          from '@angular/core';\nimport { heroServiceProvider } from './hero.service.provider';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ heroServiceProvider ],\n  template: `\n    &lt;h2&gt;Heroes&lt;/h2&gt;\n    &lt;app-hero-list&gt;&lt;/app-hero-list&gt;\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/heroes/heroes.component (v2)\" path=\"dependency-injection/src/app/heroes/heroes.component.1.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-heroes',\n  providers: [ HeroService ],\n  template: `\n    &lt;h2&gt;Heroes&lt;/h2&gt;\n    &lt;app-hero-list&gt;&lt;/app-hero-list&gt;\n  `\n})\nexport class HeroesComponent { }\n\n\n</code-pane>\n\n</code-tabs>\n<a id=\"token\"></a>\n<h2 id=\"dependency-injection-tokens\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61slnmhfxi99vn0lnway5d6an\"><i class=\"material-icons\">link</i>依赖注入令牌</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"es1yxjth5hdu81mtxwl4yfw7v\">当你使用注入器注册提供者时，你将该提供者与依赖注入令牌关联起来。 注入器维护一个内部的 \n<em>令牌-提供者</em> 映射表，它在被请求依赖项时会引用该映射表。令牌是映射表的键。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8u5trw0h66buqre1o0wm38zln\">在所有之前的示例中，依赖项值都是一个类 \n<em>实例</em>，并且 类 \n<em>类型</em> 充当其自身的查找键。 在这里，你可以通过提供 \n<code>HeroService</code> 类型作为令牌，直接从注入器获取 \n<code>HeroService</code>：</p>\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"get-hero-service\" title=\"src/app/injector.component.ts\" linenums=\"false\">\nheroService: HeroService;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4smycn0ag95wb8su1h7v5n1d\">当你编写一个需要注入的基于类的依赖项的构造函数时，你也会有类似的好运。 当你使用 \n<code>HeroService</code> 类类型定义构造函数参数时， Angular 会知道将与该 \n<code>HeroService</code> 类令牌关联的服务注入进来：</p>\n<code-example path=\"dependency-injection/src/app/heroes/hero-list.component.ts\" region=\"ctor-signature\" title=\"src/app/heroes/hero-list.component.ts\">\nconstructor(heroService: HeroService)\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3532l07sr7855jvjs7kli6c3g\">当你考虑到大多数依赖项值都是由类提供的时，这尤其方便。</p>\n<a id=\"non-class-dependencies\"></a>\n<h3 id=\"non-class-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8d8k55rsdo9v4k190whhkom0u\"><i class=\"material-icons\">link</i>非类依赖项</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1o4kjxg2svssfhrznluwsg3uw\">如果依赖项值不是类呢？有时你想要注入的是一个字符串、函数或对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c09m4nk0q667gbyuof399tff\">应用程序通常定义包含许多小事实的配置对象（例如应用程序的标题或 Web API 端点的地址）， 但这些配置对象并不总是类的实例。 它们可以是像这样的对象字面量：</p>\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"config\" title=\"src/app/app.config.ts (excerpt)\" linenums=\"false\">\nexport const HERO_DI_CONFIG: AppConfig = {\n  apiEndpoint: 'api.heroes.com',\n  title: 'Dependency Injection'\n};\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dd3l8itzhhwu18pibo4elgc1o\">如果你想让此配置对象可用于注入，该怎么办？ 你知道你可以使用 \n<a href=\"guide/dependency-injection#value-provider\">值提供者</a> 注册一个对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3agwhlcmnxzwwtd3b4tgcy0lh\">但是你应该使用什么作为令牌呢？ 你没有类可以作为令牌。 没有 \n<code>AppConfig</code> 类。</p>\n<div class=\"l-sub-section\">\n<h3 id=\"typescript-interfaces-arent-valid-tokens\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gxyqf8n4lkju5ertv36jgnfo\"><i class=\"material-icons\">link</i>TypeScript 接口不是有效的令牌</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78mcd8henqc4biy93lp8md6gt\"><code>HERO_DI_CONFIG</code> 常量符合 \n<code>AppConfig</code> 接口。 不幸的是，你不能使用 TypeScript 接口作为令牌：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9-interface\" linenums=\"false\">\n// FAIL! Can't use interface as provider token\n[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-9-ctor-interface\" linenums=\"false\">\n// FAIL! Can't <a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a> using the interface as the parameter type\nconstructor(private config: AppConfig){ }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azxnd4cl9l4ych37yw9w1n56j\">如果你习惯于强类型语言中的依赖注入，这似乎很奇怪，因为 接口是首选的依赖项查找键。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ub3gn2uipwfhnn4zub191rk2\">这不是 Angular 的问题。接口是 TypeScript 的设计时工件。JavaScript 没有接口。 TypeScript 接口从生成的 JavaScript 中消失。 在运行时，Angular 找不到任何剩余的接口类型信息。</p>\n</div>\n<a id=\"injection-token\"></a>\n<h3 id=\"injectiontoken\"><em>InjectionToken</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6o59svmxxvg5vz8oth52248kk\">为非类依赖项选择提供者令牌的一种解决方案是 定义和使用 \n<a href=\"api/core/InjectionToken\"><em>InjectionToken</em></a>。 此类令牌的定义如下所示：</p>\n<code-example path=\"dependency-injection/src/app/app.config.ts\" region=\"token\" title=\"src/app/app.config.ts\" linenums=\"false\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const APP_CONFIG = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;AppConfig&gt;('app.config');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"an1s4sf7rz1ltvwc16bae0iz2\">类型参数虽然是可选的，但它会向开发人员和工具传达依赖项的类型。 令牌描述是另一个开发人员辅助工具。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6h37ai537cdiffa7acxwtvuv4\">使用 \n<code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 对象注册依赖项提供者：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"providers-9\" linenums=\"false\">\nproviders: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2mj4crikzquqav6mer02xc6o1\">现在，你可以使用 \n<code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 装饰器将配置对象注入到任何需要它的构造函数中：</p>\n<code-example path=\"dependency-injection/src/app/app.component.2.ts\" region=\"ctor\" title=\"src/app/app.component.ts\" linenums=\"false\">\nconstructor(@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(APP_CONFIG) config: AppConfig) {\n  this.title = config.title;\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ewofs350b538ffmgqm0legds\">虽然 \n<code>AppConfig</code> 接口在依赖注入中没有作用， 但它支持在类中对配置对象的类型化。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"etsap1g2cd1uymzimdl3c2sf2\">或者，你可以在像 \n<code>AppModule</code> 这样的 ngModule 中提供和注入配置对象。</p>\n<code-example path=\"dependency-injection/src/app/app.module.ts\" region=\"providers\" title=\"src/app/app.module.ts (providers)\">\nproviders: [\n  UserService,\n  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }\n],\n\n</code-example>\n<a id=\"optional\"></a>\n<h2 id=\"optional-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1r4zvb33trkcr9rjztbxzobb3\"><i class=\"material-icons\">link</i>可选依赖项</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ev1tnnvtiitc2epm2k53muiqw\"><code>HeroService</code> \n<em>需要</em> \n<code>Logger</code>，但如果它可以没有 \n<code>logger</code> 呢？ 你可以通过使用 \n<code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 注解构造函数参数来告诉 Angular 此依赖项是可选的：</p>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"import-optional\">\nimport { <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> } from '@angular/core';\n\n</code-example>\n<code-example path=\"dependency-injection/src/app/providers.component.ts\" region=\"provider-10-ctor\" linenums=\"false\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() private logger: Logger) {\n  if (this.logger) {\n    this.logger.log(some_message);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wqj2twksna916x7q23ai04a3\">使用 \n<code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 时，你的代码必须为 null 值做好准备。如果你 没有在某处注册 \n<code>logger</code>，注入器会将 \n<code>logger</code> 的值设置为 null。</p>\n<h2 id=\"summary\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2fflknbbur8ttwdtn3o9w4vat\"><i class=\"material-icons\">link</i>总结</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"koio7947tingb7ujipxoolvr\">你已经学习了本页中 Angular 依赖注入的基础知识。 你可以注册各种类型的提供者， 并且你知道如何通过 向构造函数添加参数来请求注入的对象（例如服务）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"49tgrd5cj41japknqx2rjy7l6\">Angular 依赖注入比本指南中描述的更强大。 你可以从其对 嵌套注入器的支持开始，了解有关其高级特性的更多信息， \n<a href=\"guide/hierarchical-dependency-injection\">分层依赖注入</a>。</p>\n<a id=\"explicit-injector\"></a>\n<h2 id=\"appendix-working-with-injectors-directly\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xqqdww08e53pqw96twtytfd5\"><i class=\"material-icons\">link</i>附录：直接使用注入器</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5bldfmoht7w0un8afrzg0dxmu\">开发人员很少直接使用注入器，但 这里有一个 \n<code>InjectorComponent</code> 会这样做。</p>\n<code-example path=\"dependency-injection/src/app/injector.component.ts\" region=\"injector\" title=\"src/app/injector.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-injectors',\n  template: `\n  &lt;h2&gt;Other Injections&lt;/h2&gt;\n  &lt;div id=\"car\"&gt;{{car.drive()}}&lt;/div&gt;\n  &lt;div id=\"hero\"&gt;{{hero.name}}&lt;/div&gt;\n  &lt;div id=\"rodent\"&gt;{{rodent}}&lt;/div&gt;\n  `,\n  providers: [Car, Engine, Tires, heroServiceProvider, Logger]\n})\nexport class InjectorComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  car: Car;\n\n  heroService: HeroService;\n  hero: Hero;\n\n  constructor(private injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) { }\n\n  ngOnInit() {\n    this.car = this.injector.get(Car);\n    this.heroService = this.injector.get(HeroService);\n    this.hero = this.heroService.getHeroes()[0];\n  }\n\n  get rodent() {\n    let rousDontExist = `R.O.U.S.'s? I don't think they exist!`;\n    return this.injector.get(ROUS, rousDontExist);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3h1qmenfzjbiuipxt3gmm2r4n\"><code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> 本身就是一个可注入的服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2aepz97saa6mmdn68z3tc9amr\">在此示例中，Angular 将组件自身的 \n<code><a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a></code> 注入到组件的构造函数中。 然后，组件在 \n<code>ngOnInit()</code> 中向注入的注入器请求它想要的服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebcoo7wydq8q4vsyk7azm5ccw\">注意，服务本身并没有注入到组件中。 它们是通过调用 \n<code>injector.get()</code> 获取的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4hw3xaqg6e6tz7lcb39eyex98\">如果 \n<code>get()</code> 方法无法解析请求的服务，它会抛出错误。 你可以使用第二个参数调用 \n<code>get()</code>，该参数是在找不到服务时要返回的值。如果服务没有注册到此注入器或任何祖先注入器，Angular 就无法找到该服务。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1186gu650lapnjfyr9r0m11b7\">此技术是 \n<a href=\"https://en.wikipedia.org/wiki/Service_locator_pattern\">服务定位器模式</a> 的一个示例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dreky4l9iyq0lqpsqduwc62qt\"><strong>避免</strong>使用此技术，除非你确实需要它。 它鼓励使用像这里看到的那种粗心大意的抓取包方法。 它很难解释、理解和测试。 你无法通过检查构造函数来了解此类需要什么或它将做什么。 它可以从任何祖先组件获取服务，而不仅仅是从它自己的组件获取。 你被迫深入研究实现以发现它做了什么。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2oiwbvnq63253l2bc5d11c6ts\">框架开发人员可能会在 必须以通用和动态的方式获取服务时使用这种方法。</p>\n</div>\n<a id=\"one-class-per-file\"></a>\n<h2 id=\"appendix-one-class-per-file\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38q8ut8r2eeywmm4gwp6oze12\"><i class=\"material-icons\">link</i>附录：每个文件一个类</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1caokrap57pfn7jxlktfwajsi\">在一个文件中包含多个类会让人困惑，最好避免这样做。 开发人员希望每个文件一个类。让他们开心。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qi6jkfmh0q538qsbjvoq7cnp\">如果你将 \n<code>HeroService</code> 类与 \n<code>HeroesComponent</code> 放在同一个文件中， \n<strong>最后定义组件</strong>。 如果你在服务之前定义组件， 你会得到一个运行时空引用错误。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yvhlz11a5ysneo2fv3ch0u71\">实际上，你可以使用 \n<code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 方法在服务之前定义组件，如 这篇 \n<a href=\"http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\">博客文章</a> 中所述。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2lb05bcuny3ooqj5rcy31qbcd\">但最好通过在单独的文件中定义组件和服务来完全避免此问题。</p>\n</div>\n\n</div>\n<!-- links to this doc:\n - api/core/ClassProvider\n - api/core/ExistingProvider\n - api/core/FactoryProvider\n - api/core/Host\n - api/core/HostDecorator\n - api/core/Inject\n - api/core/InjectDecorator\n - api/core/Injectable\n - api/core/InjectableDecorator\n - api/core/Injector\n - api/core/Optional\n - api/core/OptionalDecorator\n - api/core/Provider\n - api/core/Self\n - api/core/SelfDecorator\n - api/core/SkipSelf\n - api/core/SkipSelfDecorator\n - api/core/StaticProvider\n - api/core/TypeProvider\n - api/core/ValueProvider\n - guide/architecture-services\n - guide/attribute-directives\n - guide/dependency-injection-in-action\n - guide/dependency-injection-pattern\n - guide/glossary\n - guide/hierarchical-dependency-injection\n - guide/http\n - guide/router\n - guide/sharing-ngmodules\n - guide/testing\n - guide/upgrade\n - tutorial/toh-pt4\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/core/Component\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Injector\n - api/core/NgModule\n - api/core/NgModule#providers\n - api/core/OnInit\n - api/core/Optional\n - api/core/forwardRef\n - api/core/testing/inject\n - guide/bootstrapping\n - guide/dependency-injection#aliased-class-providers\n - guide/dependency-injection#alternative-class-providers\n - guide/dependency-injection#angular-dependency-injection\n - guide/dependency-injection#appendix-one-class-per-file\n - guide/dependency-injection#appendix-working-with-injectors-directly\n - guide/dependency-injection#class-provider-with-dependencies\n - guide/dependency-injection#component-child-injectors\n - guide/dependency-injection#component-providers\n - guide/dependency-injection#create-an-injectable-heroservice\n - guide/dependency-injection#dependency-injection-tokens\n - guide/dependency-injection#di-by-example\n - guide/dependency-injection#factory-providers\n - guide/dependency-injection#inject-a-service\n - guide/dependency-injection#injectable\n - guide/dependency-injection#injection-token\n - guide/dependency-injection#injectiontoken\n - guide/dependency-injection#ngmodule-or-component\n - guide/dependency-injection#ngmodule-providers\n - guide/dependency-injection#non-class-dependencies\n - guide/dependency-injection#one-class-per-file\n - guide/dependency-injection#optional-dependencies\n - guide/dependency-injection#providers\n - guide/dependency-injection#register-a-service-provider\n - guide/dependency-injection#singleton-services\n - guide/dependency-injection#summary\n - guide/dependency-injection#testing-the-component\n - guide/dependency-injection#the-class-as-its-own-provider\n - guide/dependency-injection#the-dependent-logger-service\n - guide/dependency-injection#the-provide-object-literal\n - guide/dependency-injection#token\n - guide/dependency-injection#typescript-interfaces-arent-valid-tokens\n - guide/dependency-injection#value-provider\n - guide/dependency-injection#value-providers\n - guide/dependency-injection#when-the-service-needs-a-service\n - guide/dependency-injection-pattern\n - guide/hierarchical-dependency-injection\n - guide/lazy-loading-ngmodules\n - guide/testing\n - tutorial/\n - http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html\n - https://cli.angular.io/\n - https://en.wikipedia.org/wiki/Service_locator_pattern\n-->"
}