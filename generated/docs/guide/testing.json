{
  "id" : "guide/testing",
  "title" : "测试",
  "contents" : "<div class=\"content\">\n<a id=\"top\"></a>\n<h1 id=\"testing\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"etpgj6p39fywtmcrsphy8qrcg\"><i class=\"material-icons\">link</i>测试</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsjjj6km4p39ldnq5mit1vmu\">本指南提供了一些关于单元测试和集成测试 Angular 应用的技巧和方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eb7iypjh20kwqwcokm8pt1909\">本指南展示了对一个示例 CLI 应用的测试，该应用与 \n<a href=\"tutorial\"><em>英雄之旅</em>教程</a> 非常相似。 本指南中的示例应用和所有测试都可以供你检查和实验：</p>\n<ul>\n<li><live-example embedded-style=\"\">Sample app</live-example></li>\n<li><live-example stackblitz=\"specs\">Tests</live-example></li>\n</ul>\n<hr>\n<h2 id=\"setup\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a90a9lk5ukrzn7bkuyktmp1zv\"><i class=\"material-icons\">link</i>设置</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqxm7b4w0m99rimshag4smlzj\">Angular CLI 会下载并安装你使用 \n<a href=\"http://jasmine.github.io/2.4/introduction.html\">Jasmine 测试框架</a> 测试 Angular 应用所需的一切。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"83hiyva60szp3jbwcv1vhwypl\">你使用 CLI 创建的项目可以立即进行测试。 只需运行以下 CLI 命令：</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng test\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0xvm4qa71c7llpqr9rjd3bvw\"><code>ng test</code> 命令以\n<em>监视模式</em>构建应用， 并启动 \n<a href=\"https://karma-runner.github.io/1.0/index.html\">karma 测试运行器</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bx0wt7dyfz2e1ah0y1azk575d\">控制台输出看起来像这样：</p>\n<code-example language=\"sh\" class=\"code-shell\">\n10% building modules 1/1 modules 0 active\n...INFO [karma]: Karma v1.7.1 server started at http://0.0.0.0:9876/\n...INFO [launcher]: Launching <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a> Chrome ...\n...INFO [launcher]: Starting <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a> Chrome\n...INFO [Chrome ...]: Connected on socket ... \nChrome ...: Executed 3 of 3 SUCCESS (0.135 secs / 0.205 secs)\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6j4b4s6aumfrgg1nhax91ilhk\">日志的最后一行是最重要的。 它显示 Karma 运行了三个测试，所有测试都通过了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"40uvht5abe73lixi5m5zlmb23\">一个 Chrome 浏览器也会打开，并在 \"Jasmine HTML Reporter\" 中显示测试输出，如下所示。</p>\n<figure>\n  <img src=\"generated/images/guide/testing/initial-jasmine-html-reporter.png\" alt=\"Jasmine HTML Reporter in the browser\" width=\"502\" height=\"306\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"892ubb7o2eyptendquzpyz6ej\">大多数人发现这个浏览器输出比控制台日志更容易阅读。 你可以点击测试行重新运行该测试，或者点击描述重新运行所选测试组（\"测试套件\"）中的测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1rj5tiit5ellz0r8ysi7rpicu\">同时，<code>ng test</code> 命令还会监听这些变化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6h090eu20dackksclavpk66ki\">要查看它的实际效果，就对 <code>app.component.ts</code> 做一个小修改，并保存它。这些测试就会重新运行，浏览器也会刷新，然后新的测试结果就出现了。</p>\n<h4 id=\"configuration\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"27io2zcn0syxgd4dfu8paj1a1\"><i class=\"material-icons\">link</i>配置</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2nirw7fep83387p2r1vc1k1f\">CLI 会为你处理 Jasmine 和 karma 的配置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ubnwx6rlkqtnymg4fb0dkyas\">你可以通过编辑项目根目录中的 \n<code>karma.conf.js</code> 文件和 \n<code>src/</code> 文件夹中的 \n<code>test.ts</code> 文件来微调许多选项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3usvcshxqdfbtpsgi5dx3ol5g\"><code>karma.conf.js</code> 文件是一个部分 karma 配置文件。 CLI 会在内存中构建完整的运行时配置，该配置基于 \n<code>.angular-cli.json</code> 文件中指定的应用结构，并辅以 \n<code>karma.conf.js</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvu42i9466eacxyl4emde7eto\">在网上搜索有关 Jasmine 和 karma 配置的更多详细信息。</p>\n<h4 id=\"other-test-frameworks\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"drmoxmvux9pu6iqyppujewc6n\"><i class=\"material-icons\">link</i>其他测试框架</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mzpsgc5cbpr8w59tapgmp0ft\">你也可以使用其他测试库和测试运行器来对 Angular 应用进行单元测试。 每个库和运行器都有其独特的安装程序、配置和语法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6rvxy5vefq5ftvbff77s7go31\">在网上搜索以了解更多信息。</p>\n<h4 id=\"test-file-name-and-location\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6cerb1mtf9nx0obt7rpcge4a7\"><i class=\"material-icons\">link</i>测试文件名及其位置</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ag20y2vem7qt0lzmzbqceb5r3\">查看 \n<code>src/app</code> 文件夹。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ubscrh1nqk7zihuzqpruhjng\">CLI 为 \n<code>AppComponent</code> 生成了一个名为 \n<code>app.component.spec.ts</code> 的测试文件。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qcejwkb0mq484ndv7pi79agy\">测试文件扩展名\n<strong>必须为 <code>.spec.ts</code></strong>，以便工具可以将其识别为包含测试的（即\n<em>spec</em>）文件。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0os7f94gcr6eaznf4m9dk64a\"><code>app.component.ts</code> 和 \n<code>app.component.spec.ts</code> 文件位于同一个文件夹中，是兄弟文件。 这两个文件的根文件名（\n<code>app.component</code>）相同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"b7hqspxutkt7z1vb19zl70drd\">请在你的项目中对<em>任意类型</em>的测试文件都坚持这两条约定。</p>\n<h2 id=\"service-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ea30y9dd8w1992kecsaqcq9pz\"><i class=\"material-icons\">link</i>服务测试</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"br8q7bn3hjgz7gtebtve11ur0\">服务通常是最容易进行单元测试的文件。 以下是一些对 \n<code>ValueService</code> 进行同步和异步单元测试的示例，这些测试是在没有 Angular 测试工具的帮助下编写的。</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"ValueService\" title=\"app/demo/demo.spec.ts\">\n// Straight Jasmine testing without Angular's testing support\ndescribe('ValueService', () =&gt; {\n  let service: ValueService;\n  beforeEach(() =&gt; { service = new ValueService(); });\n\n  it('#getValue should return real value', () =&gt; {\n    expect(service.getValue()).toBe('real value');\n  });\n\n  it('#getObservableValue should return value from observable',\n    (done: DoneFn) =&gt; {\n    service.getObservableValue().subscribe(value =&gt; {\n      expect(value).toBe('observable value');\n      done();\n    });\n  });\n\n  it('#getPromiseValue should return value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> promise',\n    (done: DoneFn) =&gt; {\n    service.getPromiseValue().then(value =&gt; {\n      expect(value).toBe('promise value');\n      done();\n    });\n  });\n});\n\n</code-example>\n<a id=\"services-with-dependencies\"></a>\n<h4 id=\"services-with-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"822bp8h8cqw5y49v2v7at3y3t\"><i class=\"material-icons\">link</i>有依赖的服务</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tbv298u0b3x1dvcmoikmh518\">服务通常依赖于其他服务，这些服务由 Angular 注入到构造函数中。 在许多情况下，可以通过手动创建和\n<em>注入</em>这些依赖项来调用服务的构造函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5e61ib8ge8d0nv26t9l7snckp\"><code>MasterService</code> 就是一个简单的例子：</p>\n<code-example path=\"testing/src/app/demo/demo.ts\" region=\"MasterService\" title=\"app/demo/demo.ts\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class MasterService {\n  constructor(private valueService: ValueService) { }\n  getValue() { return this.valueService.getValue(); }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"e732jzduwt4khk20izg6rrvn4\"><code>MasterService</code> 只把它唯一的方法 <code>getValue</code> 委托给了所注入的 <code>ValueService</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7ggnkn8lmdqms3j9gc1yxlife\">这里有几种测试方法。</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"MasterService\" title=\"app/demo/demo.spec.ts\">\ndescribe('MasterService without Angular testing support', () =&gt; {\n  let masterService: MasterService;\n\n  it('#getValue should return real value from the real service', () =&gt; {\n    masterService = new MasterService(new ValueService());\n    expect(masterService.getValue()).toBe('real value');\n  });\n\n  it('#getValue should return faked value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> fakeService', () =&gt; {\n    masterService = new MasterService(new FakeValueService());\n    expect(masterService.getValue()).toBe('faked service value');\n  });\n\n  it('#getValue should return faked value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> fake object', () =&gt; {\n    const fake =  { getValue: () =&gt; 'fake value' };\n    masterService = new MasterService(fake as ValueService);\n    expect(masterService.getValue()).toBe('fake value');\n  });\n\n  it('#getValue should return stubbed value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> spy', () =&gt; {\n    // create `getValue` spy on an object representing the ValueService\n    const valueServiceSpy =\n      jasmine.createSpyObj('ValueService', ['getValue']);\n\n    // set the value to return when the `getValue` spy is called.\n    const stubValue = 'stub value';\n    valueServiceSpy.getValue.and.returnValue(stubValue);\n\n    masterService = new MasterService(valueServiceSpy);\n\n    expect(masterService.getValue())\n      .toBe(stubValue, 'service returned stub value');\n    expect(valueServiceSpy.getValue.calls.count())\n      .toBe(1, 'spy method was called once');\n    expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n      .toBe(stubValue);\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8mo0rk841y29ljycwdz3c7he0\">第一个测试使用 <code>new</code> 创建了一个 <code>ValueService</code>，并把它传给了 <code>MasterService</code> 的构造函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"dh00wa5j9i8tj1tsdmcd2ut5c\">然而，注入真实服务很难工作良好，因为大多数被依赖的服务都很难创建和控制。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jyp1ct8d4b8m00jnbiud78wr\">相反，你可以模拟依赖项，使用虚拟值，或者在相关服务方法上创建 \n<a href=\"https://jasmine.github.io/2.0/introduction.html#section-Spies\">间谍</a> 。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"950dan1jkmv5j1din43046ls3\">优先使用间谍，因为它们通常是模拟服务的最佳方法。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"89in4zne91ap3w70mxfxq63jo\">这些标准的测试技巧非常适合对服务进行单独测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7v5xdqk3xbjvllbcton41fuvd\">但是，你几乎总是使用 Angular 依赖注入将服务注入到应用程序类中，并且应该有反映这种使用模式的测试。 Angular 测试工具可以轻松地调查注入的服务的行为。</p>\n<h4 id=\"testing-services-with-the-testbed\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do74tmkbhza7ecp52kv5ttsga\"><i class=\"material-icons\">link</i>使用\n<em>TestBed</em>测试服务</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqnu7hvigwm1mgt9gp41qc3za\">你的应用依赖于 Angular \n<a href=\"guide/dependency-injection\">依赖注入 (DI)</a> 来创建服务。 当服务具有依赖服务时，DI 会查找或创建该依赖服务。 如果该依赖服务还有自己的依赖项，DI 也会查找或创建它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32owy3s0v5mc9095zq3tdrini\">作为服务\n<em>使用者</em>，你不必担心这些。 你不必担心构造函数参数的顺序或它们是如何创建的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1b8locdqsfr818w816wggrnnu\">作为服务\n<em>测试者</em>，你至少要考虑服务依赖项的第一层，但你可以让 Angular DI 在你使用 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 测试工具提供和创建服务时，处理服务创建和构造函数参数顺序。</p>\n<a id=\"testbed\"></a>\n<h4 id=\"angular-testbed\">Angular <em>TestBed</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bnthzf687zqttdzc2m5gdl1ud\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 是 Angular 测试工具中最重要的一种。 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 创建一个动态构建的 Angular \n<em>测试</em>模块，它模拟 一个 Angular \n<a href=\"guide/ngmodules\">@NgModule</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4nkuoistl2ermwag4nu3ahqyx\"><code>TestBed.configureTestingModule()</code> 方法接受一个元数据对象，该对象可以具有 \n<a href=\"guide/ngmodules\">@NgModule</a> 的大多数属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"abbwabdlpexag85p6lz4ycqnt\">要测试服务，需要使用要测试或模拟的服务数组设置 \n<code>providers</code> 元数据属性。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-before-each\" title=\"app/demo/demo.testbed.spec.ts (provide ValueService in beforeEach\">\nlet service: ValueService;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98z3pwsx2n90t24od8e41p2np\">然后，通过调用 \n<code>TestBed.get()</code> 并将服务类作为参数，在测试中注入它。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-it\">\nit('should use ValueService', () =&gt; {\n  service = TestBed.get(ValueService);\n  expect(service.getValue()).toBe('real value');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4th3om6n4lvjw431y4n981nwj\">或者，如果你喜欢把这个服务作为设置代码的一部分进行注入，也可以在 <code>beforeEach()</code> 中做。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"value-service-inject-before-each\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({ providers: [ValueService] });\n  service = TestBed.get(ValueService);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4z8cgjvz5ruvrypj4nqyjtgtw\">测试带依赖的服务时，需要在 <code>providers</code> 数组中提供 mock。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2w2maamnho2eash8h1ya8oeo0\">在下面的例子中，mock 是一个间谍对象。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-before-each\" linenums=\"false\">\nlet masterService: MasterService;\nlet valueServiceSpy: jasmine.SpyObj&lt;ValueService&gt;;\n\nbeforeEach(() =&gt; {\n  const spy = jasmine.createSpyObj('ValueService', ['getValue']);\n\n  TestBed.configureTestingModule({\n    // Provide both the service-to-test and its (spy) dependency\n    providers: [\n      MasterService,\n      { provide: ValueService, useValue: spy }\n    ]\n  });\n  // <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> both the service-to-test and its (spy) dependency\n  masterService = TestBed.get(MasterService);\n  valueServiceSpy = TestBed.get(ValueService);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"a74rd5bz78usbo01mfwn1upto\">该测试会像以前一样使用该间谍。</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"master-service-it\">\nit('#getValue should return stubbed value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> spy', () =&gt; {\n  const stubValue = 'stub value';\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n\n  expect(masterService.getValue())\n    .toBe(stubValue, 'service returned stub value');\n  expect(valueServiceSpy.getValue.calls.count())\n    .toBe(1, 'spy method was called once');\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n<a id=\"no-before-each\"></a>\n<h4 id=\"testing-without-beforeeach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1pjcdufwm2359hp9zepz0v950\"><i class=\"material-icons\">link</i>不使用\n<em>beforeEach()</em>进行测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b88baqqmok1ymla9htueaobv3\">本指南中的大多数测试套件都调用 \n<code>beforeEach()</code> 来设置每个 \n<code>it()</code> 测试的先决条件，并依赖于 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 来创建类和注入服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnsy3mse9ux4l1fnjn8djici4\">还有一种测试方法，它从不调用 \n<code>beforeEach()</code>， 并且更喜欢显式创建类，而不是使用 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"321ibwe3fxio8vakprsfgxmgk\">你可以用这种风格重写 <code>MasterService</code> 中的一个测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5xsq550pzo096tw8x0iyqqhh9\">首先，在 <em>setup</em> 函数中放入可供复用的预备代码，而不用 <code>beforeEach()</code>。</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup\" title=\"app/demo/demo.spec.ts (setup)\" linenums=\"false\">\nfunction setup() {\n  const valueServiceSpy =\n    jasmine.createSpyObj('ValueService', ['getValue']);\n  const stubValue = 'stub value';\n  const masterService = new MasterService(valueServiceSpy);\n\n  valueServiceSpy.getValue.and.returnValue(stubValue);\n  return { masterService, stubValue, valueServiceSpy };\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72bxpny74gvzb9nndyl6r6agi\"><code>setup()</code> 函数返回一个对象字面量， 其中包含测试可能引用的变量，例如 \n<code>masterService</code>。 你不会在 \n<code>describe()</code> 的主体中定义\n<em>半全局</em>变量（例如，\n<code>let masterService: MasterService</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ilevd5lltrogt8zfkv2og6xq\">然后，每个测试都在其第一行调用 \n<code>setup()</code>，然后继续执行操作测试主题和断言期望的操作。</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-test\" linenums=\"false\">\nit('#getValue should return stubbed value from <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> spy', () =&gt; {\n  const { masterService, stubValue, valueServiceSpy } = setup();\n  expect(masterService.getValue())\n    .toBe(stubValue, 'service returned stub value');\n  expect(valueServiceSpy.getValue.calls.count())\n    .toBe(1, 'spy method was called once');\n  expect(valueServiceSpy.getValue.calls.mostRecent().returnValue)\n    .toBe(stubValue);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epj76gemt11en9jrygs7zs4gc\">注意测试如何使用 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\"><em>解构赋值</em></a> 来提取它需要的设置变量。</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"no-before-each-setup-call\">\nconst { masterService, stubValue, valueServiceSpy } = setup();\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"abxmto8wjc18xgft5kw25k20t\">许多开发人员认为这种方法比传统的 \n<code>beforeEach()</code> 样式更简洁、更明确。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48bkp68a9xlqpqrs2pztcxcfv\">虽然本测试指南遵循传统样式， 并且默认的 \n<a href=\"https://github.com/angular/devkit\">CLI 原理图</a> 使用 \n<code>beforeEach()</code> 和 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 生成测试文件， 但你可以随意在自己的项目中采用\n<em>这种替代方法</em>。</p>\n<h4 id=\"testing-http-services\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8np8ctrbx57ylxl7502b5csrq\"><i class=\"material-icons\">link</i>测试 HTTP 服务</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1f0yk2xdaafrzjmo4dqbh3th9\">对远程服务器进行 HTTP 调用的数据服务通常会注入并委托 给 Angular \n<a href=\"guide/http\"><code>HttpClient</code></a> 服务，以进行 XHR 调用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3g9qlybat1k78yqyv3n41dcea\">你可以使用注入的 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 间谍来测试数据服务，就像使用依赖项测试任何服务一样。 \n<code-example path=\"testing/src/app/model/hero.service.spec.ts\" region=\"test-with-spies\" title=\"app/model/hero.service.spec.ts (tests with spies)\">\n  let httpClientSpy: { get: jasmine.Spy }; let heroService: HeroService; beforeEach(() =&gt; { // TODO: spy on other methods too httpClientSpy = jasmine.createSpyObj('\n <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a>', ['get']); heroService = new HeroService(&lt;any&gt; httpClientSpy); }); it('should return expected heroes (\n <a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a> called once)', () =&gt; { const expectedHeroes: Hero[] = [{ id: 1, name: 'A' }, { id: 2, name: 'B' }]; httpClientSpy.get.and.returnValue(asyncData(expectedHeroes)); heroService.getHeroes().subscribe( heroes =&gt; expect(heroes).toEqual(expectedHeroes, 'expected heroes'), fail ); expect(httpClientSpy.get.calls.count()).toBe(1, 'one call'); }); it('should return an error when the server returns \n <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> 404', () =&gt; { const errorResponse = new \n <a href=\"api/common/http/HttpErrorResponse\" class=\"code-anchor\">HttpErrorResponse</a>({ error: 'test 404 error', status: 404, statusText: 'Not Found' }); httpClientSpy.get.and.returnValue(asyncError(errorResponse)); heroService.getHeroes().subscribe( heroes =&gt; fail('expected an error, not heroes'), error =&gt; expect(error.message).toContain('test 404 error') ); }); \n</code-example></p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bnsitfvcgf39smq9d7dw0ap0w\"><code>HeroService</code> 方法返回\n<em>可观察者</em>。 \n<em>订阅</em>方法可观察者以（a）使其执行，以及（b） 断言该方法成功或失败。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7f41d8uo3l2aq353kxfsa1in8\"><code>subscribe()</code> 方法接受成功和失败回调。 确保提供\n<em>两个</em>回调，以便捕获错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"jlozvr7tqjh25bypfedr9dke\">忽略这样做会导致异步未捕获的可观察者错误，测试运行器可能会将其归因于完全不同的测试。</p>\n</div>\n<h4 id=\"httpclienttestingmodule\"><em>HttpClientTestingModule</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"tm1mky3725skra0gjxdj06pv\">数据服务与 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 之间的扩展交互可能很复杂，难以使用间谍进行模拟。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9rqzs5plp4z02ukvw4tve4u5u\"><code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 可以使这些测试场景更易于管理。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"g9gwisuwoyzzod0vfzm4nd2m\">虽然本指南附带的\n<em>代码示例</em>演示了 \n<code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code>， 但本页面将转到 \n<a href=\"guide/http#testing-http-requests\">Http 指南</a>， 该指南详细介绍了使用 \n<code><a href=\"api/common/http/testing/HttpClientTestingModule\" class=\"code-anchor\">HttpClientTestingModule</a></code> 进行测试。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3d7dsnmkssl0j35qltsw9hc5d\">本指南的示例代码还演示了对\n<em>旧版</em> \n<code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code> 的测试，位于 \n<code>app/model/http-hero.service.spec.ts</code> 中。</p>\n</div>\n<h2 id=\"component-test-basics\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7f2whln9r8zdppwavmn07t3mt\"><i class=\"material-icons\">link</i>组件测试基础</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzanz8r3iru0rhy4ay82miwcp\">与 Angular 应用程序的其他所有部分不同，组件 结合了 HTML 模板和 TypeScript 类。 组件实际上是模板和类\n<em>协同工作</em>。 为了充分测试组件，你应该测试它们是否按预期协同工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1yvsew8713jqidcyqyuth9jof\">此类测试需要在浏览器 DOM 中创建组件的宿主元素， 就像 Angular 所做的那样，并调查组件类与其模板所描述的 DOM 之间的交互。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dy236fyujv52pxat4frdy8e6\">Angular \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 可以帮助你进行这种测试，你将在下面的部分中看到。 但在许多情况下，\n<em>单独测试组件类</em>，而无需 DOM 参与， 可以以更轻松、更明显的方式验证组件的大部分行为。</p>\n<h3 id=\"component-class-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26mhq7x1mb19fody4898e6z4t\"><i class=\"material-icons\">link</i>组件类测试</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6y61bnbx1ffej8bg7z1ejaikf\">你可以像测试服务类那样来测试一个组件类本身。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayzfvqvqe6nfuqc4dyqdgihzh\">考虑这个 \n<code>LightswitchComponent</code>，它在用户单击按钮时打开和关闭灯光 （由屏幕上的消息表示）。</p>\n<code-example path=\"testing/src/app/demo/demo.ts\" region=\"LightswitchComp\" title=\"app/demo/demo.ts (LightswitchComp)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'lightswitch-comp',\n  template: `\n    &lt;button (click)=\"clicked()\"&gt;Click me!&lt;/button&gt;\n    &lt;span&gt;{{message}}&lt;/span&gt;`\n})\nexport class LightswitchComponent {\n  isOn = false;\n  clicked() { this.isOn = !this.isOn; }\n  get message() { return `The light is ${this.isOn ? 'On' : 'Off'}`; }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pkbcav42nhqkbvx85zwsqmgz\">你可能只决定测试 \n<code>clicked()</code> 方法 是否切换灯光的\n<em>开/关</em>状态并相应地设置消息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47n2kpdtvqadyi5slzq6to4xg\">此组件类没有依赖项。 要测试没有依赖项的服务，可以使用 \n<code>new</code> 创建它，探查其 API， 并断言其公共状态的期望。 对组件类执行相同的操作。</p>\n<code-example path=\"testing/src/app/demo/demo.spec.ts\" region=\"Lightswitch\" title=\"app/demo/demo.spec.ts (Lightswitch tests)\" linenums=\"false\">\ndescribe('LightswitchComp', () =&gt; {\n  it('#clicked() should toggle #isOn', () =&gt; {\n    const comp = new LightswitchComponent();\n    expect(comp.isOn).toBe(false, 'off at first');\n    comp.clicked();\n    expect(comp.isOn).toBe(true, 'on after click');\n    comp.clicked();\n    expect(comp.isOn).toBe(false, 'off after second click');\n  });\n\n  it('#clicked() should set #message to \"is on\"', () =&gt; {\n    const comp = new LightswitchComponent();\n    expect(comp.message).toMatch(/is off/i, 'off at first');\n    comp.clicked();\n    expect(comp.message).toMatch(/is on/i, 'on after clicked');\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"b2a873c4i3s2xdl91x59rymqt\">下面是“<em>英雄之旅</em>”教程中的 <code>DashboardHeroComponent</code>。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"class\" title=\"app/dashboard/dashboard-hero.component.ts (component)\" linenums=\"false\">\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8v3bktmxiwy4iw59sbpld3m2v\">它出现在父组件的模板中， 该模板将\n<em>英雄</em>绑定到 \n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 属性， 并监听通过\n<em>selected</em> \n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 属性引发的事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vlweew4du01msq28x7tcadvs\">你可以测试类代码是否有效，而无需创建 \n<code>DashboardHeroComponent</code> 或其父组件。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"class-only\" title=\"app/dashboard/dashboard-hero.component.spec.ts (class tests)\" linenums=\"false\">\nit('raises the selected event when clicked', () =&gt; {\n  const comp = new DashboardHeroComponent();\n  const hero: Hero = { id: 42, name: 'Test' };\n  comp.hero = hero;\n\n  comp.selected.subscribe(selectedHero =&gt; expect(selectedHero).toBe(hero));\n  comp.click();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"di5c7rt07z31eb9uubtx7rw6y\">当组件具有依赖项时，你可能希望使用 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 来 创建组件及其依赖项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1rtb34ecbc7j2f8n4tpfg8w8s\">下列的 <code>WelcomeComponent</code> 依赖于 <code>UserService</code> 来了解要问候的用户的名字。</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.ts\" region=\"class\" title=\"app/welcome/welcome.component.ts\" linenums=\"false\">\nexport class WelcomeComponent  implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome: string;\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name : 'Please log in.';\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"ccfp4r32om1fgidvyc2tou2k\">你可以先创建一个能满足本组件最低需求的 <code>UserService</code>。</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"mock-user-service\" title=\"app/welcome/welcome.component.spec.ts (MockUserService)\" linenums=\"false\">\nclass MockUserService {\n  isLoggedIn = true;\n  user = { name: 'Test User'};\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8210fpn915t17s5vqi8fjlxvq\">然后在 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置中提供并注入\n<em>组件和服务</em>。</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-before-each\" title=\"app/welcome/welcome.component.spec.ts (class-only setup)\" linenums=\"false\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    // provide the component-under-test and dependent service\n    providers: [\n      WelcomeComponent,\n      { provide: UserService, useClass: MockUserService }\n    ]\n  });\n  // <a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a> both the component and the dependent service.\n  comp = TestBed.get(WelcomeComponent);\n  userService = TestBed.get(UserService);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ugwggy0px8p1ayd9r01a0pie\">然后练习组件类，记住调用 \n<a href=\"guide/lifecycle-hooks\">生命周期钩子方法</a>，就像 Angular 在运行应用程序时所做的那样。</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"class-only-tests\" title=\"app/welcome/welcome.component.spec.ts (class-only tests)\" linenums=\"false\">\nit('should not have welcome message after construction', () =&gt; {\n  expect(comp.welcome).toBeUndefined();\n});\n\nit('should welcome logged in user after Angular calls ngOnInit', () =&gt; {\n  comp.ngOnInit();\n  expect(comp.welcome).toContain(userService.user.name);\n});\n\nit('should ask user to log in if not logged in after ngOnInit', () =&gt; {\n  userService.isLoggedIn = false;\n  comp.ngOnInit();\n  expect(comp.welcome).not.toContain(userService.user.name);\n  expect(comp.welcome).toContain('log in');\n});\n\n</code-example>\n<h3 id=\"component-dom-testing\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"70g2i691nvigupf7srh5fhk89\"><i class=\"material-icons\">link</i>组件 DOM 测试</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7n1bw54k3nvzzdhcsfu9ziake\">测试组件\n<em>类</em>就像测试服务一样简单。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eqc1h89g5km2rj3ww62rmjsy0\">但组件不仅仅是它的类。 组件与 DOM 和其他组件交互。 \n<em>仅类</em>测试可以告诉你关于类行为的信息。 它们无法告诉你组件是否会正确渲染， 响应用户输入和手势，或与它的父组件和子组件集成。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bahh3phv8dt7qijlqy4w0hgy\">以上\n<em>仅类</em>测试都不能回答关于组件在屏幕上实际行为的关键问题。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"73w7vxvfnpp6yk1evgc1l3t7f\"><code>Lightswitch.clicked()</code> 绑定到了什么？用户可以调用它吗？</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"axl3vwfz8cwkm3kbqyr6yeit7\"><code>Lightswitch.message</code> 是否显示过？</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4y8rxjurpc93i1uhdh8xzd36k\">用户能否真正选中由 <code>DashboardHeroComponent</code> 显示的英雄？</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4pkgz90652nf4s7cex8fafx5f\">英雄名称是否按预期显示（即，大写）？</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"cvfaj0g6zqkq76rhdzj3mxzlk\"><code>WelcomeComponent</code> 的模板是否显示了欢迎信息？</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1lq9dvtilcql523ftui0s0hpm\">对于上面阐明的简单组件来说，这些可能不是令人困扰的问题。 但许多组件与模板中描述的 DOM 元素有复杂的交互，导致 HTML 在组件状态改变时出现和消失。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4p47irlhw35n2acbh0aiqtxe\">要回答这些问题，你必须创建与组件相关的 DOM 元素，你必须检查 DOM 以确认组件状态在适当的时间正确显示，并且你必须模拟用户与屏幕的交互，以确定这些交互是否导致组件按预期行为。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eo3ct1c4wpp9bi6he4e0g1y5k\">要编写这些类型的测试，你将使用 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的附加功能以及其他测试助手。</p>\n<h4 id=\"cli-generated-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ggwzep26szniu0e8orm299yt\"><i class=\"material-icons\">link</i>CLI 生成的测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3yltvytzp3hejb9r3mi5fdyky\">当你要求 CLI 生成一个新组件时，它默认会为你创建一个初始测试文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"89e94zxyg5oz680f450ycvpi9\">比如，下列 CLI 命令会在 <code>app/banner</code> 文件夹中生成带有内联模板和内联样式的 <code>BannerComponent</code>：</p>\n<code-example language=\"sh\" class=\"code-shell\">\nng generate component banner --inline-template --inline-style --module app\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"xy4shtzzakrlaoe8tjov12jb\">它还会生成一个初始测试文件 <code>banner-external.component.spec.ts</code>，如下所示：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v1\" title=\"app/banner/banner-external.component.spec.ts (initial)\" linenums=\"false\">\nimport { <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>, <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { BannerComponent } from './banner.component';\n\ndescribe('BannerComponent', () =&gt; {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;BannerComponent&gt;;\n\n  beforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ BannerComponent ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() =&gt; {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () =&gt; {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<h4 id=\"reduce-the-setup\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bo74wdz8ezfm08tkg4nv6wv4x\"><i class=\"material-icons\">link</i>减少设置代码</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ydoz7xkknwh28ahqu37381k3\">此文件只有最后三行实际上测试了组件，而且它们所做的只是断言 Angular 可以创建组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"cb73anqme9w4qio8k0x1j7ijy\">该文件的其它部分是做设置用的样板代码，<em>可以</em>预见，如果组件演变得更具实质性内容，就会需要更高级的测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eep0rn3ltpa0ojhd7wa83lv4q\">你将在下面了解这些高级测试功能。 现在，你可以将此测试文件大幅缩减到更易于管理的大小：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v2\" title=\"app/banner/banner-initial.component.spec.ts (minimal)\" linenums=\"false\">\ndescribe('BannerComponent (minimal)', () =&gt; {\n  it('should create', () =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ BannerComponent ]\n    });\n    const fixture = TestBed.createComponent(BannerComponent);\n    const component = fixture.componentInstance;\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gxqqm8zythfbnis59orcgrwu\">在此示例中，传递给 \n<code>TestBed.configureTestingModule</code> 的元数据对象只声明了要测试的组件 \n<code>BannerComponent</code>。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"configureTestingModule\">\nTestBed.configureTestingModule({\n  declarations: [ BannerComponent ]\n});\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82njjtv8sijfz1dsdthyfjuxz\">无需声明或导入其他任何内容。 默认测试模块预先配置了类似于 \n<code>@angular/platform-browser</code> 中的 \n<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 的东西。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46yt2q2dpkryj2ircixbfj1vf\">稍后，你将使用导入、提供者和更多声明来调用 \n<code>TestBed.configureTestingModule()</code> 以满足你的测试需求。 可选的 \n<code>override</code> 方法可以进一步微调配置的各个方面。</p>\n</div>\n<a id=\"create-component\"></a>\n<h4 id=\"createcomponent\"><em>createComponent()</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afr03jzniy6x7av52077xusv6\">配置完 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 后，你调用它的 \n<code>createComponent()</code> 方法。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"createComponent\">\nconst fixture = TestBed.createComponent(BannerComponent);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3n6lzp4u73ls8awaarddbrxja\"><code>TestBed.createComponent()</code> 创建 \n<code>BannerComponent</code> 的实例， 将相应的元素添加到测试运行器 DOM， 并返回一个 \n<a href=\"guide/testing#component-fixture\"><code>ComponentFixture</code></a>。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85e817ztfl08vg91j4sl7giaf\">不要在调用 \n<code>createComponent</code> 后重新配置 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"btaprwey46yk2152uvlmpx0e2\"><code>createComponent</code> 方法冻结当前 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 定义， 关闭它以进行进一步配置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3y6o72i1aa5b3cmkbhwioxz2z\">你不能再调用任何 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置方法，无论是 \n<code>configureTestingModule()</code>， 还是 \n<code>get()</code>，还是任何 \n<code>override...</code> 方法。 如果你尝试，\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 会抛出错误。</p>\n</div>\n<a id=\"component-fixture\"></a>\n<h4 id=\"componentfixture\"><em>ComponentFixture</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"dig5ymr73jnuf7e0k1qwzxf1d\"><a href=\"api/core/testing/ComponentFixture\">ComponentFixture</a> 是一个测试挽具，用于与所创建的组件及其对应的元素进行交互。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8tfo3tt1yc21309e4zsvzf1t5\">可以通过测试夹具（fixture）访问组件实例，并用 Jasmine 的期望断言来确认它是否存在：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"componentInstance\">\nconst component = fixture.componentInstance;\nexpect(component).toBeDefined();\n\n</code-example>\n<h4 id=\"beforeeach\"><em>beforeEach()</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dx6s14c01oswvk8kgomfijka9\">随着此组件的演变，你将添加更多测试。 与其为每个测试重复 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置， 不如重构以将设置拉入 Jasmine \n<code>beforeEach()</code> 和一些支持变量中：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v3\" linenums=\"false\">\ndescribe('BannerComponent (with beforeEach)', () =&gt; {\n  let component: BannerComponent;\n  let fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;BannerComponent&gt;;\n\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      declarations: [ BannerComponent ]\n    });\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should create', () =&gt; {\n    expect(component).toBeDefined();\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cba1vdzoodkw0kahf87a5j4gx\">现在添加一个测试，从 \n<code>fixture.nativeElement</code> 获取组件的元素， 并查找预期的文本。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-2\">\nit('should contain \"banner works!\"', () =&gt; {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  expect(bannerElement.textContent).toContain('banner works!');\n});\n\n</code-example>\n<a id=\"native-element\"></a>\n<h4 id=\"nativeelement\"><em>nativeElement</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"64lgktv8yi97sbrzw5kg7yukz\"><code><a href=\"api/core/testing/ComponentFixture#nativeElement\" class=\"code-anchor\">ComponentFixture.nativeElement</a></code> 的值具有 \n<code>any</code> 类型。 稍后你将遇到 \n<code><a href=\"api/core/DebugElement#nativeElement\" class=\"code-anchor\">DebugElement.nativeElement</a></code>，它也具有 \n<code>any</code> 类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2g3ns5314oghv3fitgbb38co\">Angular 在编译时无法知道 \n<code>nativeElement</code> 是什么类型的 HTML 元素，或者它是否甚至是一个 HTML 元素。 该应用可能在\n<em>非浏览器平台</em>上运行，例如服务器或 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\">Web Worker</a>， 其中元素可能具有缩减的 API 或根本不存在。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44kohifz0gllm01ka38yhv401\">本指南中的测试旨在在浏览器中运行，因此 \n<code>nativeElement</code> 值始终是 \n<code>HTMLElement</code> 或 它的派生类之一。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jeuxsbdm1qrgs438yg5z72zc\">知道它是一种 \n<code>HTMLElement</code>，你可以使用 标准 HTML \n<code>querySelector</code> 深入元素树。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"687nn2akmvlqrgu5ynqsjkpk2\">这是另一个调用 <code>HTMLElement.querySelector</code> 来获取段落元素并查找横幅文本的测试：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-3\">\nit('should have &lt;p&gt; with \"banner works!\"', () =&gt; {\n  const bannerElement: HTMLElement = fixture.nativeElement;\n  const p = bannerElement.querySelector('p');\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<a id=\"debug-element\"></a>\n<h4 id=\"debugelement\"><em>DebugElement</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5efr4jb411njcd7b8q08aocjy\">Angular 的<em>测试夹具</em>可以直接通过 <code>fixture.nativeElement</code> 提供组件的元素。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"nativeElement\">\nconst bannerElement: HTMLElement = fixture.nativeElement;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4fgzr3iaarpttuqgv9kc04k1k\">它实际上是一个便利方法，其最终实现为 <code>fixture.debugElement.nativeElement</code>。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"debugElement-nativeElement\">\nconst bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\nconst bannerEl: HTMLElement = bannerDe.nativeElement;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8afwu9ff9dw5styosdyhz564b\">使用这种迂回的路径访问元素是有充分理由的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3nx1ej5fk11dsnlkvll8nbz4l\"><code>nativeElement</code> 的属性取决于运行时环境。 你可能在\n<em>非浏览器</em>平台上运行这些测试，该平台没有 DOM 或 其 DOM 模拟不支持完整的 \n<code>HTMLElement</code> API。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crgzdhlijvx88dgy8ydp938si\">Angular 依赖于 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 抽象来安全地在\n<em>所有支持的平台</em>上工作。 Angular 不是创建 HTML 元素树，而是创建 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 树，它包装了运行时平台的\n<em>原生元素</em>。 \n<code>nativeElement</code> 属性解开 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 并返回特定于平台的元素对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36x2qkqpn4mt3c3run5dteqpl\">由于本指南的示例测试旨在仅在浏览器中运行， 因此这些测试中的 \n<code>nativeElement</code> 始终是 \n<code>HTMLElement</code>， 你可以在测试中探索其熟悉的 method 和 property。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"128gs1509mvvu9rxcrpvup39b\">下面是把前述测试用 <code>fixture.debugElement.nativeElement</code> 重新实现的版本：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-4\">\nit('should find the &lt;p&gt; with fixture.debugElement.nativeElement)', () =&gt; {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const bannerEl: HTMLElement = bannerDe.nativeElement;\n  const p = bannerEl.querySelector('p');\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5h3h3a3wcwqs4aeyc7kn5c4j2\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 还有其他 method 和 property， 这些 method 和 property 在测试中很有用，正如你将在本指南的其他地方看到的那样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1f0g1pjr8scdnha492csxbpsq\">你从 Angular 核心库中导入 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 符号。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-debug-element\">\nimport { <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> } from '@angular/core';\n\n</code-example>\n<a id=\"by-css\"></a>\n<h4 id=\"bycss\"><em>By.css()</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1t7nlvyhj9x6jto1qeqij1pu9\">虽然本指南中的所有测试都在浏览器中运行， 但某些应用可能至少在某些时候在不同的平台上运行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"515fac6708y10gatla1say84b\">例如，组件可能首先在服务器上渲染，作为一种策略，使应用程序在连接不良的设备上更快地启动。服务器端渲染器可能不支持完整的 HTML 元素 API。 如果它不支持 \n<code>querySelector</code>，则之前的测试可能会失败。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4xg7208wpxik2yo67we0k8h2\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 提供了适用于所有支持平台的查询方法。 这些查询方法采用\n<em>谓词</em>函数，当 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 树中的节点匹配选择条件时，该函数返回 \n<code>true</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d36em2s7tzdlqy8fqy2t754r0\">你可以在运行时平台的库中导入的 \n<code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 类的帮助下创建\n<em>谓词</em>。以下是浏览器平台的 \n<code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 导入：</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"import-by\">\nimport { <a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a> } from '@angular/platform-browser';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6vgjmm56evaw1boquguh4sf6\">以下示例使用 \n<code><a href=\"api/core/DebugElement#query\" class=\"code-anchor\">DebugElement.query()</a></code> 和浏览器的 \n<code>By.css</code> 方法重新实现了之前的测试。</p>\n<code-example path=\"testing/src/app/banner/banner-initial.component.spec.ts\" region=\"v4-test-5\">\nit('should find the &lt;p&gt; with fixture.debugElement.query(By.css)', () =&gt; {\n  const bannerDe: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> = fixture.debugElement;\n  const paragraphDe = bannerDe.query(By.css('p'));\n  const p: HTMLElement = paragraphDe.nativeElement;\n  expect(p.textContent).toEqual('banner works!');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"f1nt5wwy7nvckrhsnx387q2o0\">一些值得注意的地方：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2pk57y0mxp20wrjn2dtx701dx\"><code><a href=\"api/platform-browser/By#css\" class=\"code-anchor\">By.css()</a></code> 静态方法选择具有 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors\" title=\"CSS selectors\">标准 CSS 选择器</a> 的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 节点。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ez7qtkq6as9vxyj2exdp49slt\">查询返回段落的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"dyollt7kyn2tib0qmq9m44ei4\">你必须解包那个结果才能得到 p 元素。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u1pnvsp8t0f9cnxjxakrcfq1\">当你通过 CSS 选择器进行过滤，并且只测试浏览器\n<em>原生元素</em>的属性时，\n<code>By.css</code> 方法可能过于复杂。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"79df4du3nii6l3u48ibhtxh6y\">使用标准 \n<code>HTMLElement</code> 方法（如 \n<code>querySelector()</code> 或 \n<code>querySelectorAll()</code>）进行过滤通常更简单、更清晰， 正如你将在下一组测试中看到的那样。</p>\n<hr>\n<h2 id=\"component-test-scenarios\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aov5ea0o780xpkm7v42to9zqa\"><i class=\"material-icons\">link</i>组件测试场景</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"euw627417gnb53gmtm5yg4nij\">以下部分（构成本指南的大部分内容）探讨了常见的 组件测试场景</p>\n<h3 id=\"component-binding\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"f0asb3p38hvlasskxr2g0unas\"><i class=\"material-icons\">link</i>组件绑定</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8m3ii01gljo9926rks8x4ijw2\">当前的 \n<code>BannerComponent</code> 在 HTML 模板中呈现静态标题文本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"67f6s0cg13nma587ginx400qr\">经过一些修改，\n<code>BannerComponent</code> 通过绑定到组件的 \n<code>title</code> 属性来呈现动态标题，如下所示。</p>\n<code-example path=\"testing/src/app/banner/banner.component.ts\" region=\"component\" title=\"app/banner/banner.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  template: '&lt;h1&gt;{{title}}&lt;/h1&gt;',\n  styles: ['h1 { color: green; font-size: 350%}']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2th7f9ik81fkw7qnhh1gbhxhp\">虽然很简单，但你决定添加一个测试来确认组件是否真的在预期位置显示了正确的内容。</p>\n<h4 id=\"query-for-the-h1\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4epqtlbgj7lp6wdz9xy874yrr\"><i class=\"material-icons\">link</i>查询 \n<em>&lt;h1&gt;</em> 元素</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8nl6t20ue0s13orl13r3w9bfx\">你将编写一系列测试，检查包裹在 \n<em>title</em> 属性插值绑定的 \n<code>&lt;h1&gt;</code> 元素的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2q7hy44jpg10f3wsmxqbyblne\">你更新了 \n<code>beforeEach</code>，使用标准的 HTML \n<code>querySelector</code> 找到该元素，并将其赋值给 \n<code>h1</code> 变量。</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"setup\" title=\"app/banner/banner.component.spec.ts (setup)\" linenums=\"false\">\nlet component: BannerComponent;\nlet fixture:   <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;BannerComponent&gt;;\nlet h1:        HTMLElement;\n\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent test instance\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<a id=\"detect-changes\"></a>\n<h4 id=\"createcomponent-does-not-bind-data\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0xel2yqfzjet10qjk438do9\"><i class=\"material-icons\">link</i><em>createComponent()</em> 不会绑定数据</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2f851s9zxzckdoswjaxpco0sg\">对于你的第一个测试，你希望屏幕上显示默认的 <code>title</code>。你的直觉就是编写一个能立即检查 <code>&lt;h1&gt;</code> 的测试，就像这样：</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default-v1\">\nit('should display original title', () =&gt; {\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2dqpzcuuu30mwevl5n2wbl0nv\"><em>那个测试失败</em>了：</p>\n<code-example language=\"javascript\">\nexpected '' to contain 'Test Tour of Heroes'.\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"422huc53i246yaaem1j9lm5br\"><strong>当 Angular 执行变更检测</strong>时就会发生绑定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bnwf9g25z1cvefomi88pkx7dy\">在生产环境中，当 Angular 创建组件或用户输入按键或异步活动（例如 AJAX）完成时，变更检测会自动启动。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsp6my41zjjtqd4yfbywv59kx\"><code>TestBed.createComponent</code> \n<em>不会</em>触发变更检测。 修改后的测试证实了这一点：</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"test-w-o-detect-changes\" linenums=\"false\">\nit('no title in the DOM after createComponent()', () =&gt; {\n  expect(h1.textContent).toEqual('');\n});\n\n</code-example>\n<h4 id=\"detectchanges\"><em>detectChanges()</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eye1s8wbn4jtej4aj64q58911\">你必须告诉 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 通过调用 \n<code>fixture.detectChanges()</code> 来执行数据绑定。 只有这样，\n<code>&lt;h1&gt;</code> 才会显示预期的标题。</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"expect-h1-default\">\nit('should display original title after detectChanges()', () =&gt; {\n  fixture.detectChanges();\n  expect(h1.textContent).toContain(component.title);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edj2rph4kdaivvisd7wrdlybl\">延迟变更检测是有意为之，也是很有用的。 它让测试人员有机会在 Angular 启动数据绑定并调用 \n<a href=\"guide/lifecycle-hooks\">生命周期钩子</a> 之前检查和更改组件的状态。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"46hf55079ndq85x7vg8elnxrx\">这是另一个测试，它会在调用 <code>fixture.detectChanges()</code> <em>之前</em>改变组件的 <code>title</code> 属性。</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"after-change\">\nit('should display <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> different test title', () =&gt; {\n  component.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges();\n  expect(h1.textContent).toContain('Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>');\n});\n\n</code-example>\n<a id=\"auto-detect-changes\"></a>\n<h4 id=\"automatic-change-detection\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"d9dphvlbvnlcqv7ql0p7bc2zr\"><i class=\"material-icons\">link</i>自动变更检测</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"67kw3f10c7etrll6slzlv28f6\"><code>BannerComponent</code> 测试会经常调用 <code>detectChanges</code>。一些测试人员更喜欢让 Angular 测试环境自动运行变更检测。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"237ql38jq4nzohmnwtqa5rabc\">可以通过使用 \n<code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 提供者配置 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 来实现这一点。 首先从测试工具库中导入它：</p>\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"import-ComponentFixtureAutoDetect\" title=\"app/banner/banner.component.detect-changes.spec.ts (import)\" linenums=\"false\">\nimport { <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a> } from '@angular/core/testing';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"f3xbom95bbm35awdgyvuopd3u\">然后把它添加到测试模块配置的 <code>providers</code> 中：</p>\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect\" title=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [ BannerComponent ],\n  providers: [\n    { provide: <a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a>, useValue: true }\n  ]\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"eu7pt1x656xdovf9quymkcrw4\">这里有三个测试来说明自动变更检测是如何工作的。</p>\n<code-example path=\"testing/src/app/banner/banner.component.detect-changes.spec.ts\" region=\"auto-detect-tests\" title=\"app/banner/banner.component.detect-changes.spec.ts (AutoDetect Tests)\" linenums=\"false\">\nit('should display original title', () =&gt; {\n  // Hooray! No `fixture.detectChanges()` needed\n  expect(h1.textContent).toContain(comp.title);\n});\n\nit('should still see original title after comp.title change', () =&gt; {\n  const oldTitle = comp.title;\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  // Displayed title is old because Angular didn't hear the change :(\n  expect(h1.textContent).toContain(oldTitle);\n});\n\nit('should display updated title after detectChanges', () =&gt; {\n  comp.title = 'Test <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a>';\n  fixture.detectChanges(); // detect changes explicitly\n  expect(h1.textContent).toContain(comp.title);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"be5qqigl841bsssz3greu05ff\">第一个测试显示了自动变更检测的优点。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq7f7ghb0fridmv0ouhva9ois\">第二个和第三个测试揭示了一个重要的限制。 Angular 测试环境\n<em>不知道</em>测试更改了组件的 \n<code>title</code>。 \n<code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code> 服务响应\n<em>异步活动</em>，例如 Promise 解析、计时器和 DOM 事件。 但直接的同步更新组件属性是不可见的。 测试必须手动调用 \n<code>fixture.detectChanges()</code> 来触发另一个变更检测周期。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6adt4cpwoo2r6jdzz4c8w80tl\">与其猜测测试夹具何时会或不会执行变更检测， 本指南中的示例\n<em>始终显式调用</em> \n<code>detectChanges()</code>。 比严格必要时更频繁地调用 \n<code>detectChanges()</code> 不会造成任何危害。</p>\n</div>\n<hr>\n<a id=\"dispatch-event\"></a>\n<h4 id=\"change-an-input-value-with-dispatchevent\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7f6xm31utyy73ty5behe5n2rt\"><i class=\"material-icons\">link</i>使用 \n<em>dispatchEvent()</em> 更改输入值</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tox59gxu9bdfejh5zo0n3ffd\">要模拟用户输入，你可以找到输入元素并设置其 \n<code>value</code> 属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bucusr3q99wcxkxfijsy6zeqr\">你会调用 <code>fixture.detectChanges()</code> 来触发 Angular 的变更检测。但还有一个重要的中间步骤。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5i0oozs2salh77nhrccxwq16q\">Angular 并不知道你为 input 设置过 <code>value</code> 属性。在通过调用 <code>dispatchEvent()</code> 分发 <code>input</code> 事件之前，它不会读取该属性。<em>紧接着</em>你就调用了 <code>detectChanges()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"esidsmwffl3td2l6t9h9nisei\">下列例子说明了正确的顺序。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\" title=\"app/hero/hero-detail.component.spec.ts (pipe test)\">\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input');\n  const nameDisplay: HTMLElement = hostElement.querySelector('span');\n\n  // simulate user entering <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // dispatch <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> DOM event so that Angular learns of input value change.\n  nameInput.dispatchEvent(newEvent('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<hr>\n<h3 id=\"component-with-external-files\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2tupz2zj58o18z446ljjyvnee\"><i class=\"material-icons\">link</i>具有外部文件的组件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q4jnplnpe1awoqngc22fnm2i\">上面的 \n<code>BannerComponent</code> 是使用\n<em>内联模板</em>和\n<em>内联 CSS</em> 定义的，分别在 \n<code>@<a href=\"api/core/Component#template\" class=\"code-anchor\">Component.template</a></code> 和 \n<code>@<a href=\"api/core/Component#styles\" class=\"code-anchor\">Component.styles</a></code> 属性中指定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kcydgepsc2t1o9uw2d0gok41\">许多组件使用 \n<code>@<a href=\"api/core/Component#templateUrl\" class=\"code-anchor\">Component.templateUrl</a></code> 和 \n<code>@<a href=\"api/core/Component#styleUrls\" class=\"code-anchor\">Component.styleUrls</a></code> 属性分别指定\n<em>外部模板</em>和\n<em>外部 CSS</em>， 如下面的 \n<code>BannerComponent</code> 变体所示。</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.ts\" region=\"metadata\" title=\"app/banner/banner-external.component.ts (metadata)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls:  ['./banner-external.component.css']\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"41nllu3k4zs2wf2vsgpkq16f6\">这个语法告诉 Angular 编译器要在组件编译时读取外部文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dm9dsatgbaqo8vmr47aarygx\">当你运行 CLI \n<code>ng test</code> 命令时，这不会造成问题，因为它 \n<em>在运行测试之前编译应用程序</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8o4f9ydpyllpbf78sw6pmpmob\">但是，如果你在\n<strong>非 CLI 环境</strong>中运行测试， 此组件的测试可能会失败。 例如，如果你在 \n<a href=\"http://plnkr.co/\">plunker</a> 等 Web 编码环境中运行 \n<code>BannerComponent</code> 测试，你将看到类似以下的错误消息：</p>\n<code-example language=\"sh\" class=\"code-shell\" hidecopy=\"\">\nError: This test module uses the component BannerComponent \nwhich is using <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> \"templateUrl\" or \"styleUrls\", but they were never compiled. \nPlease call \"TestBed.compileComponents\" before your test.\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93940pn9peu3k8xrmwqv71835\">当你运行时环境 \n<em>在测试本身期间</em>编译源代码时，就会出现此测试失败消息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ek0w0uyuq0evwshlsxrdvnn36\">要解决此问题，请调用 \n<code>compileComponents()</code>，如 \n<a href=\"guide/testing#compile-components\">下面</a> 所述。</p>\n<a id=\"component-with-dependency\"></a>\n<h3 id=\"component-with-a-dependency\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gc7b5p3txeu55fqumg6fbmqt\"><i class=\"material-icons\">link</i>具有依赖项的组件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"50nquo5snywxvj44c3c0fyazg\">组件通常都有服务依赖。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8xbgh0emfmuoa3a04ig7yzpil\"><code>WelcomeComponent</code> 向已登录的用户显示欢迎消息。 它根据注入的 \n<code>UserService</code> 的某个属性来了解用户是谁：</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.ts\" title=\"app/welcome/welcome.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { UserService }       from '../model/user.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-welcome',\n  template: '&lt;h3 class=\"welcome\"&gt;&lt;i&gt;{{welcome}}&lt;/i&gt;&lt;/h3&gt;'\n})\nexport class WelcomeComponent  implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  welcome: string;\n  constructor(private userService: UserService) { }\n\n  ngOnInit(): void {\n    this.welcome = this.userService.isLoggedIn ?\n      'Welcome, ' + this.userService.user.name : 'Please log in.';\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87d3qngudmcw3unywkqw8yo7h\"><code>WelcomeComponent</code> 具有与服务交互的决策逻辑，这种逻辑使该组件值得测试。 以下是 spec 文件 \n<code>app/welcome/welcome.component.spec.ts</code> 的测试模块配置：</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"config-test-module\" title=\"app/welcome/welcome.component.spec.ts\" linenums=\"false\">\nTestBed.configureTestingModule({\n   declarations: [ WelcomeComponent ],\n// providers:    [ UserService ]  // NO! Don't provide the real service!\n                                  // Provide <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> test-double instead\n   providers:    [ {provide: UserService, useValue: userServiceStub } ]\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"130pyhgnwn5c40bkg40dnid12\">这次，除了声明<em>被测组件外</em>，该配置还在 <code>providers</code> 列表中加入了 <code>UserService</code> 提供者。但它不是真正的 <code>UserService</code>。</p>\n<a id=\"service-test-doubles\"></a>\n<h4 id=\"provide-service-test-doubles\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1w4q8bm5nr807s5qarba8g1kj\"><i class=\"material-icons\">link</i>为服务提供测试替身</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"67w18mpaj6ou1n97t5ey15k3\"><em>被测组件</em>不必注入真实的服务。 实际上，如果它们是测试替身（桩、模拟、间谍或模拟），通常会更好。 spec 的目的是测试组件，而不是服务， 而真实的服务可能会带来麻烦。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"be5zwapvr7ine9pcirb9lgjam\">注入真实的 \n<code>UserService</code> 可能会是一场噩梦。 真实的服务可能会要求用户提供登录凭据， 并尝试连接到身份验证服务器。 这些行为可能难以拦截。 创建和注册一个测试替身来代替真实的 \n<code>UserService</code> 更加容易和安全。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ozy3coyyeh6gmxk6vpeheoj2\">此特定的测试套件提供了一个 \n<code>UserService</code> 的最小模拟，它满足了 \n<code>WelcomeComponent</code> 及其测试的需求：</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"user-service-stub\" title=\"app/welcome/welcome.component.spec.ts\" linenums=\"false\">\nlet userServiceStub: Partial&lt;UserService&gt;;\n\nuserServiceStub = {\n  isLoggedIn: true,\n  user: { name: 'Test User'}\n};\n\n</code-example>\n<a id=\"get-injected-service\"></a>\n<h4 id=\"get-injected-services\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"45778uy3p2czps47kn5uge4uw\"><i class=\"material-icons\">link</i>获取注入的服务</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3bm4yst1s08djgpvjs6k49gp7\">测试需要访问注入到 \n<code>WelcomeComponent</code> 中的（桩）\n<code>UserService</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ag10f0ej3toz3wpxoqdsw4kkd\">Angular 具有分层注入系统。 可以在多个级别存在注入器，从 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 创建的根注入器 一直到组件树。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5s0h29h0cwhx4n7xrf9p22nxo\">获取注入服务的最佳方法，也是\n<strong>始终有效</strong>的方法， 是\n<strong>从<em>被测组件</em>的注入器中获取它</strong>。 组件注入器是夹具的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 的一个属性。</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"injected-service\" title=\"WelcomeComponent's injector\">\n// UserService actually injected into the component\nuserService = fixture.debugElement.injector.get(UserService);\n\n</code-example>\n<a id=\"testbed-get\"></a>\n<h4 id=\"testbedget\"><em>TestBed.get()</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"799etj1j6oook8vs29rbnl43h\">你\n<em>可能</em>也可以通过 \n<code>TestBed.get()</code> 从根注入器中获取服务。 这更容易记住，而且更简洁。 但这只有在 Angular 在测试的根注入器中使用服务实例注入组件时才有效。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ca8eo3y4mtsb1k44jskdreuy\">在此测试套件中，\n<code>UserService</code> 的\n<em>唯一</em>提供者是根测试模块， 因此可以安全地按如下方式调用 \n<code>TestBed.get()</code>：</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"inject-from-testbed\" title=\"TestBed injector\">\n// UserService from the root injector\nuserService = TestBed.get(UserService);\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djpgp3n41vzh9rh0i7irf27x0\">对于 \n<code>TestBed.get()</code> 不起作用的用例， 请参阅 \n<a href=\"guide/testing#component-override\"><em>覆盖组件的提供者</em></a> 部分，其中 解释了何时以及为何必须从组件的注入器中获取服务。</p>\n</div>\n<a id=\"service-from-injector\"></a>\n<h4 id=\"always-get-the-service-from-an-injector\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayluexnxygj71ml5u7710p9du\"><i class=\"material-icons\">link</i>始终从注入器中获取服务</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"14zjwippdwswc3tq786jbvgcr\"><em>不要</em>引用 在测试主体中提供给测试模块的 \n<code>userServiceStub</code> 对象。 \n<strong>它不起作用！</strong> 注入到组件中的 \n<code>userService</code> 实例是一个完全\n<em>不同的</em>对象， 是提供的 \n<code>userServiceStub</code> 的克隆。</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"stub-not-injected\" title=\"app/welcome/welcome.component.spec.ts\" linenums=\"false\">\nit('stub object and injected UserService should not be the same', () =&gt; {\n  expect(userServiceStub === userService).toBe(false);\n\n  // Changing the stub object has no effect on the injected service\n  userServiceStub.isLoggedIn = false;\n  expect(userService.isLoggedIn).toBe(true);\n});\n\n</code-example>\n<a id=\"welcome-spec-setup\"></a>\n<h4 id=\"final-setup-and-tests\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c2jcr1xsg9s2nvsca1wo5rjso\"><i class=\"material-icons\">link</i>最后的设置与测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47u4h7hfg9rd1ojtybvn2oy0c\">以下是使用 \n<code>TestBed.get()</code> 的完整 \n<code>beforeEach()</code>：</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"setup\" title=\"app/welcome/welcome.component.spec.ts\" linenums=\"false\">\n  let userServiceStub: Partial&lt;UserService&gt;;\n\nbeforeEach(() =&gt; {\n  // stub UserService for test purposes\n  userServiceStub = {\n    isLoggedIn: true,\n    user: { name: 'Test User'}\n  };\n\n  TestBed.configureTestingModule({\n     declarations: [ WelcomeComponent ],\n     providers:    [ {provide: UserService, useValue: userServiceStub } ]\n  });\n\n  fixture = TestBed.createComponent(WelcomeComponent);\n  comp    = fixture.componentInstance;\n\n  // UserService from the root injector\n  userService = TestBed.get(UserService);\n\n  //  get the \"welcome\" element by CSS selector (e.g., by class name)\n  el = fixture.nativeElement.querySelector('.welcome');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"dlp37v1vnodhqg9bs8toz03x2\">以下是一些测试：</p>\n<code-example path=\"testing/src/app/welcome/welcome.component.spec.ts\" region=\"tests\" title=\"app/welcome/welcome.component.spec.ts\" linenums=\"false\">\nit('should welcome the user', () =&gt; {\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).toContain('Welcome', '\"Welcome ...\"');\n  expect(content).toContain('Test User', 'expected name');\n});\n\nit('should welcome \"Bubba\"', () =&gt; {\n  userService.user.name = 'Bubba'; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  expect(el.textContent).toContain('Bubba');\n});\n\nit('should request login if not logged in', () =&gt; {\n  userService.isLoggedIn = false; // welcome message hasn't been shown yet\n  fixture.detectChanges();\n  const content = el.textContent;\n  expect(content).not.toContain('Welcome', 'not welcomed');\n  expect(content).toMatch(/log in/i, '\"log in\"');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"ab103lnr8m8r3s4yhd20qd61i\">首先是一个健全性测试；它确认了桩服务 <code>UserService</code> 被调用过并能正常工作。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqwawxjdjvininamz676ogm70\">Jasmine 匹配器的第二个参数（例如 \n<code>'expected name'</code>）是一个可选的失败标签。 如果期望失败，Jasmine 会将此标签附加到期望失败消息。 在一个包含多个期望的 spec 中，这有助于澄清出了什么问题以及哪个期望失败。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8oztbnowfapmjh4fddh3q6xxh\">当该服务返回不同的值时，其余的测试会确认该组件的逻辑。第二个测试验证了更改用户名的效果。当用户未登录时，第三个测试会检查组件是否显示了正确的消息。</p>\n<hr>\n<a id=\"component-with-async-service\"></a>\n<h3 id=\"component-with-async-service\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"89pawgl0p7g1f5jqz1hlsyba5\"><i class=\"material-icons\">link</i>具有异步服务的组件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"edm9ff239y53dlmyg0xhu3kh1\">在这个例子中，<code>AboutComponent</code> 模板托管了一个 <code>TwainComponent</code>。<code>TwainComponent</code> 会显示马克·吐温的名言。</p>\n<code-example path=\"testing/src/app/twain/twain.component.ts\" region=\"template\" title=\"app/twain/twain.component.ts (template)\" linenums=\"false\">\ntemplate: `\n  &lt;p class=\"twain\"&gt;&lt;i&gt;{{quote | async}}&lt;/i&gt;&lt;/p&gt;\n  &lt;button (click)=\"getQuote()\"&gt;Next quote&lt;/button&gt;\n  &lt;p class=\"error\" *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"errorMessage\"&gt;{{ errorMessage }}&lt;/p&gt;`,\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bc2r0iumc87q9ooi2czqd93nd\">请注意，组件的 \n<code>quote</code> 属性的值通过 \n<code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code> 传递。 这意味着该属性返回 \n<code>Promise</code> 或 \n<code>Observable</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e42bqn0i7vwuknw5yg0d5u64o\">在此示例中，\n<code>TwainComponent.getQuote()</code> 方法告诉我们 \n<code>quote</code> 属性返回一个 \n<code>Observable</code>。</p>\n<code-example path=\"testing/src/app/twain/twain.component.ts\" region=\"get-quote\" title=\"app/twain/twain.component.ts (getQuote)\" linenums=\"false\">\ngetQuote() {\n  this.errorMessage = '';\n  this.quote = this.twainService.getQuote().pipe(\n    startWith('...'),\n    catchError( (err: any) =&gt; {\n      // Wait <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> turn because errorMessage already set once this turn\n      setTimeout(() =&gt; this.errorMessage = err.message || err.toString());\n      return of('...'); // reset message to placeholder\n    })\n  );\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3lyyz7zzh7h83xob23l7tqc40\"><code>TwainComponent</code> 从注入的 \n<code>TwainService</code> 获取引号。 组件使用占位符值（\n<code>'...'</code>）启动返回的 \n<code>Observable</code>， 在服务能够返回其第一个引号之前。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ln2k5psspyddcydp7q1kuocs\"><code>catchError</code> 拦截服务错误，准备错误消息， 并在成功通道上返回占位符值。 它必须等待一个 tick 来设置 \n<code>errorMessage</code>， 以避免在同一个变更检测周期内两次更新该消息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"3sjgc24129i86m7ewydreookt\">这些都是你想要测试的特性。</p>\n<h4 id=\"testing-with-a-spy\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"dzqjwahmrwy6h4ebjinsilcm\"><i class=\"material-icons\">link</i>使用间谍（spy）进行测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"anv1qeaxsjn5kck2554zs39hq\">在测试组件时，只有服务的公共 API 应该起作用。 一般来说，测试本身不应该调用远程服务器。 它们应该模拟此类调用。\n<code>app/twain/twain.component.spec.ts</code> 中的设置展示了一种实现此目的的方法：</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"setup\" title=\"app/twain/twain.component.spec.ts (setup)\" linenums=\"false\">\nbeforeEach(() =&gt; {\n  testQuote = 'Test Quote';\n\n  // Create <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> fake TwainService object with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> `getQuote()` spy\n  const twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n  // Make the spy return <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> synchronous Observable with the test data\n  getQuoteSpy = twainService.getQuote.and.returnValue( of(testQuote) );\n\n  TestBed.configureTestingModule({\n    declarations: [ TwainComponent ],\n    providers:    [\n      { provide: TwainService, useValue: twainService }\n    ]\n  });\n\n  fixture = TestBed.createComponent(TwainComponent);\n  component = fixture.componentInstance;\n  quoteEl = fixture.nativeElement.querySelector('.twain');\n});\n\n</code-example>\n<a id=\"service-spy\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"cup3iu7q744k00p8r29o1ww04\">仔细看一下这个间谍。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy\">\n// Create <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> fake TwainService object with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> `getQuote()` spy\nconst twainService = jasmine.createSpyObj('TwainService', ['getQuote']);\n// Make the spy return <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> synchronous Observable with the test data\ngetQuoteSpy = twainService.getQuote.and.returnValue( of(testQuote) );\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"edw8lqnulq3ieqzhzbdcp0l0s\">间谍的设计使得对 \n<code>getQuote</code> 的任何调用都会收到一个包含测试引号的 Observable。 与真实的 \n<code>getQuote()</code> 方法不同，此间谍绕过了服务器， 并返回一个同步 Observable，其值可以立即获得。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5g60gwz61nrhzwgzdf0kxccc4\">虽然这个 <code>Observable</code> 是同步的，但你也可以用这个间谍编写很多有用的测试。</p>\n<a id=\"sync-tests\"></a>\n<h4 id=\"synchronous-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xhnk8619g2837p7eu6z4vjwu\"><i class=\"material-icons\">link</i>同步测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3t0yb5820f5o93ipr3uwdiqlx\">同步 \n<code>Observable</code> 的一个主要优势是， 你通常可以将异步进程转换为同步测试。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"sync-test\">\nit('should show quote after component initialized', () =&gt; {\n  fixture.detectChanges(); // onInit()\n\n  // sync spy result shows testQuote immediately after init\n  expect(quoteEl.textContent).toBe(testQuote);\n  expect(getQuoteSpy.calls.any()).toBe(true, 'getQuote called');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eg6te76nnx5enfatccgfo8xwf\">由于间谍结果同步返回，因此 \n<code>getQuote()</code> 方法会在 Angular 调用 \n<code>ngOnInit</code> 的第一个变更检测周期\n<em>之后</em>立即更新屏幕上的消息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6ovo1aijtntvkonmf6hlkbi2\">测试错误路径时，你就不那么幸运了。虽然服务间谍会同步返回错误，但组件方法会调用 \n<code>setTimeout()</code>。测试必须等待 JavaScript 引擎至少完整运行一次，才能获取到该值。测试必须变为\n<em>异步</em>的。</p>\n<a id=\"fake-async\"></a>\n<h4 id=\"async-test-with-fakeasync\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zjqd61kz1sxi6deent1kepmq\"><i class=\"material-icons\">link</i>使用 \n<em>fakeAsync()</em> 进行异步测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"273rfgrzqzbuurnack4vk6bgw\">当该服务返回 <code>ErrorObservable</code> 时，下列测试会对其预期行为进行确认。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"error-test\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  // tell spy to return an error observable\n  getQuoteSpy.and.returnValue(\n    new ErrorObservable('TwainService test failure'));\n\n  fixture.detectChanges(); // onInit()\n  // sync spy errors immediately after init\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the component's setTimeout()\n\n  fixture.detectChanges(); // update errorMessage within setTimeout()\n\n  expect(errorMessage()).toMatch(/test failure/, 'should display error');\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ktfa54hnxo9a4z46i51orowj\">注意，\n<code>it()</code> 函数接收以下形式的参数。</p>\n<code-example language=\"javascript\">\n<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; { /* test body */ })`\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dc30rqsw9vqawnicqjbsqmao4\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 函数通过在特殊的\n<em>fakeAsync 测试区域</em>中运行测试主体，实现了线性编码风格。测试主体看起来是同步的。没有嵌套语法（如 \n<code>Promise.then()</code>）来破坏控制流。</p>\n<a id=\"tick\"></a>\n<h4 id=\"the-tick-function\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6bvalsop15yq7s6xamxh4htjx\"><i class=\"material-icons\">link</i><em>tick()</em> 函数</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e2o0m4ezq6iacj4neot8nwxkr\">你必须调用 \n<code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> 来推进（虚拟）时钟。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7biqc2lxe8wwv0vxiipfnn6ds\">调用 \n<code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> 模拟时间的推移，直到所有挂起的异步活动完成。在本例中，它会等待错误处理程序的 \n<code>setTimeout()</code>；</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d26kfjcgzrfhyj7x2b1c2gep6\"><code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code> 函数是 Angular 测试实用程序之一，你可以使用 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 导入它。它是 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 的配套函数，你只能在 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 主体中调用它。</p>\n<h4 id=\"async-observables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2syrkvav0rjr6ltkb6y9qp8x\"><i class=\"material-icons\">link</i>异步可观察者</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6bp7zynw5cwjcqzvzy13yp4gw\">你可能已经对前面这些测试的测试覆盖率感到满意。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3epyy7a0gvcdtskqy62mhnnq\">但你可能会被这样一个事实困扰，即真实的服务并不完全按照这种方式运行。真实的服务会向远程服务器发送请求。服务器需要时间来响应，并且响应肯定不会像前两个测试那样立即可用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wgc2q8mh9252b8g11d22c7x1\">如果从 \n<code>getQuote()</code> 间谍中返回一个\n<em>异步</em>可观察者，你的测试将更忠实地反映现实世界，就像这样。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-setup\">\n// Simulate delayed observable values with the `asyncData()` helper\ngetQuoteSpy.and.returnValue(asyncData(testQuote));\n\n</code-example>\n<h4 id=\"async-observable-helpers\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"13lyh42xwxbspib1hohkfirxk\"><i class=\"material-icons\">link</i>异步可观察者测试助手</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afyx2zzvajxjov2wtq3cyxttx\">异步可观察者是由 \n<code>asyncData</code> 辅助函数生成的。\n<code>asyncData</code> 辅助函数是一个你必须自己编写的实用程序函数。或者你可以从示例代码中复制这个函数。</p>\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-data\" title=\"testing/async-observable-helpers.ts\">\n/** Create <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> observable that emits-once and completes\n *  after <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> JS engine turn */\nexport function asyncData&lt;T&gt;(data: T) {\n  return defer(() =&gt; Promise.resolve(data));\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8kfbykm9ha0snxl2c6cwzucj2\">这个助手返回的可观察者会在 JavaScript 引擎的下一个周期中发送 <code>data</code> 值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ek2t8rt28nysm54pk7pip7lbc\"><a href=\"http://reactivex.io/documentation/operators/defer.html\">RxJS <code>defer()</code></a> 返回一个可观察者。它接收一个工厂函数，该函数返回一个 Promise 或一个可观察者。当有东西订阅 \n<em>defer</em> 的可观察者时，它会将订阅者添加到使用该工厂创建的新可观察者中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwz9ihtaarc2emepr8mouebit\">RxJS \n<code>defer()</code> 将 \n<code>Promise.resolve()</code> 转换为一个新的可观察者，它像 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 一样，只发射一次并完成。订阅者在收到数据值后将被取消订阅。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"3kkjegr84wd0vb2uq6r9qtfg6\">还有一个类似的用来生成异步错误的测试助手。</p>\n<code-example path=\"testing/src/testing/async-observable-helpers.ts\" region=\"async-error\">\n/** Create <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> observable error that errors\n *  after <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> JS engine turn */\nexport function asyncError&lt;T&gt;(errorObject: any) {\n  return defer(() =&gt; Promise.reject(errorObject));\n}\n\n</code-example>\n<h4 id=\"more-async-tests\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"e3pu8whi5ta5n9eelcvb0sajf\"><i class=\"material-icons\">link</i>更多异步测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tif1hlhh2t8sp7ksmdgzg24i\">现在 \n<code>getQuote()</code> 间谍正在返回异步可观察者，你大多数测试也必须是异步的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51fwp354np8swm3xshv3k63lj\">这是一个 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 测试，它演示了你在现实世界中所期望的数据流。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"fake-async-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>)', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observable to get the quote\n  fixture.detectChanges(); // update view\n\n  expect(quoteEl.textContent).toBe(testQuote, 'should show quote');\n  expect(errorMessage()).toBeNull('should not show error');\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4fy3pycuvzczlf72cayhiphcg\">注意，quote 元素会在 <code>ngOnInit()</code> 之后显示占位符 <code>'...'</code>。因为第一句名言尚未到来。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"634hsd5xg7gajpjn8d9s6gmnb\">要从可观察者中刷新第一个报价，你需要调用 \n<code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code>。然后调用 \n<code>detectChanges()</code> 来告诉 Angular 更新屏幕。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1xutq7f545hf4fff66b9zql41\">然后，你可以断言 quote 元素是否显示了预期的文本。</p>\n<a id=\"async\"></a>\n<h4 id=\"async-test-with-async\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1im3ygys4xcfsstzshmp340e\"><i class=\"material-icons\">link</i>使用 \n<em>async()</em> 进行异步测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4f0xhhj7rmgiv8xdot27sfyco\"><code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 实用程序函数有一些限制。特别是，如果测试主体进行 \n<code>XHR</code> 调用，它将无法工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5879u5eordmdeojnmbblga3xz\">测试中的 \n<code>XHR</code> 调用很少见，因此你通常可以坚持使用 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>。但如果你确实需要调用 \n<code>XHR</code>，你将需要了解 \n<code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zooa536qlp5e0x7pqgxshbco\"><code>TestBed.compileComponents()</code> 方法（见 \n<a href=\"guide/testing#compile-components\">下方</a>）在“即时”编译期间调用 \n<code>XHR</code> 来读取外部模板和 css 文件。使用 \n<code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 实用程序编写调用 \n<code>compileComponents()</code> 的测试。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5pp78x5p7z8vjcqeorioqofk3\">这是之前使用 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 实用程序编写的测试，现在使用 \n<code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 实用程序重写。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"async-test\">\nit('should show quote after getQuote (<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>)', <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  fixture.whenStable().then(() =&gt; { // wait for <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> getQuote\n    fixture.detectChanges();        // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).toBeNull('should not show error');\n  });\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"40xom2cj79t1pc63me7d5dirb\"><code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 实用程序通过安排测试者的代码在特殊的\n<em>异步测试区域</em>中运行，隐藏了一些异步样板代码。你不需要将 Jasmine 的 \n<code>done()</code> 传递给测试，也不需要在 Promise 或可观察者回调中调用 \n<code>done()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bz0yqtuhrt7bkbj5uy0ebe40g\">但测试的异步性质通过对 \n<code>fixture.whenStable()</code> 的调用来揭示，这打破了控制的线性流程。</p>\n<a id=\"when-stable\"></a>\n<h4 id=\"whenstable\"><em>whenStable</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6qr6jotg9s1ewebcm87qt9s7u\">测试必须等待 \n<code>getQuote()</code> 可观察者发射下一个报价。它没有调用 \n<code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code>，而是调用了 \n<code>fixture.whenStable()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvfrnfw0huk9tgpdrhben0fzh\"><code>fixture.whenStable()</code> 返回一个 Promise，当 JavaScript 引擎的任务队列变为空时，该 Promise 会被解决。在本例中，当可观察者发射第一个报价时，任务队列变为空。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8byj1kcup6jtvysta4ocykujm\">测试在 Promise 回调中恢复，该回调调用 \n<code>detectChanges()</code> 来使用预期文本更新报价元素。</p>\n<a id=\"jasmine-done\"></a>\n<h4 id=\"jasmine-done\">Jasmine <em>done()</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epp3aye82qpq9u9jx5ahcwp5u\">虽然 \n<code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a></code> 和 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 函数极大地简化了 Angular 异步测试，但你仍然可以回退到传统技术，并将一个接收\n<a href=\"http://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\"><code>done</code> 回调</a>的函数传递给 \n<code>it</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"blmq3nau4h5odsdrg6t41id2t\">现在，你要自己负责串联各种 Promise、处理错误，并在适当的时机调用 <code>done()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4gt0asfuwty039momchv9fnbk\">使用 \n<code>done()</code> 编写测试函数比 \n<code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a></code> 和 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 更麻烦。但它偶尔是必要的。例如，在测试涉及 \n<code>intervalTimer()</code> 或 RxJS \n<code>delay()</code> 操作符的代码时，你不能调用 \n<code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a></code> 或 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5pz59gbidxlwhxasja48lcp2c\">以下是之前测试的两个移动版本，使用 \n<code>done()</code> 编写。第一个版本订阅了组件 \n<code>quote</code> 属性暴露给模板的 \n<code>Observable</code>。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"quote-done-test\" linenums=\"false\">\nit('should show last quote (quote done)', (done: DoneFn) =&gt; {\n  fixture.detectChanges();\n\n  component.quote.pipe( last() ).subscribe(() =&gt; {\n    fixture.detectChanges(); // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).toBeNull('should not show error');\n    done();\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8z39ox7rbqq9bpqovwvrfayfs\">RxJS \n<code>last()</code> 操作符在完成之前发射可观察者的最后一个值，该值将是测试报价。\n<code>subscribe</code> 回调调用 \n<code>detectChanges()</code> 来使用测试报价更新报价元素，与之前的测试方式相同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aqyph3ffmpxsocou5wggdqqup\">在某些测试中，你更关心注入的服务方法是如何被调用的以及它返回了什么值，而不是屏幕上显示的内容。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayap3gdf0nypco0msmyxxt1bl\">服务间谍，例如伪造 \n<code>TwainService</code> 的 \n<code>qetQuote()</code> 间谍，可以为你提供这些信息，并对视图的状态进行断言。</p>\n<code-example path=\"testing/src/app/twain/twain.component.spec.ts\" region=\"spy-done-test\" linenums=\"false\">\nit('should show quote after getQuote (spy done)', (done: DoneFn) =&gt; {\n  fixture.detectChanges();\n\n  // the spy's most recent call returns the observable with the test quote\n  getQuoteSpy.calls.mostRecent().returnValue.subscribe(() =&gt; {\n    fixture.detectChanges(); // update view with quote\n    expect(quoteEl.textContent).toBe(testQuote);\n    expect(errorMessage()).toBeNull('should not show error');\n    done();\n  });\n});\n\n</code-example>\n<hr>\n<a id=\"marble-testing\"></a>\n<h3 id=\"component-marble-tests\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2flqz2rbktkr322r731gly6ne\"><i class=\"material-icons\">link</i>组件的弹珠测试</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"518pd2k4e0ewf3ydyh2yye441\">之前的 \n<code>TwainComponent</code> 测试使用 \n<code>asyncData</code> 和 \n<code>asyncError</code> 实用程序模拟了来自 \n<code>TwainService</code> 的异步可观察者响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76an26680bmz4zixpokxvv3d3\">这些是你可以自己编写的简短、简单的函数。不幸的是，它们对于许多常见场景来说太简单了。可观察者通常会多次发射，也许是在相当长的延迟之后。组件可能会协调多个可观察者，这些可观察者具有重叠的值和错误序列。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehswj46d1eb1t2im21q6p4rzk\"><strong>RxJS 弹珠测试</strong> 是一种测试可观察者场景的好方法，无论简单还是复杂。你可能已经看到了 \n<a href=\"http://rxmarbles.com/\">弹珠图</a>，它说明了可观察者是如何工作的。弹珠测试使用类似的弹珠语言来指定测试中的可观察者流和期望。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"byeu4szs6nsa1wtmdvyg20k8x\">以下示例使用弹珠测试重新审视了 \n<code>TwainComponent</code> 的两个测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"f02hgkdt38eeoal5awvc0ez2i\">首先安装 npm 包 <code>jasmine-marbles</code>。然后导入你需要的符号。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"import-marbles\" title=\"app/twain/twain.component.marbles.spec.ts (import marbles)\" linenums=\"false\">\nimport { cold, getTestScheduler } from 'jasmine-marbles';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"ahzb4teblmwe85f8qx216j1pt\">获取名言的完整测试方法如下：</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"get-quote-test\" linenums=\"false\">\nit('should show quote after getQuote (marbles)', () =&gt; {\n  // observable test quote value and complete(), after delay\n  const q$ = cold('---x|', { x: testQuote });\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  getTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n\n  fixture.detectChanges(); // update view\n\n  expect(quoteEl.textContent).toBe(testQuote, 'should show quote');\n  expect(errorMessage()).toBeNull('should not show error');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bksb3af5ysbc8m8a09w737wr9\">注意，Jasmine 测试是同步的。没有 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code>。弹珠测试使用测试调度器在同步测试中模拟时间的推移。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ay3td0o59jgloshv7283lrobh\">弹珠测试的妙处在于可观察者流的视觉定义。此测试定义了一个 \n<a href=\"guide/testing#cold-observable\"><em>冷</em>可观察者</a>，它等待 三个 \n<a href=\"guide/testing#marble-frame\">帧</a>（\n<code>---</code>）， 发射一个值（\n<code>x</code>），并完成（\n<code>|</code>）。在第二个参数中，你将值标记（\n<code>x</code>）映射到发射的值（\n<code>testQuote</code>）。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-quote-marbles\" linenums=\"false\">\nconst q$ = cold('---x|', { x: testQuote });\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"y2rm9adgng7tqoo8ud4be16\">弹珠库构建了相应可观察者，测试将其设置为 \n<code>getQuote</code> 间谍的返回值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"19b03r1j58a5n4dygg3d9y8p0\">当你准备好激活弹珠可观察者时，你告诉 \n<code>TestScheduler</code> \n<em>刷新</em>其准备好的任务队列，就像这样。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"test-scheduler-flush\" linenums=\"false\">\ngetTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3b00e0uo8152s2y988vl1aoep\">此步骤的作用类似于之前 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 和 \n<code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 示例中的 \n<code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code> 和 \n<code>whenStable()</code>。测试的其余部分与这些示例相同。</p>\n<h4 id=\"marble-error-testing\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7n6xe9d8jwwgicoxiy7xqu6fi\"><i class=\"material-icons\">link</i>弹珠错误测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"72isgvfkcedhgs20qqvuuysln\">下面是 <code>getQuote()</code> 错误测试的弹珠测试版。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-test\" linenums=\"false\">\nit('should display error when TwainService fails', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  // observable error after delay\n  const q$ = cold('---#|', null, new Error('TwainService test failure'));\n  getQuoteSpy.and.returnValue( q$ );\n\n  fixture.detectChanges(); // ngOnInit()\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n\n  getTestScheduler().flush(); // <a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a> the observables\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>();                     // component shows error after <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> setTimeout()\n  fixture.detectChanges();    // update error message\n\n  expect(errorMessage()).toMatch(/test failure/, 'should display error');\n  expect(quoteEl.textContent).toBe('...', 'should show placeholder');\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"769tfdpu90r0938lvvj2imh17\">它仍然是一个异步测试，调用 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>()</code> 和 \n<code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>()</code>，因为组件本身在处理错误时会调用 \n<code>setTimeout()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"m5udc7cf180y73roer1vkcy3\">看看这个弹珠的可观察定义。</p>\n<code-example path=\"testing/src/app/twain/twain.component.marbles.spec.ts\" region=\"error-marbles\" linenums=\"false\">\nconst q$ = cold('---#|', null, new Error('TwainService test failure'));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"503t14kght74017qglxkegx91\">这是一个\n<em>冷</em>可观察者，它等待三个帧，然后发射一个错误。哈希（\n<code>#</code>）表示第三个参数中指定的错误时间。第二个参数为 null，因为可观察者从未发射过值。</p>\n<h4 id=\"learn-about-marble-testing\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2a2c7dfw6lfhfjd7o4n5zwdw7\"><i class=\"material-icons\">link</i>了解弹珠测试</h4>\n<a id=\"marble-frame\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1hlvvnvmqzp3f7z0pqefdgodj\"><em>弹珠帧</em>是测试时间线上的虚拟单位。每个符号（<code>-</code>，<code>x</code>，<code>|</code>，<code>#</code>）都表示经过了一帧。</p>\n<a id=\"cold-observable\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"btwwj5dap0fxnszjldfvr1is3\"><em>冷</em>可观察者在你订阅它之前不会产生值。你的大多数应用中可观察者都是冷的。所有的 <a href=\"guide/http\"><em>HttpClient</em></a> 方法返回的都是冷可观察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80psovwsp0zbnc4gw1s6eqppk\">一个\n<em>热</em>可观察者在你订阅它\n<em>之前</em>就已经在生成值了。\n<code><a href=\"api/router/Router#events\"><em>Router.events</em></a></code> 可观察者，它报告路由器活动，是一个\n<em>热</em>可观察者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"di4twukielgkyxgwrsswt8j7q\">RxJS 弹珠测试是一个丰富的主题，超出了本指南的范围。在网上学习它，从 \n<a href=\"https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md\">官方文档</a> 开始。</p>\n<hr>\n<a id=\"component-with-input-output\"></a>\n<h3 id=\"component-with-inputs-and-outputs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6akltf74dkxr2nmj7g3zripof\"><i class=\"material-icons\">link</i>具有输入和输出的组件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3w2ouqa8oolij3nc3lh723y0o\">具有输入和输出的组件通常出现在宿主组件的视图模板中。宿主使用属性绑定来设置输入属性，并使用事件绑定来监听输出属性引发的事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1hx0jgd2ywi97x99pqc5lpysx\">本测试的目标是验证这些绑定是否如预期般工作。这些测试应该设置输入值并监听输出事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"acfwvlxhw8304giw7perl0adx\"><code>DashboardHeroComponent</code> 是这类组件的一个小例子。它会显示由 <code>DashboardComponent</code> 提供的一个英雄。点击这个英雄就会告诉 <code>DashboardComponent</code>，用户已经选择了此英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"a31limhqwwj3hsibg7nkghqb7\"><code>DashboardHeroComponent</code> 会像这样内嵌在 <code>DashboardComponent</code> 模板中的：</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.html\" region=\"dashboard-hero\" title=\"app/dashboard/dashboard.component.html (excerpt)\" linenums=\"false\">\n&lt;dashboard-hero *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"  class=\"col-1-4\"\n  [hero]=hero  (selected)=\"gotoDetail($event)\" &gt;\n&lt;/dashboard-hero&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5l4onkqhj6bcu0yd2lvv1jm3t\"><code>DashboardHeroComponent</code> 出现在 \n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 重复器中，该重复器将每个组件的 \n<code>hero</code> 输入属性设置为循环值，并监听组件的 \n<code>selected</code> 事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8iuphrpgspoxeic7iudpmq98e\">这里是组件的完整定义：</p>\n<a id=\"dashboard-hero-component\"></a>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.ts\" region=\"component\" title=\"app/dashboard/dashboard-hero.component.ts (component)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'dashboard-hero',\n  template: `\n    &lt;div (click)=\"click()\" class=\"hero\"&gt;\n      {{hero.name | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}}\n    &lt;/div&gt;`,\n  styleUrls: [ './dashboard-hero.component.css' ]\n})\nexport class DashboardHeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() selected = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n  click() { this.selected.emit(this.hero); }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7a9rtq1tbofhwcu3olyibn2x\">虽然测试这样一个简单的组件本身价值不大，但了解如何测试它还是很有意义的。你可以使用以下方法之一：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58a5berb7y04lg5z512h93bp6\">以 \n<code>DashboardComponent</code> 使用的方式测试它。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1r4ulsmz2li46mh5gmry4gl5h\">以独立组件的方式测试它。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xhcqw5zt422s7fzx0n1msk21\">以 \n<code>DashboardComponent</code> 的替代品使用的方式测试它。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2daf0y5s8yvr6zeeaxlxwa0p1\">快速看一眼 <code>DashboardComponent</code> 构造函数就知道不建议采用第一种方法：</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" title=\"app/dashboard/dashboard.component.ts (constructor)\" linenums=\"false\">\nconstructor(\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private heroService: HeroService) {\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"51q1biw4uj1cpmtsnva1hu85o\"><code>DashboardComponent</code> 依赖于 Angular 的路由器和 <code>HeroService</code>。你可能不得不用测试替身来代替它们，这有很多工作。路由器看上去特别有挑战性。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"y4qwfzkltwiqt9jetd41a02g\">下面的 \n<a href=\"guide/testing#routing-component\">讨论</a> 涵盖了测试需要路由器的组件。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqt34bl12wnh6920ldsh2ix20\">当前目标是测试 \n<code>DashboardHeroComponent</code>，而不是 \n<code>DashboardComponent</code>，所以，尝试第二和第三种方法。</p>\n<a id=\"dashboard-standalone\"></a>\n<h4 id=\"test-dashboardherocomponent-stand-alone\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4f1dyfakvdyqc9sl77pfcf84b\"><i class=\"material-icons\">link</i>独立测试 \n<em>DashboardHeroComponent</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"d9ucpbe0i5au54cvoq2ujv1f0\">这里是 spec 文件中环境设置部分的内容。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"setup\" title=\"app/dashboard/dashboard-hero.component.spec.ts (setup)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [ DashboardHeroComponent ]\n})\nfixture = TestBed.createComponent(DashboardHeroComponent);\ncomp    = fixture.componentInstance;\n\n// find the hero's <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> and element\nheroDe  = fixture.debugElement.query(By.css('.hero'));\nheroEl = heroDe.nativeElement;\n\n// mock the hero supplied by the parent component\nexpectedHero = { id: 42, name: 'Test Name' };\n\n// simulate the parent setting the input property with that hero\ncomp.hero = expectedHero;\n\n// <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\nfixture.detectChanges();\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wnq5s90abypu1ehnkfnesea2\">注意，设置代码如何将测试英雄（\n<code>expectedHero</code>）分配给组件的 \n<code>hero</code> 属性，模拟 \n<code>DashboardComponent</code> 通过其重复器中的属性绑定设置它的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"581umaqbliirwsee22znlt091\">以下测试验证英雄名称是否通过绑定传播到模板。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"name-test\">\nit('should display hero name in uppercase', () =&gt; {\n  const expectedPipedName = expectedHero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71nxhbxl38gg14samy2d4tx2k\">因为 \n<a href=\"guide/testing#dashboard-hero-component\">模板</a> 通过 Angular \n<code><a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a></code> 传递英雄名称，所以测试必须将元素值与大写名称匹配。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wycyk2kanhqv0tiqk3s667z5\">这个小测试演示了 Angular 测试如何验证组件的视觉表示——这是 \n<a href=\"guide/testing#component-class-testing\">组件类测试</a> 做不到的——而且成本低廉，无需诉诸更慢、更复杂的端到端测试。</p>\n</div>\n<h4 id=\"clicking\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"3xzyzhgy3ao0qjsswmxwjfnz0\"><i class=\"material-icons\">link</i>点击</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zjh0j5fel3tjlt9qbrrbgp2v\">点击英雄应该会触发一个 \n<code>selected</code> 事件，宿主组件（可能是 \n<code>DashboardComponent</code>）可以听到这个事件：</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test\">\nit('should raise selected event when clicked (triggerEventHandler)', () =&gt; {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  heroDe.triggerEventHandler('click', null);\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4hmamm13hv863yjfkd84lswuo\">组件的 \n<code>selected</code> 属性返回一个 \n<code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>，对于使用者来说，它看起来像一个 RxJS 同步 \n<code>Observable</code>。测试显式地订阅它，就像宿主组件隐式地订阅它一样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dck8jjihu3ry6viqt992jj1ty\">如果组件按预期工作，点击英雄的元素应该告诉组件的 \n<code>selected</code> 属性发出 \n<code>hero</code> 对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"a6mrm2xwtjftqy75bkk26dfmt\">该测试通过对 <code>selected</code> 的订阅来检测该事件。</p>\n<a id=\"trigger-event-handler\"></a>\n<h4 id=\"triggereventhandler\"><em>triggerEventHandler</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2txv3kkkokn0vbe7jd0kaphnn\">之前测试中的 \n<code>heroDe</code> 是一个 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>，它代表英雄 \n<code>&lt;div&gt;</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dhr74g9pzokzkyddaunuflmpg\">它具有 Angular 属性和方法，这些属性和方法抽象了与原生元素的交互。此测试使用 \"click\" 事件名称调用 \n<code>DebugElement.triggerEventHandler</code>。 \"click\" 事件绑定通过调用 \n<code>DashboardHeroComponent.click()</code> 来响应。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlppoouihcpcbszrlyioskd6d\">Angular \n<code>DebugElement.triggerEventHandler</code> 可以通过其 \n<em>事件名称</em> 触发 \n<em>任何数据绑定事件</em>。第二个参数是传递给处理程序的事件对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cssdlr21xfq2drpfcrc4i8f4y\">测试使用 \n<code>null</code> 事件对象触发了 \"click\" 事件。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"trigger-event-handler\">\nheroDe.triggerEventHandler('click', null);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0rk1hhlsmzv1956gwypee1or\">测试假设（在这种情况下是正确的）运行时事件处理程序——组件的 \n<code>click()</code> 方法——不关心事件对象。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37c2rim44a30rq4v807hsfef1\">其他处理程序则没有那么宽容。例如，\n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令期望一个包含 \n<code>button</code> 属性的对象，该属性标识在点击期间按下哪个鼠标按钮（如果有）。如果事件对象丢失，\n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令会抛出错误。</p>\n</div>\n<h4 id=\"click-the-element\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7y6e4w4w8rkf5d29p98b3gn0r\"><i class=\"material-icons\">link</i>点击元素</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1u5e5grvxqogxmpnh4xbi9xmm\">以下测试替代方案调用原生元素自己的 \n<code>click()</code> 方法，这对 \n<em>此组件</em> 来说是完全可以的。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-2\">\nit('should raise selected event when clicked (element.click)', () =&gt; {\n  let selectedHero: Hero;\n  comp.selected.subscribe((hero: Hero) =&gt; selectedHero = hero);\n\n  heroEl.click();\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<a id=\"click-helper\"></a>\n<h4 id=\"click-helper\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38o26dc9t4yj68a5eey4m4axs\"><i class=\"material-icons\">link</i><em>click()</em> 辅助函数</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4aqbfipdljftyc329w5k5y05b\">点击按钮、链接或者任意 HTML 元素是很常见的测试任务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"l760egfclu0eqk1f50l1hhvw\">通过将 \n<em>点击触发</em> 过程封装在像下面的 \n<code>click()</code> 函数这样的辅助函数中，使之保持一致且易于使用：</p>\n<code-example path=\"testing/src/testing/index.ts\" region=\"click-event\" title=\"testing/index.ts (click helper)\" linenums=\"false\">\n/** Button events to pass to `DebugElement.triggerEventHandler` for <a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a> event handler */\nexport const ButtonClickEvents = {\n   left:  { button: 0 },\n   right: { button: 2 }\n};\n\n/** Simulate element click. Defaults to mouse left-button click event. */\nexport function click(el: <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> | HTMLElement, eventObj: any = ButtonClickEvents.left): void {\n  if (el instanceof HTMLElement) {\n    el.click();\n  } else {\n    el.triggerEventHandler('click', eventObj);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"t1s0tbic1gsf7s0w7o5o53qh\">第一个参数是 \n<em>要点击的元素</em>。如果你愿意，可以将自定义事件对象作为第二个参数传递。默认情况下，它是一个（部分）\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\">左键鼠标事件对象</a>，许多处理程序（包括 \n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令）都接受它。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26eis6yj7ij5dxvven5bk2zm6\"><code>click()</code> 辅助函数 \n<strong>不是</strong> Angular 测试实用程序之一。它是 \n<em>本指南示例代码</em> 中定义的函数。所有示例测试都使用它。如果你喜欢它，可以将其添加到你自己的辅助函数集合中。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dj3pfjwvn51x7so63un6fl749\">以下是使用点击辅助函数重写的先前测试。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"click-test-3\" title=\"app/dashboard/dashboard-hero.component.spec.ts (test with click helper)\">\nit('should raise selected event when clicked (click helper)', () =&gt; {\n  let selectedHero: Hero;\n  comp.selected.subscribe(hero =&gt; selectedHero = hero);\n\n  click(heroDe); // click helper with <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>\n  click(heroEl); // click helper with native element\n\n  expect(selectedHero).toBe(expectedHero);\n});\n\n</code-example>\n<hr>\n<a id=\"component-inside-test-host\"></a>\n<h3 id=\"component-inside-a-test-host\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d5o8ljbojifmr4s6e99zljc9e\"><i class=\"material-icons\">link</i>测试宿主内的组件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"cv7i0kkpmseyl6t7x3qnhpz22\">前面的这些测试都是自己扮演宿主元素 <code>DashboardComponent</code> 的角色。但是当 <code>DashboardHeroComponent</code> 真的绑定到某个宿主元素时还能正常工作吗？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"399j908nwsrp5w0ifz502hra4\">你可以使用实际的 \n<code>DashboardComponent</code> 进行测试。但这样做可能需要大量的设置，尤其是在其模板包含 \n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 重复器、其他组件、布局 HTML、额外的绑定、一个注入多个服务的构造函数，并且它会立即开始与这些服务交互时。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxw9zydikcyzrifylmdchm6f\">想象一下，为了证明一个可以用 \n<em>测试宿主</em> 令人满意地证明的观点，需要付出多少努力来禁用这些干扰，就像这个测试宿主一样：</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host\" title=\"app/dashboard/dashboard-hero.component.spec.ts (test host)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  template: `\n    &lt;dashboard-hero\n      [hero]=\"hero\" (selected)=\"onSelected($event)\"&gt;\n    &lt;/dashboard-hero&gt;`\n})\nclass TestHostComponent {\n  hero: Hero = {id: 42, name: 'Test Name' };\n  selectedHero: Hero;\n  onSelected(hero: Hero) { this.selectedHero = hero; }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bei43ri2b3m2dsk16qerhm0wj\">此测试宿主将 \n<code>DashboardHeroComponent</code> 绑定为 \n<code>DashboardComponent</code> 所做的那样，但没有 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>、\n<code>HeroService</code> 或 \n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 重复器的噪音。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1efrwljtty91vw9v1s0hism8a\">测试宿主使用其测试英雄设置组件的 \n<code>hero</code> 输入属性。它将组件的 \n<code>selected</code> 事件绑定到其 \n<code>onSelected</code> 处理程序，该处理程序在其 \n<code>selectedHero</code> 属性中记录发出的英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjnty4cn2c9h1w77o5elrniiz\">稍后，测试将能够轻松地检查 \n<code>selectedHero</code> 以验证 \n<code>DashboardHeroComponent.selected</code> 事件是否发出了预期的英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d19qllu7tmsbrnd1ryfuaeuft\"><em>测试宿主</em> 测试的设置类似于独立测试的设置：</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-setup\" title=\"app/dashboard/dashboard-hero.component.spec.ts (test host setup)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [ DashboardHeroComponent, TestHostComponent ]\n})\n// create TestHostComponent instead of DashboardHeroComponent\nfixture  = TestBed.createComponent(TestHostComponent);\ntestHost = fixture.componentInstance;\nheroEl   = fixture.nativeElement.querySelector('.hero');\nfixture.detectChanges(); // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2jfbtwpmyvq9rt3ckck3jt0mr\">这个测试模块的配置信息有三个重要的不同点：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dludqnubauzt1nb1rrala3yjn\">它 \n<em>声明</em> 了 \n<code>DashboardHeroComponent</code> 和 \n<code>TestHostComponent</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bijdfy9yow6xt3jc04cp31jpb\">它 \n<em>创建</em> 了 \n<code>TestHostComponent</code> 而不是 \n<code>DashboardHeroComponent</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8iqw5ut4449i54d6h3h14h7bz\"><code>TestHostComponent</code> 使用绑定设置 \n<code>DashboardHeroComponent.hero</code>。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0nhj58wmzffeiwx5fl9e9yek\"><code>createComponent</code> 返回一个 \n<code>fixture</code>，它包含 \n<code>TestHostComponent</code> 的实例，而不是 \n<code>DashboardHeroComponent</code> 的实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3le8oi2brtnuptqsnpg51vc3x\">创建 \n<code>TestHostComponent</code> 会产生创建 \n<code>DashboardHeroComponent</code> 的副作用，因为后者出现在前者的模板中。对英雄元素（\n<code>heroEl</code>）的查询仍然可以在测试 DOM 中找到它，尽管它在元素树中的深度比以前更大。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7zxbrdygjmsirjboyh9sh9103\">这些测试本身和它们的孤立版本几乎相同：</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"test-host-tests\" title=\"app/dashboard/dashboard-hero.component.spec.ts (test-host)\" linenums=\"false\">\nit('should display hero name', () =&gt; {\n  const expectedPipedName = testHost.hero.name.toUpperCase();\n  expect(heroEl.textContent).toContain(expectedPipedName);\n});\n\nit('should raise selected event when clicked', () =&gt; {\n  click(heroEl);\n  // selected hero should be the same data bound hero\n  expect(testHost.selectedHero).toBe(testHost.hero);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ghhow3ttug9zrmwew4w5icyf\">只有选定事件测试有所不同。它确认选定的 \n<code>DashboardHeroComponent</code> 英雄确实通过事件绑定传到了宿主组件。</p>\n<hr>\n<a id=\"routing-component\"></a>\n<h3 id=\"routing-component\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"9u7mq4pbjyv40jwu8gjh18zum\"><i class=\"material-icons\">link</i>路由组件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"86pzltzl8vxn0by7wybpb2hx6\"><em>路由组件</em> 是一个告诉 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 导航到另一个组件的组件。\n<code>DashboardComponent</code> 是一个 \n<em>路由组件</em>，因为用户可以通过点击仪表板上的 \n<em>英雄按钮</em> 导航到 \n<code>HeroDetailComponent</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d60xzq7s8w0pb5fxr1003anll\">路由相当复杂。测试 \n<code>DashboardComponent</code> 看起来很令人生畏，部分原因是它涉及 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>，它与 \n<code>HeroService</code> 一起注入。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"ctor\" title=\"app/dashboard/dashboard.component.ts (constructor)\" linenums=\"false\">\nconstructor(\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,\n  private heroService: HeroService) {\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kmt003xnld95ey99u3iwu8g1\">使用间谍模拟 \n<code>HeroService</code> 是一个 \n<a href=\"guide/testing#component-with-async-service\">熟悉的故事</a>。但 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 具有复杂的 API，并且与其他服务和应用程序先决条件交织在一起。模拟它是否很困难？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dkf3364dnfd2dek7nc3piabjf\">幸运的是，在这种情况下并非如此，因为 \n<code>DashboardComponent</code> 对 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 没有做太多事情。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.ts\" region=\"goto-detail\" title=\"app/dashboard/dashboard.component.ts (goToDetail)\">\ngotoDetail(hero: Hero) {\n  let url = `/heroes/${hero.id}`;\n  this.router.navigateByUrl(url);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4b9puwl9bl4fy6bzlmblfj6am\">这在 \n<em>路由组件</em> 中很常见。通常情况下，你测试组件，而不是路由器，并且只关心组件在给定条件下是否使用正确的地址进行导航。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"clak2c2qq7lkxq0uythkrkorv\">为 \n<em>此组件</em> 测试套件提供路由器间谍与提供 \n<code>HeroService</code> 间谍一样容易。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"router-spy\" title=\"app/dashboard/dashboard.component.spec.ts (spies)\" linenums=\"false\">\nconst routerSpy = jasmine.createSpyObj('<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>', ['navigateByUrl']);\nconst heroServiceSpy = jasmine.createSpyObj('HeroService', ['getHeroes']);\n\nTestBed.configureTestingModule({\n  providers: [\n    { provide: HeroService, useValue: heroServiceSpy },\n    { provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,      useValue: routerSpy }\n  ]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6wben7nphvwcw4du7moa5ztqa\">以下测试点击显示的英雄，并确认 \n<code>Router.navigateByUrl</code> 使用预期的 URL 被调用。</p>\n<code-example path=\"testing/src/app/dashboard/dashboard.component.spec.ts\" region=\"navigate-test\" title=\"app/dashboard/dashboard.component.spec.ts (navigate test)\" linenums=\"false\">\nit('should tell ROUTER to navigate when hero clicked', () =&gt; {\n\n  heroClick(); // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> click on first inner &lt;div class=\"hero\"&gt;\n\n  // args passed to router.navigateByUrl() spy\n  const spy = router.navigateByUrl as jasmine.Spy;\n  const navArgs = spy.calls.first().args[0];\n\n  // expecting to navigate to id of the component's first hero\n  const id = comp.heroes[0].id;\n  expect(navArgs).toBe('/heroes/' + id,\n    'should nav to HeroDetail for first hero');\n});\n\n</code-example>\n<a id=\"routed-component-w-param\"></a>\n<h3 id=\"routed-components\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"ca0qb793u28asb2pr12abrcat\"><i class=\"material-icons\">link</i>路由目标组件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cgyfr4ypowtxuc3qbbozwknd\"><em>路由组件</em> 是 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 导航的目的地。测试它可能更棘手，尤其是在路由到组件 \n<em>包含参数</em> 时。\n<code>HeroDetailComponent</code> 是一个 \n<em>路由组件</em>，它是这种路由的目的地。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"513vn7sqi4cnzi3026jhq8n08\">当用户点击某个 \n<em>Dashboard</em> 英雄时，\n<code>DashboardComponent</code> 会告诉 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 导航到 \n<code>heroes/:id</code>。 \n<code>:id</code> 是一个路由参数，其值为要编辑的英雄的 \n<code>id</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"894vagvrmvymg0f9cuc5bdcn7\"><code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 会将此 URL 与指向 \n<code>HeroDetailComponent</code> 的路由匹配。 它会创建一个包含路由信息的 \n<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 对象，并将其注入到 \n<code>HeroDetailComponent</code> 的新实例中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"b9lk3m1abbsp03d1o8dnz0gab\">下面是 <code>HeroDetailComponent</code> 的构造函数：</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ctor\" title=\"app/hero/hero-detail.component.ts (constructor)\" linenums=\"false\">\nconstructor(\n  private heroDetailService: HeroDetailService,\n  private route:  <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n  private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4nr25heun30q7x1jjdw70e6ep\"><code>HeroDetail</code> 组件需要 \n<code>id</code> 参数，以便它可以通过 \n<code>HeroDetailService</code> 获取相应的英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0fem0oz7mipnduubp7l7b0ll\">该组件必须从 \n<code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 属性中获取 \n<code>id</code>， 该属性是一个 \n<em>Observable</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7pr7rarjg8y3ziy5ku2p7tke3\">它不能直接引用 \n<code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 的 \n<code>id</code> 属性。 该组件必须 \n<em>订阅</em> \n<code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 可观察者，并为其生命周期内 \n<code>id</code> 的变化做好准备。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"ng-on-init\" title=\"app/hero/hero-detail.component.ts (ngOnInit)\" linenums=\"false\">\nngOnInit(): void {\n  // get hero when `id` param changes\n  this.route.paramMap.subscribe(pmap =&gt; this.getHero(pmap.get('id')));\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55zkk2fky0gagup9gqa7q6owd\">路由指南涵盖了 \n<code><a href=\"api/router/ActivatedRoute#paramMap\" class=\"code-anchor\">ActivatedRoute.paramMap</a></code> 的更多细节。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3pijiwh7rfp677m7i4b9hodx8\">测试可以探索 \n<code>HeroDetailComponent</code> 如何响应不同的 \n<code>id</code> 参数值， 方法是操纵注入到组件构造函数中的 \n<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8fvnq30b4n484bv2sh89dr95e\">你知道如何监视 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 和数据服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cqswbsbt85v957fs7gggl8aa\">你会对 \n<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 采取不同的方法，因为</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"atm3d83f52vbxfwrpqjsg4rko\"><code>paramMap</code> 返回一个 \n<code>Observable</code>，它可以在测试期间发出多个值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3veq9ynex4212n945fespz3pa\">你需要路由辅助函数 \n<code><a href=\"api/router/convertToParamMap\" class=\"code-anchor\">convertToParamMap</a>()</code> 来创建一个 \n<code><a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a></code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yafq1wybfrcyxk9hixof1mxw\">其他 \n<em>路由组件</em> 测试需要一个 \n<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 的测试替身。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3dt0qpdsby2iwvjiw8qm56u9y\">这些差异表明需要一个可复用的存根类。</p>\n<h4 id=\"activatedroutestub\"><em>ActivatedRouteStub</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tj5s9prjcfwue8u41uavwf64\">以下 \n<code>ActivatedRouteStub</code> 类用作 \n<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> 的测试替身。</p>\n<code-example path=\"testing/src/testing/activated-route-stub.ts\" region=\"activated-route-stub\" title=\"testing/activated-route-stub.ts (ActivatedRouteStub)\" linenums=\"false\">\nimport { ReplaySubject } from 'rxjs/ReplaySubject';\nimport { <a href=\"api/router/convertToParamMap\" class=\"code-anchor\">convertToParamMap</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>, <a href=\"api/router/Params\" class=\"code-anchor\">Params</a> } from '@angular/router';\n\n/**\n * An ActivateRoute test double with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> `paramMap` observable.\n * Use the `setParamMap()` method to add the next `paramMap` value.\n */\nexport class ActivatedRouteStub {\n  // Use <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> ReplaySubject to share previous values with subscribers\n  // and pump new values into the `paramMap` observable\n  private subject = new ReplaySubject&lt;<a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>&gt;();\n\n  constructor(initialParams?: <a href=\"api/router/Params\" class=\"code-anchor\">Params</a>) {\n    this.setParamMap(initialParams);\n  }\n\n  /** The mock paramMap observable */\n  readonly paramMap = this.subject.asObservable();\n\n  /** Set the paramMap observables's next value */\n  setParamMap(params?: <a href=\"api/router/Params\" class=\"code-anchor\">Params</a>) {\n    this.subject.next(<a href=\"api/router/convertToParamMap\" class=\"code-anchor\">convertToParamMap</a>(params));\n  };\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4136er1it2tckdspok6n9480z\">可以将此类辅助程序放在 \n<code>app</code> 文件夹的同级 \n<code>testing</code> 文件夹中。 此示例将 \n<code>ActivatedRouteStub</code> 放在 \n<code>testing/activated-route-stub.ts</code> 中。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35rf73yc8bj4am3zqdta4mlnt\">可以考虑使用 \n<a href=\"guide/testing#marble-testing\"><em>弹珠测试库</em></a> 编写此存根类的更强大版本。</p>\n</div>\n<a id=\"tests-w-test-double\"></a>\n<h4 id=\"testing-with-activatedroutestub\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dd784vdx5el9o8ymjgeyaul4q\"><i class=\"material-icons\">link</i>使用 \n<em>ActivatedRouteStub</em> 进行测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2374t2d9s5zfixbfdxu1lrspv\">下面的测试程序是演示组件在被观察的 <code>id</code> 指向现有英雄时的行为：</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-good-id\" title=\"app/hero/hero-detail.component.spec.ts (existing id)\" linenums=\"false\">\ndescribe('when navigate to existing hero', () =&gt; {\n  let expectedHero: Hero;\n\n  beforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n    expectedHero = firstHero;\n    activatedRoute.setParamMap({ id: expectedHero.id });\n    createComponent();\n  }));\n\n  it('should display that hero\\'s name', () =&gt; {\n    expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n  });\n});\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3nftw38v8lwsyki9g5q2bvy57\"><code>createComponent()</code> 方法和 \n<code>page</code> 对象将在 \n<a href=\"guide/testing#page-object\">下面</a> 讨论。 现在先凭直觉理解。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"35s151lkbccxpzrhi65adxj2u\">当找不到 <code>id</code> 的时候，组件应该重新路由到 <code>HeroListComponent</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3yj9llc09n3dgrp73yuhvamg6\">测试套件设置提供了与 \n<a href=\"guide/testing#routing-component\">上面描述的</a> 相同的路由间谍，它监视路由器，但不会实际导航。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"ctw509cw2ylaocv2gryy70nh1\">这个测试中会期待该组件尝试导航到 <code>HeroListComponent</code>。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-bad-id\" title=\"app/hero/hero-detail.component.spec.ts (bad id)\" linenums=\"false\">\ndescribe('when navigate to non-existent hero id', () =&gt; {\n  beforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n    activatedRoute.setParamMap({ id: 99999 });\n    createComponent();\n  }));\n\n  it('should try to navigate back to hero list', () =&gt; {\n    expect(page.gotoListSpy.calls.any()).toBe(true, 'comp.gotoList called');\n    expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n  });\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eldhm1mtxmvy9iou0jwcjd8ho\">虽然此应用没有指向 \n<code>HeroDetailComponent</code> 的路由，该路由省略了 \n<code>id</code> 参数，但它可能在将来添加此类路由。 当没有 \n<code>id</code> 时，该组件应该执行一些合理的操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"etgmlh8nbky7enjs8kpxkkoje\">在此实现中，该组件应该创建并显示一个新的英雄。 新英雄的 \n<code>id=0</code>，并且 \n<code>name</code> 为空。此测试确认该组件按预期工作：</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"route-no-id\" title=\"app/hero/hero-detail.component.spec.ts (no id)\" linenums=\"false\">\ndescribe('when navigate with no hero id', () =&gt; {\n  beforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>( createComponent ));\n\n  it('should have hero.id === 0', () =&gt; {\n    expect(component.hero.id).toBe(0);\n  });\n\n  it('should display empty hero name', () =&gt; {\n    expect(page.nameDisplay.textContent).toBe('');\n  });\n});\n\n</code-example>\n<hr>\n<h3 id=\"nested-component-tests\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"b867kv4bibqcsucw7n6kky6hj\"><i class=\"material-icons\">link</i>对嵌套组件的测试</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xmwpgrnnqaxisa7bsnnzthwc\">组件模板通常包含嵌套组件，其模板可能包含更多组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bus69oabfxjtk6nlgmn4eqme0\">组件树可能非常深，而且大多数情况下，嵌套组件 在测试树顶部的组件时不起作用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcejotvqjvx3sjgcl5hnizzkn\">例如，\n<code>AppComponent</code> 显示一个带有锚点及其 \n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令的导航栏。</p>\n<code-example path=\"testing/src/app/app.component.html\" title=\"app/app.component.html\" linenums=\"false\">\n&lt;app-banner&gt;&lt;/app-banner&gt;\n&lt;app-welcome&gt;&lt;/app-welcome&gt;\n&lt;nav&gt;\n  &lt;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\"&gt;Dashboard&lt;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>&gt;\n  &lt;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\"&gt;Heroes&lt;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>&gt;\n  &lt;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\"&gt;About&lt;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>&gt;\n&lt;/nav&gt;\n&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;&lt;/<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afa2dy9ppdtsm3zin03cco0ew\">虽然 \n<code>AppComponent</code> \n<em>类</em>为空， 但你可能希望编写单元测试以确认链接是否正确连接到 \n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 指令，也许是为了 \n<a href=\"guide/testing#why-stubbed-routerlink-tests\">下面解释的</a> 原因。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dj0vb2miv9n2v3w1kfuve0p7\">为了验证链接，你不需要 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 进行导航，也不需要 \n<code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 来标记 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 插入 \n<em>路由组件</em> 的位置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7gir9bkjjzrc6zioet07a12lh\"><code>BannerComponent</code> 和 \n<code>WelcomeComponent</code> （由 \n<code>&lt;app-banner&gt;</code> 和 \n<code>&lt;app-welcome&gt;</code> 指示）也无关紧要。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wdkkxvkhng8jiggmaerionq9\">但是，任何在 DOM 中创建 \n<code>AppComponent</code> 的测试也会创建这三个组件的实例，如果你允许这种情况发生， 则必须配置 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 来创建它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"883d6bnfhgh1ufg47w6zi2s3r\">如果你忽略了声明它们，Angular 编译器将无法识别 \n<code>AppComponent</code> 模板中的 \n<code>&lt;app-banner&gt;</code>、\n<code>&lt;app-welcome&gt;</code> 和 \n<code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 标签， 并会抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"m1r5tylrjyvkxlp2f9md4evj\">如果你声明了真实组件，则还必须声明 \n<em>它们的</em> 嵌套组件， 并为树中 \n<em>任何</em> 组件中注入的 \n<em>所有</em> 服务提供支持。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"59aebrdhcs5i9hayt01xly9jq\">如果只是想回答关于链接的一些简单问题，做这些显然就太多了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9n2nd0eqkh5qioaxzzfx9wfh7\">本节介绍两种最小化设置的技术。 单独使用或组合使用它们，以专注于测试主要组件。</p>\n<a id=\"stub-component\"></a>\n<h5 id=\"stubbing-unneeded-components\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xf0j58xy8pd7945d3owxi2ei\"><i class=\"material-icons\">link</i>存根不需要的组件</h5>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d8tx0swor33uskyfhvcp8e15v\">在第一种技术中，你创建并声明组件的存根版本 以及在测试中几乎不起作用的指令。</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"component-stubs\" title=\"app/app.component.spec.ts (stub declaration)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: 'app-banner', template: ''})\nclass BannerStubComponent {}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: '<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>', template: ''})\nclass RouterOutletStubComponent { }\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({selector: 'app-welcome', template: ''})\nclass WelcomeStubComponent {}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"zz9fqdgy67aho07tc4wekkda\">这些测试桩的选择器要和其对应的真实组件一致，但其模板和类是空的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bocwpyt7a8psw2fq6j5tje9z1\">然后在 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置中，将它们声明在 需要真实的组件、指令和管道旁边。</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"testbed-stubs\" title=\"app/app.component.spec.ts (TestBed stubs)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [\n    AppComponent,\n    RouterLinkDirectiveStub,\n    BannerStubComponent,\n    RouterOutletStubComponent,\n    WelcomeStubComponent\n  ]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"3hm7s5x7prju490spg5jb2yd9\"><code>AppComponent</code> 是该测试的主角，因此当然要用它的真实版本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ihamh5bb2dkzliwr1eekjm7a\"><code>RouterLinkDirectiveStub</code>（\n<a href=\"guide/testing#routerlink\">稍后描述</a>）是真实 \n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 的测试版本， 它有助于链接测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1oia9ptwsrcykit8zsdn1373m\">其它都是测试桩。</p>\n<a id=\"no-errors-schema\"></a>\n<h4 id=\"no_errors_schema\"><em>NO_ERRORS_SCHEMA</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4yar357kciry6hjcafsnymloe\">在第二种方法中，将 \n<code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 添加到 \n<code>TestBed.schemas</code> 元数据中。</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"no-errors-schema\" title=\"app/app.component.spec.ts (NO_ERRORS_SCHEMA)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [\n    AppComponent,\n    RouterLinkDirectiveStub\n  ],\n  schemas: [ <a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a> ]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cr5a083qzo65xg8mm9oyxkhm\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 告诉 Angular 编译器忽略无法识别的元素和属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ue07vkl5md2i7qj1s0nkr8m5\">编译器将识别 \n<code>&lt;app-root&gt;</code> 元素和 \n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 属性， 因为你在 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置中声明了相应的 \n<code>AppComponent</code> 和 \n<code>RouterLinkDirectiveStub</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmqcaj0vtv9cq2fuyie39ft58\">但是，当编译器遇到 \n<code>&lt;app-banner&gt;</code>、\n<code>&lt;app-welcome&gt;</code> 或 \n<code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 时，它不会抛出错误。 它只是将它们渲染为空标签，浏览器会忽略它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"92rv6shqwij8w6w9rwlaw3lmt\">你不用再提供桩组件了。</p>\n<h4 id=\"use-both-techniques-together\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26luscwauyhxs3fsg5ps6hgx2\"><i class=\"material-icons\">link</i>将两种技术结合使用</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"clhlhvy5lo4qsicg29gu69lyn\">这些是 \n<em>浅层组件测试</em> 的技术， 之所以这样命名，是因为它们将组件的视觉表面缩减为仅组件模板中对测试重要的元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2oncy3o1dmr7ya9ucza3i3mv\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 方法是两者中最简单的，但不要过度使用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6gh1ojwbbumv06i2bpb8drz2o\"><code><a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a></code> 还会阻止编译器告诉你你无意中省略或拼写错误的缺失 组件和属性。 你可能会浪费数小时追查编译器可以在瞬间捕获的幽灵错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5c8l2553knqgexpbntp6x8oej\"><em>存根组件</em> 方法还有另一个优点。 虽然 \n<em>此</em> 示例中的存根是空的， 但如果你需要以某种方式与它们交互，则可以为它们提供简化的模板和类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax9rz8rj7l2uadp7tr87u0iov\">在实践中，你会将两种技术结合在同一个设置中， 如本示例所示。</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"mixed-setup\" title=\"app/app.component.spec.ts (mixed setup)\" linenums=\"false\">\nTestBed.configureTestingModule({\n  declarations: [\n    AppComponent,\n    BannerStubComponent,\n    RouterLinkDirectiveStub\n  ],\n  schemas: [ <a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a> ]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"da56neogr2pnbjd2lm7cpipy8\">Angular 编译器为 \n<code>&lt;app-banner&gt;</code> 元素创建 \n<code>BannerComponentStub</code>， 并将 \n<code>RouterLinkStubDirective</code> 应用于具有 \n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 属性的锚点， 但它会忽略 \n<code>&lt;app-welcome&gt;</code> 和 \n<code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code> 标签。</p>\n<hr>\n<a id=\"routerlink\"></a>\n<h3 id=\"components-with-routerlink\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e7p64nixxtujp52ibbmpmb1wl\"><i class=\"material-icons\">link</i>具有 \n<em>RouterLink</em> 的组件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"depad9oj31rxg9rn6bi3ebvlq\">真实的 \n<code>RouterLinkDirective</code> 非常复杂，并且与 \n<code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 的其他组件 和指令纠缠在一起。 它需要具有挑战性的设置才能在测试中进行模拟和使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1b9ftua6l7zq0dhpy4rse4l6z\">此示例代码中的 \n<code>RouterLinkDirectiveStub</code> 用一个替代版本替换了真实指令，该版本旨在验证在 \n<code>AppComponent</code> 模板中看到的锚点标签连接方式。</p>\n<code-example path=\"testing/src/testing/router-link-directive-stub.ts\" region=\"router-link\" title=\"testing/router-link-directive-stub.ts (RouterLinkDirectiveStub)\" linenums=\"false\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]',\n  host: { '(click)': 'onClick()' }\n})\nexport class RouterLinkDirectiveStub {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>') linkParams: any;\n  navigatedTo: any = null;\n\n  onClick() {\n    this.navigatedTo = this.linkParams;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afee7dbuetbzskwlu3zm5oxds\">绑定到 \n<code>[<a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>]</code> 属性的 URL 流入指令的 \n<code>linkParams</code> 属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8z5osa7sx5hfyoc2jrne8oca6\"><code>host</code> 元数据属性将宿主元素的点击事件（\n<code>AppComponent</code> 中的 \n<code>&lt;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>&gt;</code> 锚点元素）连接到存根指令的 \n<code>onClick</code> 方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1cby1ma0ka1w79yqwstphl5qc\">点击锚点应该会触发 \n<code>onClick()</code> 方法，该方法会设置存根的指示性 \n<code>navigatedTo</code> 属性。测试会检查 \n<code>navigatedTo</code> 以确认点击锚点是否设置了预期的路由定义。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ddw1cv5fjycvuot42uhni6s2f\">路由是否配置正确以使用该路由定义进行导航，这是另一组测试要解决的问题。</p>\n</div>\n<a id=\"by-directive\"></a>\n<a id=\"inject-directive\"></a>\n<h4 id=\"bydirective-and-injected-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qzbb0bjd0pujqsb3z4d85r3f\"><i class=\"material-icons\">link</i><em>By.directive</em> 和注入的指令</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"9gpft9ec9qy1w4wrgwoc2f8m\">再一步配置触发了数据绑定的初始化，获取导航链接的引用：</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"test-setup\" title=\"app/app.component.spec.ts (test setup)\" linenums=\"false\">\nbeforeEach(() =&gt; {\n  fixture.detectChanges(); // <a href=\"api/animations/trigger\" class=\"code-anchor\">trigger</a> initial data binding\n\n  // find DebugElements with an attached RouterLinkStubDirective\n  linkDes = fixture.debugElement\n    .queryAll(By.directive(RouterLinkDirectiveStub));\n\n  // get attached link directive instances\n  // using each <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>'s injector\n  routerLinks = linkDes.map(de =&gt; de.injector.get(RouterLinkDirectiveStub));\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"3u9fdsznbwxcnxjxy6ncfdjsc\">有三点特别重要：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3szfrztlm8yxy4seb08as6if0\">你可以使用 \n<code>By.directive</code> 定位带有附加指令的锚点元素。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dm1rm1qf6zlqhw3poeonqyjxr\">查询返回围绕匹配元素的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 包装器。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3qsw5vyuf7gdu48cmhmv9g312\">每个 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 都公开了一个依赖注入器，其中包含附加到该元素的指令的特定实例。</p>\n</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6adft3lczl7lmru73jdcq4z40\"><code>AppComponent</code> 中要验证的链接如下：</p>\n<code-example path=\"testing/src/app/app.component.html\" region=\"links\" title=\"app/app.component.html (navigation links)\" linenums=\"false\">\n&lt;nav&gt;\n  &lt;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/dashboard\"&gt;Dashboard&lt;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>&gt;\n  &lt;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/heroes\"&gt;Heroes&lt;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>&gt;\n  &lt;<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a>=\"/about\"&gt;About&lt;/<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>&gt;\n&lt;/nav&gt;\n\n</code-example>\n<a id=\"app-component-tests\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97z3x1m5w7pilzb7ja6s72yyp\">以下是一些测试，它们确认这些链接按预期连接到 \n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">routerLink</a></code> 指令：</p>\n<code-example path=\"testing/src/app/app.component.spec.ts\" region=\"tests\" title=\"app/app.component.spec.ts (selected tests)\" linenums=\"false\">\nit('can get RouterLinks from template', () =&gt; {\n  expect(routerLinks.length).toBe(3, 'should have 3 routerLinks');\n  expect(routerLinks[0].linkParams).toBe('/dashboard');\n  expect(routerLinks[1].linkParams).toBe('/heroes');\n  expect(routerLinks[2].linkParams).toBe('/about');\n});\n\nit('can click Heroes link in template', () =&gt; {\n  const heroesLinkDe = linkDes[1];   // heroes link <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>\n  const heroesLink = routerLinks[1]; // heroes link directive\n\n  expect(heroesLink.navigatedTo).toBeNull('should not have navigated yet');\n\n  heroesLinkDe.triggerEventHandler('click', null);\n  fixture.detectChanges();\n\n  expect(heroesLink.navigatedTo).toBe('/heroes');\n});\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2j3bwywuq71veb5jfan0fwwxt\">此示例中的“点击”测试具有误导性。它测试的是 \n<code>RouterLinkDirectiveStub</code> 而不是\n<em>组件</em>。这是指令存根的常见缺陷。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2o6tc2qtyr0cvq1z4niux56h1\">它在这个指南中有一个合理的用途。它演示了如何在不使用完整路由机制的情况下，找到一个 \n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 元素，点击它并检查结果。这可能是一项你可能需要测试更复杂的组件的技能，该组件会在用户点击链接时更改显示、重新计算参数或重新排列导航选项。</p>\n</div>\n<a id=\"why-stubbed-routerlink-tests\"></a>\n<h4 id=\"what-good-are-these-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jat7l9qc31tnmjbxosh31sbb\"><i class=\"material-icons\">link</i>这些测试有什么用？</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ateikyyiuz0fjouc41wdsd6rr\">存根的 \n<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> 测试可以确认具有链接和出口的组件是否设置正确，组件是否具有它应该具有的链接，以及它们是否都指向预期的方向。这些测试不关心应用程序在用户点击链接时是否能够成功导航到目标组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cyd245jpsfhsuhc9v8ckelrgk\">对于这种有限的测试目标，存根 \n<code>RouterLink</code> 和 \n<code>RouterOutlet</code> 是最佳选择。依赖于真实的路由会使它们变得脆弱。它们可能会因为与组件无关的原因而失败。例如，导航守卫可能会阻止未经授权的用户访问 \n<code>HeroListComponent</code>。这不是 \n<code>AppComponent</code> 的错误，对该组件的任何更改都无法解决测试失败的问题。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8xjobgdz4b8zk41gaxnfwhezf\">另一组\n<em>不同</em>的测试可以探索应用程序在影响守卫的条件下（例如用户是否已认证和授权）是否按预期导航。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8isrrcvfxgmlq2u08ew2yx9z\">未来的指南更新将解释如何使用 \n<code><a href=\"api/router/testing/RouterTestingModule\" class=\"code-anchor\">RouterTestingModule</a></code> 编写此类测试。</p>\n</div>\n<hr>\n<a id=\"page-object\"></a>\n<h3 id=\"use-a-page-object\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzjw93ohsmenwrna7al1lcosf\"><i class=\"material-icons\">link</i>使用\n<em>页面</em>对象</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8c4x7ggqu8w6ltj4fmea6is95\"><code>HeroDetailComponent</code> 是带有标题、两个英雄字段和两个按钮的简单视图。</p>\n<figure>\n  <img src=\"generated/images/guide/testing/hero-detail.component.png\" alt=\"HeroDetailComponent in action\" width=\"269\" height=\"170\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4rge93bafozg97ktx4m3w76q\">但即使是这么简单的表单，其模板中也涉及到不少复杂性。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.html\" title=\"app/hero/hero-detail.component.html\" linenums=\"false\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\"&gt;\n  &lt;h2&gt;&lt;span&gt;{{hero.name | <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">titlecase</a>}}&lt;/span&gt; Details&lt;/h2&gt;\n  &lt;div&gt;\n    &lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;\n  &lt;div&gt;\n    &lt;label for=\"name\"&gt;name: &lt;/label&gt;\n    &lt;input id=\"name\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\" /&gt;\n  &lt;/div&gt;\n  &lt;button (click)=\"save()\"&gt;Save&lt;/button&gt;\n  &lt;button (click)=\"cancel()\"&gt;Cancel&lt;/button&gt;\n&lt;/div&gt;\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5z9fb3m1xmxd9g8hagbd819pp\">测试组件需要…</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yw3ubkcn8iv5anvdlvv6hxt9\">等待英雄到达，然后元素才会出现在 DOM 中。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dy41ixcecpbivqsdvvy0yu0df\">对标题文本的引用。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5yh2de6j1y9co77wo78sknmkg\">对名称输入框的引用，以便检查和设置它。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8r64bfo5h168aki015zhnbdab\">对两个按钮的引用，以便可以点击它们。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"19c5ix07t3tf4fl7p9w63fagh\">对一些组件和路由方法的间谍。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bdv1cg0mw1m9xwdiukwh5wpfo\">即使是像这样一个很小的表单，也能产生令人疯狂的错综复杂的条件设置和 CSS 元素选择。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"uo206uf62eo07clmqmtfvtat\">使用 \n<code>Page</code> 类来控制对组件属性的访问，并封装设置它们的逻辑，从而简化复杂性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"67uuvaycjhu2omwzp1ew8ps1q\">下面是一个供 <code>hero-detail.component.spec.ts</code> 使用的 <code>Page</code> 类</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"page\" title=\"app/hero/hero-detail.component.spec.ts (Page)\" linenums=\"false\">\nclass Page {\n  // getter properties wait to <a href=\"api/animations/query\" class=\"code-anchor\">query</a> the DOM until called.\n  get buttons()     { return this.queryAll&lt;HTMLButtonElement&gt;('button'); }\n  get saveBtn()     { return this.buttons[0]; }\n  get cancelBtn()   { return this.buttons[1]; }\n  get nameDisplay() { return this.query&lt;HTMLElement&gt;('span'); }\n  get nameInput()   { return this.query&lt;HTMLInputElement&gt;('input'); }\n\n  gotoListSpy: jasmine.Spy;\n  navigateSpy:  jasmine.Spy;\n\n  constructor(fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&lt;HeroDetailComponent&gt;) {\n    // get the navigate spy from the injected router spy object\n    const routerSpy = &lt;any&gt; fixture.debugElement.injector.get(<a href=\"api/router/Router\" class=\"code-anchor\">Router</a>);\n    this.navigateSpy = routerSpy.navigate;\n\n    // spy on component's `gotoList()` method\n    const component = fixture.componentInstance;\n    this.gotoListSpy = spyOn(component, 'gotoList').and.callThrough();\n  }\n\n  //// <a href=\"api/animations/query\" class=\"code-anchor\">query</a> helpers ////\n  private <a href=\"api/animations/query\" class=\"code-anchor\">query</a>&lt;T&gt;(selector: string): T {\n    return fixture.nativeElement.querySelector(selector);\n  }\n\n  private queryAll&lt;T&gt;(selector: string): T[] {\n    return fixture.nativeElement.querySelectorAll(selector);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"36jp2xbsoqvhvygu6k3mx1u2\">现在，用来操作和检查组件的重要钩子都被井然有序的组织起来了，可以通过 <code>page</code> 实例来使用它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1vwsiylzx9skc4a4e226q177b\"><code>createComponent</code> 方法创建一个 \n<code>page</code> 对象，并在英雄到达后填补空白。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"create-component\" title=\"app/hero/hero-detail.component.spec.ts (createComponent)\" linenums=\"false\">\n/** Create the HeroDetailComponent, initialize it, set test variables  */\nfunction createComponent() {\n  fixture = TestBed.createComponent(HeroDetailComponent);\n  component = fixture.componentInstance;\n  page = new Page(fixture);\n\n  // 1st change detection triggers ngOnInit which gets <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> hero\n  fixture.detectChanges();\n  return fixture.whenStable().then(() =&gt; {\n    // 2nd change detection displays the async-fetched hero\n    fixture.detectChanges();\n  });\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmq2vpqysh4kcj4arvzc39nmq\">前面部分的\n<a href=\"guide/testing#tests-w-test-double\"><em>HeroDetailComponent</em> 测试</a>演示了 \n<code>createComponent</code> 和 \n<code>page</code> 如何使测试保持简短并\n<em>重点突出</em>。没有干扰：没有等待 Promise 求解，也没有在 DOM 中搜索要比较的元素值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"akwr9l1qosfrfbwuaphrwh27b\">还有更多的 <code>HeroDetailComponent</code> 测试可以证明这一点。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"selected-tests\" title=\"app/hero/hero-detail.component.spec.ts (selected tests)\" linenums=\"false\">\nit('should display that hero\\'s name', () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(expectedHero.name);\n});\n\nit('should navigate when click cancel', () =&gt; {\n  click(page.cancelBtn);\n  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n});\n\nit('should save when click save but not navigate immediately', () =&gt; {\n  // Get service injected into component and spy on its`saveHero` method.\n  // It delegates to fake `HeroService.updateHero` which delivers <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> safe test result.\n  const hds = fixture.debugElement.injector.get(HeroDetailService);\n  const saveSpy = spyOn(hds, 'saveHero').and.callThrough();\n\n  click(page.saveBtn);\n  expect(saveSpy.calls.any()).toBe(true, 'HeroDetailService.save called');\n  expect(page.navigateSpy.calls.any()).toBe(false, 'router.navigate not called');\n});\n\nit('should navigate when click save and save resolves', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  click(page.saveBtn);\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // wait for <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> save to complete\n  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n}));\n\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input');\n  const nameDisplay: HTMLElement = hostElement.querySelector('span');\n\n  // simulate user entering <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // dispatch <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> DOM event so that Angular learns of input value change.\n  nameInput.dispatchEvent(newEvent('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<hr>\n<a id=\"compile-components\"></a>\n<h3 id=\"calling-compilecomponents\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3r0u1zka2j3h6gdarj0bf1093\"><i class=\"material-icons\">link</i>调用\n<em>compileComponents()</em></h3>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cywh4kdo41tnuenm51h4h9lgu\">如果你\n<em>只</em>使用 CLI \n<code>ng test</code> 命令运行测试，则可以忽略此部分，因为 CLI 会在运行测试之前编译应用程序。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c56zaktepq809li6hnnxb7li8\">如果你在\n<strong>非 CLI 环境</strong>中运行测试，则测试可能会失败，并显示类似以下的错误消息：</p>\n<code-example language=\"sh\" class=\"code-shell\" hidecopy=\"\">\nError: This test module uses the component BannerComponent \nwhich is using <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> \"templateUrl\" or \"styleUrls\", but they were never compiled. \nPlease call \"TestBed.compileComponents\" before your test.\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsbm7evs2gfiyfv2esf9rlcfd\">问题的根源在于测试中涉及的至少一个组件指定了外部模板或 CSS 文件，如下面的 \n<code>BannerComponent</code> 版本所示。</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.ts\" title=\"app/banner/banner-external.component.ts (external template &amp; css)\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-banner',\n  templateUrl: './banner-external.component.html',\n  styleUrls:  ['./banner-external.component.css']\n})\nexport class BannerComponent {\n  title = 'Test Tour of Heroes';\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ayu3s6yieh4yi04tv9ts8ka6\">当 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 尝试创建组件时，测试会失败。</p>\n<code-example path=\"testing/src/app/banner/banner.component.spec.ts\" region=\"configure-and-create\" title=\"app/banner/banner.component.spec.ts (setup that fails)\" avoid=\"\" linenums=\"false\">\nbeforeEach(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  });\n  fixture = TestBed.createComponent(BannerComponent);\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dl4d1vsg0r5v0nzig8ogr3gb\">回想一下，应用程序尚未编译。因此，当你调用 \n<code>createComponent()</code> 时，\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 会隐式编译。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7oh0aah5kfjj6bf2oh64sosdi\">当源代码在内存中时，这不是问题。但是 \n<code>BannerComponent</code> 需要外部文件，编译必须从文件系统中读取这些文件，这是一个本质上\n<em>异步</em>的操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nps9l4ektu5woquu223ftc5g\">如果允许 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 继续，测试将运行并神秘地失败，因为编译器无法完成。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"56ght0bl8zvthwq8ybbauz7te\">这些错误信息告诉你要使用 <code>compileComponents()</code> 进行显式的编译。</p>\n<h4 id=\"compilecomponents-is-async\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3pp7sllitdgoyhh0opdr0n1t9\"><i class=\"material-icons\">link</i><em>compileComponents()</em> 是异步的</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5gtaw6a789flsrbfamqxy3718\">你必须在异步测试函数中调用 <code>compileComponents()</code>。</p>\n<div class=\"alert is-critical\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"erqeziid408n5xln3e4df4b4n\">如果你忽略了使测试函数异步（例如，忘记使用 \n<code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code>，如下所述），你将看到此错误消息</p>\n<code-example language=\"sh\" class=\"code-shell\" hidecopy=\"\">\nError: ViewDestroyedError: Attempt to use <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> destroyed view\n</code-example>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5ogf1axrgmc4dftw8mb1q70sf\">典型的做法是把准备逻辑拆成两个独立的 <code>beforeEach()</code> 函数：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5tvuhy4559ys9aode1c11zjmg\">一个异步的 \n<code>beforeEach()</code>，它编译组件</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dn8hhgu2a5wbpcjr8curuntx\">一个同步的 \n<code>beforeEach()</code>，它执行剩余的设置。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"340z6qw1yajecn224efwppcjb\">要遵循此模式，请使用其他测试符号导入 \n<code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 辅助函数。</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"import-async\">\nimport { <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>, <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\n\n</code-example>\n<h4 id=\"the-async-beforeeach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3tw5ul144qqod57844w44qk5j\"><i class=\"material-icons\">link</i>异步的\n<em>beforeEach</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6yipia3l0nnx2k5u5qld7sfo8\">像下面这样编写第一个异步的 <code>beforeEach</code>。</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"async-before-each\" title=\"app/banner/banner-external.component.spec.ts (async beforeEach)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  })\n  .compileComponents();  // compile template and css\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31hheomt5e34jpg6auvsekn9z\"><code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>()</code> 辅助函数接受一个无参数函数，该函数包含设置的主体。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejxmdzsg5evirzh35usfe0ld6\"><code>TestBed.configureTestingModule()</code> 方法返回 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 类，以便你可以将调用链接到其他 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 静态方法，例如 \n<code>compileComponents()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48rff9xw5zl8ihfreiwpg45w5\">在此示例中，\n<code>BannerComponent</code> 是唯一要编译的组件。其他示例使用多个组件配置测试模块，并可能导入包含更多组件的应用程序模块。它们中的任何一个都可能需要外部文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6h6g2w983h6bhw2jsuwwzdahm\"><code>TestBed.compileComponents</code> 方法会异步编译测试模块中配置过的所有组件。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2q9ie0mzerpzo25oe3z2uaxq6\">在调用 \n<code>compileComponents()</code> 后，不要重新配置 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b8rb28rgapk6w02f75k3dxjeh\">调用 \n<code>compileComponents()</code> 会关闭当前 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例以进行进一步配置。你不能再调用任何 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置方法，包括 \n<code>configureTestingModule()</code> 或任何 \n<code>override...</code> 方法。如果你尝试，\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 会抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89qlmlnvgwz868le0lrfyn6bq\">使 \n<code>compileComponents()</code> 成为在调用 \n<code>TestBed.createComponent()</code> 之前的最后一步。</p>\n<h4 id=\"the-synchronous-beforeeach\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxnynwsrb79kmw3ehdh3snwlp\"><i class=\"material-icons\">link</i>同步的\n<em>beforeEach</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dhkzsf107hz25z04pxqc39zil\">第二个同步 \n<code>beforeEach()</code> 包含剩余的设置步骤，包括创建组件和查询要检查的元素。</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"sync-before-each\" title=\"app/banner/banner-external.component.spec.ts (synchronous beforeEach)\" linenums=\"false\">\nbeforeEach(() =&gt; {\n  fixture = TestBed.createComponent(BannerComponent);\n  component = fixture.componentInstance; // BannerComponent test instance\n  h1 = fixture.nativeElement.querySelector('h1');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jsutbqwotx7guwdq8f10gb31\">你可以依靠测试运行器在调用第二个 \n<code>beforeEach</code> 之前等待第一个异步 \n<code>beforeEach</code> 完成。</p>\n<h4 id=\"consolidated-setup\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"275hecw5dasswv084vnlw1hda\"><i class=\"material-icons\">link</i>整合的准备代码</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"9l2iqffa5xlkod1ni7d8ytfo1\">你可以把这两个 <code>beforeEach()</code> 函数重整成一个异步的 <code>beforeEach()</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"18bi0x9yqbel6hc6rswp806s1\"><code>compileComponents()</code> 方法返回一个 Promise，因此你可以通过将同步代码移到 \n<code>then(...)</code> 回调中，在编译\n<em>之后</em>执行同步设置任务。</p>\n<code-example path=\"testing/src/app/banner/banner-external.component.spec.ts\" region=\"one-before-each\" title=\"app/banner/banner-external.component.spec.ts (one beforeEach)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n  TestBed.configureTestingModule({\n    declarations: [ BannerComponent ],\n  })\n  .compileComponents()\n  .then(() =&gt; {\n    fixture = TestBed.createComponent(BannerComponent);\n    component = fixture.componentInstance;\n    h1 = fixture.nativeElement.querySelector('h1');\n  });\n}));\n\n</code-example>\n<h4 id=\"compilecomponents-is-harmless\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7mtbfixgmav5yab5oicd0kv7g\"><i class=\"material-icons\">link</i><em>compileComponents()</em> 是无害的。</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"9yiqkrnkkughrrs238uebn4e3\">在不需要 <code>compileComponents()</code> 的时候调用它也不会有害处。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cyvk9dvgf5a8j1j1m4yd5k6qz\">CLI 生成的组件测试文件调用了 \n<code>compileComponents()</code>，即使在运行 \n<code>ng test</code> 时它从未被需要。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"9vrcabz52diuth4ewlrsby7em\">但这篇指南中的这些测试只会在必要时才调用 <code>compileComponents</code>。</p>\n<hr>\n<a id=\"import-module\"></a>\n<h3 id=\"setup-with-module-imports\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3sb9tbb1jmqxi0sbrd1nwelbh\"><i class=\"material-icons\">link</i>使用模块导入进行设置</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5yj4pig6c3iql2s9krf4glahr\">此前的组件测试程序使用了一些 <code>declarations</code> 来配置模块，就像这样：</p>\n<code-example path=\"testing/src/app/dashboard/dashboard-hero.component.spec.ts\" region=\"config-testbed\" title=\"app/dashboard/dashboard-hero.component.spec.ts (configure TestBed)\">\nTestBed.configureTestingModule({\n  declarations: [ DashboardHeroComponent ]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13mrcm1irhyb19bd059xwy0d1\"><code>DashboardComponent</code> 很简单，不需要任何帮助。但更复杂的组件通常依赖于其他组件、指令、管道和提供者，这些也必须添加到测试模块中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2t1lfsof9df4xlt1xm8bb389r\">幸运的是，\n<code>TestBed.configureTestingModule</code> 参数与传递给 \n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器的元数据平行，这意味着你也可以指定 \n<code>providers</code> 和 \n<code>imports</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32kkg3jy7q71yy3ajzii4m1lq\"><code>HeroDetailComponent</code> 尽管体积小巧，结构简单，但需要很多帮助。除了从默认测试模块 \n<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 获得的支持外，它还需要：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2vsat71d1rp3gezytba5tvg6\"><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 和 \n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 中的伙伴，以启用双向数据绑定。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qhlvy8dvilqt6xntm2cr3vw6\">来自 \n<code>shared</code> 文件夹的 \n<code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"81b6bbfw0k6oidu7mp1p19vra\">路由服务（这些测试正在模拟）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cthngs3h04vn6rf4986fy2zq6\">英雄数据访问服务（也已模拟）。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"3rv6lwu7j7bkdaeckgqcmmx5g\">一种方法是从各个部分配置测试模块，就像这样：</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-forms-module\" title=\"app/hero/hero-detail.component.spec.ts (FormsModule setup)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    imports:      [ <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ],\n    declarations: [ HeroDetailComponent, <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a> ],\n    providers: [\n      { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: activatedRoute },\n      { provide: HeroService,    useClass: TestHeroService },\n      { provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,         useValue: routerSpy},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ou901smip5zyi0crm3meydr6\">注意，\n<code>beforeEach()</code> 是异步的，并调用 \n<code>TestBed.compileComponents</code>，因为 \n<code>HeroDetailComponent</code> 有一个外部模板和 css 文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20kouzyb0jwwzko1ai4jgeh21\">如上面 \n<a href=\"guide/testing#compile-components\"><em>调用 compileComponents()</em></a> 中所述，这些测试可以在非 CLI 环境中运行，在该环境中，Angular 必须在浏览器中编译它们。</p>\n</div>\n<h4 id=\"import-a-shared-module\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8j08sii3rhb6e3o6km7yvmgv6\"><i class=\"material-icons\">link</i>导入共享模块</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yrehwk8o0dowc4q63tyoklja\">由于许多应用程序组件需要 \n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 和 \n<code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>，开发人员创建了 \n<code>SharedModule</code> 来组合这些以及其他经常需要的部分。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2rpmit6om983te8fqk7gcx8bb\">这些测试配置也可以使用 <code>SharedModule</code>，如下所示：</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-shared-module\" title=\"app/hero/hero-detail.component.spec.ts (SharedModule setup)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    imports:      [ SharedModule ],\n    declarations: [ HeroDetailComponent ],\n    providers: [\n      { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: activatedRoute },\n      { provide: HeroService,    useClass: TestHeroService },\n      { provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,         useValue: routerSpy},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"comw41fqys65afnspmuhgioid\">它更紧凑，更小，导入语句更少（未显示）。</p>\n<a id=\"feature-module-import\"></a>\n<h4 id=\"import-a-feature-module\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"crgh806lzqxhf9p75u9dp6u8s\"><i class=\"material-icons\">link</i>导入特性模块</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"546xehtxqj4rr0lj8b96qbupx\"><code>HeroDetailComponent</code> 是 \n<code>HeroModule</code> \n<a href=\"guide/feature-modules\">特性模块</a> 的一部分，它聚合了更多相互依赖的部分，包括 \n<code>SharedModule</code>。尝试一个像这样导入 \n<code>HeroModule</code> 的测试配置：</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-hero-module\" title=\"app/hero/hero-detail.component.spec.ts (HeroModule setup)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    imports:   [ HeroModule ],\n    providers: [\n      { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: activatedRoute },\n      { provide: HeroService,    useClass: TestHeroService },\n      { provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,         useValue: routerSpy},\n    ]\n  })\n  .compileComponents();\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7n1053bikf5vq3tst6gpjsd3f\">这\n<em>真的</em>很简洁。只有 \n<code>providers</code> 中的\n<em>测试替身</em>仍然存在。甚至 \n<code>HeroDetailComponent</code> 的声明也消失了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3oz2gcnpt4ghz8tuhyk1pbhg1\">事实上，如果你尝试声明它，Angular 会抛出一个错误，因为 \n<code>HeroDetailComponent</code> 在 \n<code>HeroModule</code> 和 \n<code>TestBed</code> 创建的 \n<code>DynamicTestModule</code> 中都被声明了。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wxe3k2hlqtjwpv7hneh9g12\">当模块内部存在许多相互依赖关系，并且模块很小（特性模块往往很小）时，导入组件的特性模块可能是配置测试的最简单方法。</p>\n</div>\n<hr>\n<a id=\"component-override\"></a>\n<h3 id=\"override-component-providers\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"78zumly5k3ex6me9sk4ig5504\"><i class=\"material-icons\">link</i>重写组件的服务提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4b4rnelrl6pexirajky2zxe4a\"><code>HeroDetailComponent</code> 提供自己的 <code>HeroDetailService</code> 服务。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.ts\" region=\"prototype\" title=\"app/hero/hero-detail.component.ts (prototype)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector:    'app-hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls:  ['./hero-detail.component.css' ],\n  providers:  [ HeroDetailService ]\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(\n    private heroDetailService: HeroDetailService,\n    private route:  <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d51ijw9vchu5wuwlrmes3c897\">无法在 \n<code>TestBed.configureTestingModule</code> 的 \n<code>providers</code> 中模拟组件的 \n<code>HeroDetailService</code>。这些是\n<em>测试模块</em>的提供者，而不是组件的提供者。它们在\n<em>夹具级别</em>准备依赖注入器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ncr8lidy99tnie3p379jwr06\">Angular 使用\n<em>自己的</em>注入器创建组件，该注入器是夹具注入器的\n<em>子</em>注入器。它将组件的提供者（在本例中为 \n<code>HeroDetailService</code>）注册到子注入器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"dmgnhcvhe1h6iwd6mqghrnm8v\">测试没办法从测试夹具的注入器中获取子注入器中的服务，而 <code>TestBed.configureTestingModule</code> 也没法配置它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9tylelrb1rdujfm2w5py1y40\">一直以来，Angular 都在创建真实 \n<code>HeroDetailService</code> 的新实例！</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8y7gqga1tezs9wye1k1hqot55\">如果 \n<code>HeroDetailService</code> 对远程服务器进行自己的 XHR 调用，这些测试可能会失败或超时。可能没有远程服务器可以调用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"71cj16a6q02kpbfq42aaug12b\">幸运的是，<code>HeroDetailService</code> 将远程数据访问的责任交给了注入进来的 <code>HeroService</code>。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.service.ts\" region=\"prototype\" title=\"app/hero/hero-detail.service.ts (prototype)\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroDetailService {\n  constructor(private heroService: HeroService) {  }\n/* . . . */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7v7sqrgdktb342fzygqa8t8dw\"><a href=\"guide/testing#feature-module-import\">之前的测试配置</a> 用 \n<code>TestHeroService</code> 替换了真实的 \n<code>HeroService</code>，该服务拦截服务器请求并伪造其响应。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e7m82c6e620bzjl6dmn2bzjx\">如果你没有那么幸运怎么办？如果模拟 \n<code>HeroService</code> 很困难怎么办？如果 \n<code>HeroDetailService</code> 进行自己的服务器请求怎么办？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"96qbs5ccbg2qep8ugwzki89v0\"><code>TestBed.overrideComponent</code> 方法可以将组件的 \n<code>providers</code> 替换为易于管理的\n<em>测试替身</em>，如以下设置变体所示：</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"setup-override\" title=\"app/hero/hero-detail.component.spec.ts (Override setup)\" linenums=\"false\">\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n  const routerSpy = createRouterSpy();\n\n  TestBed.configureTestingModule({\n    imports:   [ HeroModule ],\n    providers: [\n      { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: activatedRoute },\n      { provide: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>,         useValue: routerSpy},\n    ]\n  })\n\n  // Override component's own provider\n  .overrideComponent(HeroDetailComponent, {\n    set: {\n      providers: [\n        { provide: HeroDetailService, useClass: HeroDetailServiceSpy }\n      ]\n    }\n  })\n\n  .compileComponents();\n}));\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88qw5yiie9ykxkd10w3zb4kqb\">注意，\n<code>TestBed.configureTestingModule</code> 不再提供（假的）\n<code>HeroService</code>，因为它\n<a href=\"guide/testing#spy-stub\">不再需要</a>。</p>\n<a id=\"override-component-method\"></a>\n<h4 id=\"the-overridecomponent-method\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bpglmlh7746owpiqwdv4ywvmf\"><i class=\"material-icons\">link</i><em>overrideComponent</em> 方法</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"et5wd2qgx00ss4hvkklh1gdsm\">注意这个 <code>overrideComponent</code> 方法。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-component-method\" title=\"app/hero/hero-detail.component.spec.ts (overrideComponent)\" linenums=\"false\">\n.overrideComponent(HeroDetailComponent, {\n  set: {\n    providers: [\n      { provide: HeroDetailService, useClass: HeroDetailServiceSpy }\n    ]\n  }\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"erplqzo40hohg9h2k90yezbvp\">它接受两个参数：要覆盖的组件类型（\n<code>HeroDetailComponent</code>）和一个覆盖元数据对象。 \n<a href=\"guide/testing#metadata-override-object\">覆盖元数据对象</a> 是一个泛型，定义如下：</p>\n<code-example format=\".\" language=\"javascript\">\n  type <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a><t> = {\n    add?: T;\n    remove?: T;\n    set?: T;\n  };\n</t></code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c1lh2e2kbgkh1fhsws08xvi60\">元数据重载对象可以添加和删除元数据属性的项目，也可以彻底重设这些属性。这个例子重新设置了组件的 <code>providers</code> 元数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3mw5339alqrd5gdwmscjo235z\">类型参数 \n<code>T</code> 是你传递给 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 装饰器的元数据类型：</p>\n<code-example format=\".\" language=\"javascript\">\n  selector?: string;\n  template?: string;\n  templateUrl?: string;\n  providers?: any[];\n  ...\n</code-example>\n<a id=\"spy-stub\"></a>\n<h4 id=\"provide-a-spy-stub-herodetailservicespy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ovc5n88bu01ax6ywjya1zh2o\"><i class=\"material-icons\">link</i>提供一个\n<em>间谍桩</em>（\n<em>HeroDetailServiceSpy</em>）</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"207r7ony5uvimd8yc5sm44ohp\">这个例子把组件的 <code>providers</code> 数组完全替换成了一个包含 <code>HeroDetailServiceSpy</code> 的新数组。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"721zbpm6ks4yf0qlhsbs5wrsa\"><code>HeroDetailServiceSpy</code> 是真实 \n<code>HeroDetailService</code> 的一个桩版本，它伪造了该服务的所有必要功能。它既不注入也不委托给更低级别的 \n<code>HeroService</code>，因此不需要为它提供测试替身。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cb8lqb9e8j5mhwftxp221d08w\">相关的 \n<code>HeroDetailComponent</code> 测试将断言 \n<code>HeroDetailService</code> 的方法被调用，方法是通过监视服务方法。因此，桩将其实现方法作为间谍：</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"hds-spy\" title=\"app/hero/hero-detail.component.spec.ts (HeroDetailServiceSpy)\" linenums=\"false\">\nclass HeroDetailServiceSpy {\n  testHero: Hero = {id: 42, name: 'Test Hero' };\n\n  /* emit cloned test hero */\n  getHero = jasmine.createSpy('getHero').and.callFake(\n    () =&gt; asyncData(Object.assign({}, this.testHero))\n  );\n\n  /* emit clone of test hero, with changes merged in */\n  saveHero = jasmine.createSpy('saveHero').and.callFake(\n    (hero: Hero) =&gt; asyncData(Object.assign(this.testHero, hero))\n  );\n}\n\n\n</code-example>\n<a id=\"override-tests\"></a>\n<h4 id=\"the-override-tests\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"9ffh9bs7hgbf7j9rxeup6cj2e\"><i class=\"material-icons\">link</i>重写测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a65e8ennez5bvxfyljixsok1\">现在，测试可以通过操纵间谍桩的 \n<code>testHero</code> 直接控制组件的英雄，并确认服务方法被调用。</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"override-tests\" title=\"app/hero/hero-detail.component.spec.ts (override tests)\" linenums=\"false\">\nlet hdsSpy: HeroDetailServiceSpy;\n\nbeforeEach(<a href=\"api/core/testing/async\" class=\"code-anchor\">async</a>(() =&gt; {\n  createComponent();\n  // get the component's injected HeroDetailServiceSpy\n  hdsSpy = fixture.debugElement.injector.get(HeroDetailService) as any;\n}));\n\nit('should have called `getHero`', () =&gt; {\n  expect(hdsSpy.getHero.calls.count()).toBe(1, 'getHero called once');\n});\n\nit('should display stub hero\\'s name', () =&gt; {\n  expect(page.nameDisplay.textContent).toBe(hdsSpy.testHero.name);\n});\n\nit('should save stub hero change', <a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a>(() =&gt; {\n  const origName = hdsSpy.testHero.name;\n  const newName = 'New Name';\n\n  page.nameInput.value = newName;\n  page.nameInput.dispatchEvent(newEvent('input')); // tell Angular\n\n  expect(component.hero.name).toBe(newName, 'component hero has new name');\n  expect(hdsSpy.testHero.name).toBe(origName, 'service hero unchanged before save');\n\n  click(page.saveBtn);\n  expect(hdsSpy.saveHero.calls.count()).toBe(1, 'saveHero called once');\n\n  <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a>(); // wait for <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> save to complete\n  expect(hdsSpy.testHero.name).toBe(newName, 'service hero has new name after save');\n  expect(page.navigateSpy.calls.any()).toBe(true, 'router.navigate called');\n}));\n\n</code-example>\n<a id=\"more-overrides\"></a>\n<h4 id=\"more-overrides\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mjbrzoai8owzny0n4irwd9ej\"><i class=\"material-icons\">link</i>更多覆盖</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"biyk34iycszncshnw0osj67cu\"><code>TestBed.overrideComponent</code> 方法可以多次调用，用于相同或不同的组件。\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 提供了类似的 \n<code>overrideDirective</code>、\n<code>overrideModule</code> 和 \n<code>overridePipe</code> 方法，用于深入挖掘和替换这些其他类的部分。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"cioq7okr6hzk3x17w9z7zhkax\">自己探索这些选项和组合。</p>\n<hr>\n<a id=\"attribute-directive\"></a>\n<h2 id=\"attribute-directive-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0aeeonqug2h6i524jpnmwldr\"><i class=\"material-icons\">link</i>属性指令测试</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"52mr6q5j59157crygtiw1pr2f\"><em>属性型指令</em>会修改元素、组件或其他指令的行为。它的名字反映了该指令的应用方式：作为宿主元素的一个属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bglsuhpkxsahbqr4sgh05ejeq\">示例应用程序的 \n<code>HighlightDirective</code> 根据数据绑定的颜色或默认颜色（浅灰色）设置元素的背景颜色。它还将元素的自定义属性（\n<code>customProperty</code>）设置为 \n<code>true</code>，只是为了表明它可以做到。</p>\n<code-example path=\"testing/src/app/shared/highlight.directive.ts\" title=\"app/shared/highlight.directive.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[highlight]' })\n/** Set backgroundColor for the attached element to highlight color\n *  and set the element's customProperty to true */\nexport class HighlightDirective implements <a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a> {\n\n  defaultColor =  'rgb(211, 211, 211)'; // lightgray\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('highlight') bgColor: string;\n\n  constructor(private el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    el.nativeElement.style.customProperty = true;\n  }\n\n  ngOnChanges() {\n    this.el.nativeElement.style.backgroundColor = this.bgColor || this.defaultColor;\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"948ia9e8d857ilqnagccd2x8c\">它在整个应用中都用到过，也许最简单的是在 <code>AboutComponent</code> 中：</p>\n<code-example path=\"testing/src/app/about/about.component.ts\" title=\"app/about/about.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  template: `\n  &lt;h2 highlight=\"skyblue\"&gt;About&lt;/h2&gt;\n  &lt;h3&gt;Quote of the day:&lt;/h3&gt;\n  &lt;twain-quote&gt;&lt;/twain-quote&gt;\n  `\n})\nexport class AboutComponent { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ccvm59r8y9yw72bx8gko7lnx\">测试 \n<code>HighlightDirective</code> 在 \n<code>AboutComponent</code> 中的特定使用只需要上面探讨的技术（特别是 \n<a href=\"guide/testing#nested-component-tests\">\"浅层测试\"</a> 方法）。</p>\n<code-example path=\"testing/src/app/about/about.component.spec.ts\" region=\"tests\" title=\"app/about/about.component.spec.ts\" linenums=\"false\">\nbeforeEach(() =&gt; {\n  fixture = TestBed.configureTestingModule({\n    declarations: [ AboutComponent, HighlightDirective],\n    schemas:      [ <a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a> ]\n  })\n  .createComponent(AboutComponent);\n  fixture.detectChanges(); // initial binding\n});\n\nit('should have skyblue &lt;h2&gt;', () =&gt; {\n  const h2: HTMLElement = fixture.nativeElement.querySelector('h2');\n  const bgColor = h2.style.backgroundColor;\n  expect(bgColor).toBe('skyblue');\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"82o235c0nc4zcys2mhs8okywn\">但是，测试单个用例不太可能涉及指令的全部能力。要找到并测试那些使用了该指令的所有组件会很乏味、很脆弱，而且几乎不可能做到完全覆盖。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mthgbeuydhn5wo579n46xtpb\"><em>仅类测试</em>可能会有所帮助，但像这样的属性指令往往会操纵 DOM。隔离的单元测试不接触 DOM，因此，不会让人对指令的有效性充满信心。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"tqaqmzthn3yjge9is6nb69j\">更好的解决方案是创建一个人工测试组件来演示应用该指令的所有方法。</p>\n<code-example path=\"testing/src/app/shared/highlight.directive.spec.ts\" region=\"test-component\" title=\"app/shared/highlight.directive.spec.ts (TestComponent)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  template: `\n  &lt;h2 highlight=\"yellow\"&gt;Something Yellow&lt;/h2&gt;\n  &lt;h2 highlight&gt;The Default (Gray)&lt;/h2&gt;\n  &lt;h2&gt;No Highlight&lt;/h2&gt;\n  &lt;input #box [highlight]=\"box.value\" value=\"cyan\"/&gt;`\n})\nclass TestComponent { }\n\n</code-example>\n<figure>\n  <img src=\"generated/images/guide/testing/highlight-directive-spec.png\" alt=\"HighlightDirective spec in action\" width=\"200\" height=\"159\">\n</figure>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3x2jd90ij75y6xg6abefj2v91\"><code>&lt;input&gt;</code> 案例将 \n<code>HighlightDirective</code> 绑定到输入框中颜色值的名称。初始值为单词 \"cyan\"，它应该是输入框的背景颜色。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6ou7jukpgi0ent9sl340xznfk\">下面是对该组件的一些测试：</p>\n<code-example path=\"testing/src/app/shared/highlight.directive.spec.ts\" region=\"selected-tests\" title=\"app/shared/highlight.directive.spec.ts (selected tests)\">\nbeforeEach(() =&gt; {\n  fixture = TestBed.configureTestingModule({\n    declarations: [ HighlightDirective, TestComponent ]\n  })\n  .createComponent(TestComponent);\n\n  fixture.detectChanges(); // initial binding\n\n  // all elements with an attached HighlightDirective\n  des = fixture.debugElement.queryAll(By.directive(HighlightDirective));\n\n  // the h2 without the HighlightDirective\n  bareH2 = fixture.debugElement.query(By.css('h2:not([highlight])'));\n});\n\n// color tests\nit('should have three highlighted elements', () =&gt; {\n  expect(des.length).toBe(3);\n});\n\nit('should color 1st &lt;h2&gt; background \"yellow\"', () =&gt; {\n  const bgColor = des[0].nativeElement.style.backgroundColor;\n  expect(bgColor).toBe('yellow');\n});\n\nit('should color 2nd &lt;h2&gt; background w/ default color', () =&gt; {\n  const dir = des[1].injector.get(HighlightDirective) as HighlightDirective;\n  const bgColor = des[1].nativeElement.style.backgroundColor;\n  expect(bgColor).toBe(dir.defaultColor);\n});\n\nit('should bind &lt;input&gt; background to value color', () =&gt; {\n  // easier to work with nativeElement\n  const input = des[2].nativeElement as HTMLInputElement;\n  expect(input.style.backgroundColor).toBe('cyan', 'initial backgroundColor');\n\n  // dispatch <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> DOM event so that Angular responds to the input value change.\n  input.value = 'green';\n  input.dispatchEvent(newEvent('input'));\n  fixture.detectChanges();\n\n  expect(input.style.backgroundColor).toBe('green', 'changed backgroundColor');\n});\n\n\nit('bare &lt;h2&gt; should not have <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> customProperty', () =&gt; {\n  expect(bareH2.properties['customProperty']).toBeUndefined();\n});\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"3y2lc5hlzxsz1e3wn30k2l0na\">一些技巧值得注意：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54ye3cf1sk9l9grdo454xon6o\"><code>By.directive</code> 谓词是在\n<em>元素类型未知时</em>获取具有此指令的元素的好方法。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3nprwx4n8cs0tpcsznisesliq\"><code>By.css('h2:not([highlight])')</code> 中的 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:not\"><code>:not</code> 伪类</a> 有助于查找\n<em>没有</em>该指令的 \n<code>&lt;h2&gt;</code> 元素。\n<code>By.css('*:not([highlight])')</code> 查找\n<em>任何</em>没有该指令的元素。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"765juh1cwkatprq596goqy019\"><code><a href=\"api/core/DebugElement#styles\" class=\"code-anchor\">DebugElement.styles</a></code> 允许访问元素样式，即使在没有真实浏览器的情况下，这要归功于 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 抽象。但如果抽象方法看起来更容易或更清晰，请随意利用 \n<code>nativeElement</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayua5oll3vn0vph0k6xrvltij\">Angular 将指令添加到它应用到的元素的注入器中。默认颜色的测试使用第二个 \n<code>&lt;h2&gt;</code> 的注入器来获取其 \n<code>HighlightDirective</code> 实例及其 \n<code>defaultColor</code>。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56rej8u27dkew85do47s51hn1\"><code><a href=\"api/core/DebugElement#properties\" class=\"code-anchor\">DebugElement.properties</a></code> 允许访问指令设置的人工自定义属性。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"pipe-testing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yaeufqha2e8dbnw85r24o5ku\"><i class=\"material-icons\">link</i>管道测试</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"378cjeqfnt2p9pr9c605hyhd5\">管道很容易测试，不需要 Angular 测试工具。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rbe3nf0wt4wtib4kt8rj10zx\">管道类有一个方法 \n<code>transform</code>，它将输入值操作为转换后的输出值。\n<code>transform</code> 实现很少与 DOM 交互。大多数管道除了 \n<code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code> 元数据和一个接口之外，没有对 Angular 的依赖。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3cfun9cdldq7o6yfl78y31xrp\">考虑一个 \n<code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code>，它将每个单词的首字母大写。 这是一个使用正则表达式的简单实现。</p>\n<code-example path=\"testing/src/app/shared/title-case.pipe.ts\" title=\"app/shared/title-case.pipe.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({name: 'titlecase', pure: false})\n/** Transform to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case: uppercase the first letter of the words in <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> string.*/\nexport class <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a> implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(input: string): string {\n    return input.length === 0 ? '' :\n      input.replace(/\\w\\S*/g, (txt =&gt; txt[0].toUpperCase() + txt.substr(1).toLowerCase() ));\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"64osqp3hrhq44i9c6fejc0d7x\">任何使用正则表达式的东西都值得彻底测试。使用简单的 Jasmine 来探索预期的案例和边缘情况。</p>\n<code-example path=\"testing/src/app/shared/title-case.pipe.spec.ts\" region=\"excerpt\" title=\"app/shared/title-case.pipe.spec.ts\">\ndescribe('<a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>', () =&gt; {\n  // This pipe is <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> pure, stateless function so no need for BeforeEach\n  let pipe = new <a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a>();\n\n  it('transforms \"abc\" to \"Abc\"', () =&gt; {\n    expect(pipe.transform('abc')).toBe('Abc');\n  });\n\n  it('transforms \"abc def\" to \"Abc Def\"', () =&gt; {\n    expect(pipe.transform('abc def')).toBe('Abc Def');\n  });\n\n  // ... more tests ...\n});\n\n</code-example>\n<a id=\"write-tests\"></a>\n<h4 id=\"write-dom-tests-too\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4gaqjgacuxr8im2jxnjhaevnh\"><i class=\"material-icons\">link</i>也编写 DOM 测试</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlpd91jl1yzwou7nf86134iqd\">这些是\n<em>独立</em>的管道测试。 它们无法判断 \n<code><a href=\"api/common/TitleCasePipe\" class=\"code-anchor\">TitleCasePipe</a></code> 在应用组件中是否正常工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1pqgnklmt2rjs9c0bvp3po8of\">考虑添加这样的组件测试：</p>\n<code-example path=\"testing/src/app/hero/hero-detail.component.spec.ts\" region=\"title-case-pipe\" title=\"app/hero/hero-detail.component.spec.ts (pipe test)\">\nit('should convert hero name to <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> Case', () =&gt; {\n  // get the name's input and display elements from the DOM\n  const hostElement = fixture.nativeElement;\n  const nameInput: HTMLInputElement = hostElement.querySelector('input');\n  const nameDisplay: HTMLElement = hostElement.querySelector('span');\n\n  // simulate user entering <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> new name into the input box\n  nameInput.value = 'quick BROWN  fOx';\n\n  // dispatch <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> DOM event so that Angular learns of input value change.\n  nameInput.dispatchEvent(newEvent('input'));\n\n  // Tell Angular to update the display binding through the title pipe\n  fixture.detectChanges();\n\n  expect(nameDisplay.textContent).toBe('Quick Brown  Fox');\n});\n\n</code-example>\n<hr>\n<a id=\"test-debugging\"></a>\n<h2 id=\"test-debugging\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d196xlnyqj13jlfh92586mpy4\"><i class=\"material-icons\">link</i>测试调试</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"akrea7ic8jb79z40iczab9ioi\">在浏览器中调试这些测试规约的方式与调试应用时相同。</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8peqzee6417k1p81b8j3cgthp\">显示 karma 浏览器窗口（之前隐藏）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"35wk1vd879d4br0w0z66xeop7\">点击 \n<strong>DEBUG</strong> 按钮；它会打开一个新的浏览器标签页并重新运行测试。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3apm6j3yngw6q6vjdhdz4ife1\">打开浏览器的“开发者工具”（Windows 上为 \n<code>Ctrl-Shift-I</code>；OSX 上为 \n<code>Command-Option-I</code>）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5t4hy636sn85utl1yv2laok40\">选择“sources”部分。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"73e5wyw9v8l1jzwknh9v3levc\">打开 \n<code>1st.spec.ts</code> 测试文件（Control/Command-P，然后开始输入文件名）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"eihr3xmtj493gzrrie0qmzdbj\">在测试中设置一个断点。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e4xwqf1fli652xed6udopafwv\">刷新浏览器，它会在断点处停止。</li>\n</ol>\n<figure>\n  <img src=\"generated/images/guide/testing/karma-1st-spec-debug.png\" alt=\"Karma debugging\" width=\"700\" height=\"150\">\n</figure>\n<hr>\n<a id=\"atu-apis\"></a>\n<h2 id=\"testing-utility-apis\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"ebvbxxp2lwm71m7q7b2xvbvg4\"><i class=\"material-icons\">link</i>测试实用工具 API</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvn1iiyiums8yfu86iske4g1k\">本节将盘点最实用的 Angular 测试特性，并总结它们的功能。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bksyvlxjkp6d23u8ihpq5ptn\">Angular 测试工具包括 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code>、\n<code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 和一些控制测试环境的函数。 \n<a href=\"guide/testing#testbed-api-summary\"><em>TestBed</em></a> 和 \n<a href=\"guide/testing#component-fixture-api-summary\"><em>ComponentFixture</em></a> 类将在单独的章节中介绍。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"9xfmr3bkgdsj428agchzu9574\">下面是一些独立函数的摘要，以使用频率排序：</p>\n<table>\n  <tbody><tr>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"69zkc5nhsy9rpq7h7lvbwnmwn\">函数</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c1zh7m7zz0q1ywb7182og533b\">说明</th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a></code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ac27umfu6xgzptja3xn2um3rb\">在特殊的\n<em>异步测试区域</em>内运行测试（\n<code>it</code>）或设置（\n<code>beforeEach</code>）函数的主体。 参见 \n<a href=\"guide/testing#async\">上面的讨论</a>。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bvgoxb5rn9ex2wj4oooxvzb1m\">在特殊的\n<em>fakeAsync 测试区域</em>内运行测试（\n<code>it</code>）的主体，从而实现 线性控制流编码风格。参见 \n<a href=\"guide/testing#fake-async\">上面的讨论</a>。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a></code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5oc3fzkz5qt3owt15lkgwthm7\">通过刷新\n<em>fakeAsync 测试区域</em>内的\n<em>计时器</em>和\n<em>微任务</em>队列，模拟时间的推移和挂起的异步活动的完成。</p>\n      <div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94wwlnfy6t5th3b0dhd59mdns\">好奇心强且专注的读者可能会喜欢这篇冗长的博文， \n<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">\"<em>Tasks, microtasks, queues and schedules</em>\"</a>。</p>\n      </div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7f5bncoamp9cos7vu5drgdkty\">接受一个可选参数，该参数将虚拟时钟向前移动 指定毫秒数， 清除在此时间范围内安排的异步活动。 参见 \n<a href=\"guide/testing#tick\">上面的讨论</a>。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n       <code><a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6uzirqy90goolzqyf6kxzd4hm\">将当前 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 注入器中的一个或多个服务注入到测试函数中。 它无法注入组件本身提供的服务。 参见 \n<a href=\"guide/testing#get-injected-services\">debugElement.injector</a> 的讨论。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xr9vk0plttxesze4fwirhfbu\">当 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 测试以挂起的计时器事件\n<em>任务</em>（排队的 \n<code>setTimeOut</code> 和 \n<code>setInterval</code> 回调）结束时， 测试会以清晰的错误消息失败。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87n5nm3cuzpqeczw6x2gv77kh\">一般来说，测试应该以没有排队的任务结束。 当预期挂起计时器任务时，调用 \n<code><a href=\"api/core/testing/discardPeriodicTasks\" class=\"code-anchor\">discardPeriodicTasks</a></code> 来刷新\n<em>任务</em>队列 并避免错误。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3lwscakimyqnrgibvlfcg1irg\">当 \n<code><a href=\"api/core/testing/fakeAsync\" class=\"code-anchor\">fakeAsync</a></code> 测试以挂起的\n<em>微任务</em>（例如未解析的 Promise）结束时， 测试会以清晰的错误消息失败。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bc4t25o0drn1sreot2abyurwt\">一般来说，测试应该等待微任务完成。 当预期挂起微任务时，调用 \n<code><a href=\"api/core/testing/flushMicrotasks\" class=\"code-anchor\">flushMicrotasks</a></code> 来刷新\n<em>微任务</em>队列 并避免错误。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/ComponentFixtureAutoDetect\" class=\"code-anchor\">ComponentFixtureAutoDetect</a></code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emebbz4mu6d2kqxmjhoek7cuf\">用于服务的提供者令牌，该服务打开 \n<a href=\"guide/testing#automatic-change-detection\">自动变更检测</a>。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a></code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eteqlawp0lzmbmxqcs08p4w3w\">获取 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的当前实例。 通常不需要，因为 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 类的静态类方法通常就足够了。 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例公开了一些很少使用的成员，这些成员无法作为 静态方法使用。</p>\n    </td>\n  </tr>\n</tbody></table>\n<hr>\n<a id=\"testbed-class-summary\"></a>\n<h4 id=\"testbed-class-summary\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bppn3j0kzr6e3ct3o5fnd937j\"><i class=\"material-icons\">link</i><em>TestBed</em> 类摘要</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"enkj97izp63lu4amcozzbxzzs\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 类是主要的 Angular 测试工具之一。 它的 API 非常庞大，在你探索它之前可能会让人不知所措， 一次一点地探索。首先阅读本指南的早期部分 了解基础知识，然后再尝试吸收完整的 API。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vxg9tj79rzs4r0bhjyk753k2\">传递给 \n<code>configureTestingModule</code> 的模块定义 是 \n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 元数据属性的子集。</p>\n<code-example format=\".\" language=\"javascript\">\n  type <a href=\"api/core/testing/TestModuleMetadata\" class=\"code-anchor\">TestModuleMetadata</a> = {\n    providers?: any[];\n    declarations?: any[];\n    imports?: any[];\n    schemas?: Array&lt;<a href=\"api/core/SchemaMetadata\" class=\"code-anchor\">SchemaMetadata</a> | any[]&gt;;\n  };\n</code-example>\n<a id=\"metadata-override-object\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8vxazocuno3lo9vvtzqdqqhdp\">每个覆盖方法都接受一个 \n<code><a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a>&lt;T&gt;</code>，其中 \n<code>T</code> 是适合该方法的元数据类型，即 \n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>、 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>、\n<code>@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 或 \n<code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code> 的参数。</p>\n<code-example format=\".\" language=\"javascript\">\n  type <a href=\"api/core/testing/MetadataOverride\" class=\"code-anchor\">MetadataOverride</a><t> = {\n    add?: T;\n    remove?: T;\n    set?: T;\n  };\n</t></code-example>\n<a id=\"testbed-methods\"></a>\n<a id=\"testbed-api-summary\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6kaofyiybkfh29s2v5s59dzt\"><code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> API 由静态类方法组成，这些方法要么更新要么引用 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 的\n<em>全局</em>实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ws06stur89qlg80cv9rdtmdn\">在内部，所有静态方法都覆盖当前运行时 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 实例的方法， 该实例也是由 \n<code><a href=\"api/core/testing/getTestBed\" class=\"code-anchor\">getTestBed</a>()</code> 函数返回的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebkiuu3lh1v5myuwz366l52p3\">在 \n<code>beforeEach()</code> \n<em>内部</em>调用 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 方法，以确保在每个单独测试之前都重新开始。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bo5rtabfl0612hhvd3ph25se5\">这里列出了最重要的静态方法，以使用频率排序。</p>\n<table>\n  <tbody><tr>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fsj23mx5o5oztwjxzrt5w4fn\">方法</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c1zh7m7zz0q1ywb7182og533b\">说明</th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>configureTestingModule</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5inildewhkr6gpljbct544gwd\">测试垫片（\n<code>karma-test-shim</code>、\n<code>browser-test-shim</code>） 建立 \n<a href=\"guide/testing\">初始测试环境</a> 和默认测试模块。 默认测试模块配置了基本声明和每个测试人员都需要的一些 Angular 服务替代品。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbk7xoc3bsdgs25c864xwdbgc\">调用 \n<code>configureTestingModule</code> 来细化特定测试集的测试模块配置 通过添加和删除导入、声明（组件、指令和管道）和提供者。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>compileComponents</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wyvaam8f8dc4xozva585aips\">在完成配置后异步编译测试模块。 如果\n<em>任何</em>测试模块组件具有 \n<code>templateUrl</code> 或 \n<code>styleUrls</code>，则\n<strong>必须</strong>调用此方法，因为获取组件模板和样式文件必然是异步的。 参见 \n<a href=\"guide/testing#compile-components\">上面</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9w4duev1g3hfxlrungt26mi6y\">调用 \n<code>compileComponents</code> 后，\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置在当前规范的持续时间内被冻结。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>createComponent<t></t></code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1z9y4sjp3vviul5yvhaqu4x5x\">根据当前 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置创建类型为 \n<code>T</code> 的组件实例。 调用 \n<code>compileComponent</code> 后，\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置在当前规范的持续时间内被冻结。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overrideModule</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ga5gcag7m3ppq0vukgm3ld0o\">替换给定 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 的元数据。请记住，模块可以导入其他模块。 \n<code>overrideModule</code> 方法可以深入到当前测试模块中 修改这些内部模块之一。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overrideComponent</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e76dnoh9l2njzo2r1u8roea5a\">替换给定组件类的元数据，该组件类可能嵌套在内部模块中。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overrideDirective</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0gv1cj7d3192dk5jldsunsxb\">替换给定指令类的元数据，该指令类可能嵌套在内部模块中。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>overridePipe</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2kc4jmp9vsf04vyl0a8u2vpf\">替换给定管道类的元数据，该管道类可能嵌套在内部模块中。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"testbed-get\"></a>\n      <code>get</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6j2ucc6doev7f1kfyw3qhw77\">从当前 \n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 注入器中检索服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"275mbzag65ph7na6nph0w9j0n\"><code><a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code> 函数通常足以满足此目的。 但如果 \n<code><a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code> 无法提供服务，它会抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4pn32qfb7j5jnl8c4j1vxs40s\">如果服务是可选的怎么办？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5x1em8o74ywxxqw9itkh6tg7x\"><code>TestBed.get()</code> 方法接受一个可选的第二个参数， 如果 Angular 找不到提供者，则返回该对象 （在本例中为 \n<code>null</code>）：</p>\n<p>      <code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"testbed-get-w-null\" title=\"app/demo/demo.testbed.spec.ts\" linenums=\"false\">\nservice = TestBed.get(NotProvided, null); // service is null\n\n</code-example></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dt23u2bi0l1xaiye7zhsyjsm1\">调用 \n<code>get</code> 后，\n<code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> 配置在当前规范的持续时间内被冻结。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <a id=\"testbed-initTestEnvironment\"></a>\n      <code>initTestEnvironment</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76bvw0p6zcppvz2ulxwl2w3ka\">初始化整个测试运行的测试环境。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98h8xmaeei2ovc38rqci8uab8\">测试垫片（\n<code>karma-test-shim</code>、\n<code>browser-test-shim</code>）会为你调用它 因此你很少有理由自己调用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wyu99yhphwwkd2qe85jf9az3\">你最多可以调用此方法\n<em>一次</em>。如果你必须在测试运行过程中更改 此默认值，请先调用 \n<code>resetTestEnvironment</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a2ythiygp5r3fifr5iq68w58i\">指定 Angular 编译器工厂（一个 \n<code><a href=\"api/core/PlatformRef\" class=\"code-anchor\">PlatformRef</a></code>）和一个默认的 Angular 测试模块。 非浏览器平台的替代方案以通用形式提供， 例如 \n<code>@angular/platform-&lt;platform_name&gt;/testing/&lt;platform_name&gt;</code>。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>resetTestEnvironment</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9zrjwx5wj3a3qntipkt9e81ty\">重置初始测试环境，包括默认测试模块。</p>\n    </td>\n  </tr>\n</tbody></table>A few of the <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> instance methods are not covered by static <code><a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a></code> <em>class</em> methods.\nThese are rarely needed.<p></p>\n<a id=\"component-fixture-api-summary\"></a>\n<h4 id=\"the-componentfixture\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jx3wmtbvy3e22zmoru7cpnn2\"><i class=\"material-icons\">link</i><em>ComponentFixture</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jrpzfq84g43316fm8yirz0cs\"><code>TestBed.createComponent&lt;T&gt;</code> 创建组件 \n<code>T</code> 的实例， 并返回一个针对该组件的强类型 \n<code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9uwc0yvbxnkx7jefu8ox91rhh\"><code><a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a></code> 的属性和方法提供了对组件、 其 DOM 表示以及 Angular 环境各个方面的访问。</p>\n<a id=\"component-fixture-properties\"></a>\n<h4 id=\"componentfixture-properties\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bg9oehatwcht36wnic8e61z1c\"><i class=\"material-icons\">link</i><em>ComponentFixture</em> 属性</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5erhswfokpke60pfl8ftj2ovp\">下面是对测试最重要的属性，以使用频率排序。</p>\n<table>\n  <tbody><tr>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yrneke1kjvnf5mt7mxyl2lqg\">属性</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c1zh7m7zz0q1ywb7182og533b\">说明</th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>componentInstance</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e19gwanfy2n7g0tbo14ju1vv5\">由 \n<code>TestBed.createComponent</code> 创建的组件类实例。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>debugElement</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5t1xtw5t3x57namibe0ggg597\">与组件根元素关联的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amgm2wirb5d37wrslb0g7flew\"><code>debugElement</code> 在测试和调试期间提供了对组件及其 DOM 元素的洞察。 对于测试人员来说，这是一个关键属性。下面将介绍最有趣的成员。 \n<a href=\"guide/testing#debug-element-details\">点击此处查看</a>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>nativeElement</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3u8mqci751uqngklpoc34kvn6\">组件根部的原生 DOM 元素。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>changeDetectorRef</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a87b98v019m708gpoftjxuwbt\">组件的 \n<code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7x2ql549pr8yjzmh2k679j91o\">当测试具有 \n<code><a href=\"api/core/ChangeDetectionStrategy#OnPush\" class=\"code-anchor\">ChangeDetectionStrategy.OnPush</a></code> 方法的组件或组件的变更检测受程序控制时， \n<code><a href=\"api/core/ChangeDetectorRef\" class=\"code-anchor\">ChangeDetectorRef</a></code> 最有价值。</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"component-fixture-methods\"></a>\n<h4 id=\"componentfixture-methods\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crq69ylh4n5avcxnd5axb10ud\"><i class=\"material-icons\">link</i><em>ComponentFixture</em> 方法</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8isoy0gf8gtnjq5ob28umaeit\"><em>fixture</em> 方法会导致 Angular 对组件树执行某些任务。 调用这些方法以触发 Angular 对模拟用户操作的响应行为。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"9rge64b4zkeic42ufdz0ewwez\">下面是对测试最有用的方法。</p>\n<table>\n  <tbody><tr>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7fsj23mx5o5oztwjxzrt5w4fn\">方法</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c1zh7m7zz0q1ywb7182og533b\">说明</th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>detectChanges</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1n1oe3nnpe6dptdtjm1znjsn7\">触发组件的变更检测周期。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nsmq1uzbm2vgj6siklfoxwbv\">调用它来初始化组件（它会调用 \n<code>ngOnInit</code>），并在测试代码之后更改组件的数据绑定属性值。 Angular 无法看到你更改了 \n<code>personComponent.name</code>，并且在调用 \n<code>detectChanges</code> 之前不会更新 \n<code>name</code> 绑定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cz4302qwrxxqyfdb2m809s4t7\">之后运行 \n<code>checkNoChanges</code> 以确认没有循环更新，除非调用 \n<code>detectChanges(false)</code>；</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>autoDetectChanges</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dfepc48vqy6ghwmsybs1urp9o\">当你希望 fixture 自动检测更改时，将其设置为 \n<code>true</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2kb6qlwrr2kbfztvd1wfwumae\">当 autodetect 为 \n<code>true</code> 时，测试 fixture 会在创建组件后立即调用 \n<code>detectChanges</code>。然后它会监听相关的区域事件，并相应地调用 \n<code>detectChanges</code>。 当你的测试代码直接修改组件属性值时， 你可能仍然需要调用 \n<code>fixture.detectChanges</code> 来触发数据绑定更新。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"11srdbjf3mx56c8vtcnqao391\">默认值为 \n<code>false</code>。喜欢对测试行为进行精细控制的测试人员倾向于将其保留为 \n<code>false</code>。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>checkNoChanges</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ag6l44350rn6dysjrxbzgjxb\">执行变更检测运行以确保没有待处理的更改。 如果有更改，则抛出异常。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>isStable</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8q9psbz2ou5urylgbzd0w2z8s\">如果 fixture 当前处于 \n<em>稳定</em> 状态，则返回 \n<code>true</code>。 如果有未完成的异步任务，则返回 \n<code>false</code>。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>whenStable</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cj94wej044wrk8tiujw05izdn\">返回一个在 fixture 稳定时解析的 Promise。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xt8y1v62c7hhspvztu89t0su\">要在异步活动或异步变更检测完成后恢复测试，请挂钩该 Promise。 请参阅 \n<a href=\"guide/testing#when-stable\">此处</a>.</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>destroy</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7cq00u476my16ckj8blqdawd9\">触发组件的销毁。</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"debug-element-details\"></a>\n<h4 id=\"debugelement-1\"><em>DebugElement</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"h70kbrvqjdc5y6090e7s8gka\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 提供了对组件 DOM 表示的关键洞察。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"57g54gsi0msn6qd7dmjfddm8q\">从测试根组件的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>（由 \n<code>fixture.debugElement</code> 返回）开始， 你可以遍历（并查询）fixture 的整个元素和组件子树。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36d5302u6jvz20rpeef4akojn\">以下是测试人员最常用的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 成员，按实用性排序（大致）：</p>\n<table>\n  <tbody><tr>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4mqt2qsskr458389a5znethu\">成员</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c1zh7m7zz0q1ywb7182og533b\">说明</th>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>nativeElement</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zr8ppta33umne912ezc3nuwm\">浏览器中的对应 DOM 元素（WebWorkers 为 null）。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code><a href=\"api/animations/query\" class=\"code-anchor\">query</a></code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ciz5tsky0ijoeafuxlqctjdb8\">调用 \n<code><a href=\"api/animations/query\" class=\"code-anchor\">query</a>(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&lt;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>&gt;)</code> 返回第一个与 \n<a href=\"guide/testing#query-predicate\">谓词</a>匹配的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>， 该谓词位于子树中的任何深度。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>queryAll</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"xdq8d0gljiys2jd5qez7h9at\">调用 \n<code>queryAll(predicate: <a href=\"api/core/Predicate\" class=\"code-anchor\">Predicate</a>&lt;<a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a>&gt;)</code> 返回所有与 \n<a href=\"guide/testing#query-predicate\">谓词</a>匹配的 \n<code>DebugElements</code>， 该谓词位于子树中的任何深度。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>injector</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8neg176nfoh2nv3nrbj03503\">宿主依赖注入器。 例如，根元素的组件实例注入器。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>componentInstance</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"767imx67ls7q6b92k5pls71ep\">元素自己的组件实例（如果有）。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>context</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2o7barhtd15zsqkgafj8lzxx0\">提供此元素的父级上下文的对象。 通常是管理此元素的祖先组件实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wdolvkpiy9j8l902ua5c193c\">当元素在 \n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 中重复时，上下文是一个 \n<code>NgForRow</code>，其 \n<code>$implicit</code> 属性是行实例值的 value。 例如，\n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"</code> 中的 \n<code>hero</code>。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>children</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eep6go6q9w43qt5te2yznexef\">直接的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 子元素。通过遍历 \n<code>children</code> 来遍历树。</p>\n      <div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3flpus1f1pewpu46clawxscmv\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 还有 \n<code>childNodes</code>，这是一个 \n<code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> 对象列表。 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 派生自 \n<code><a href=\"api/core/DebugNode\" class=\"code-anchor\">DebugNode</a></code> 对象，并且通常节点比元素多。测试人员通常可以忽略普通节点。</p>\n      </div>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>parent</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bb8t1axgim63ora2r1jvqi95v\"><code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 父元素。如果这是根元素，则为 null。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>name</code>\n    </td>\n    <td data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8m3uacixicm3xhijvl1gz1euh\">元素令牌名称（如果是元素）。</td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>triggerEventHandler</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qwuxzqwfaqjlpxyb8xxp3g7m\">如果元素的 \n<code>listeners</code> 集合中存在相应的监听器，则按其名称触发事件。 第二个参数是处理程序期望的 \n<em>事件对象</em>。 请参阅 \n<a href=\"guide/testing#trigger-event-handler\">此处</a>.</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bah34cwxlfllyf2jpcoh8gck7\">如果事件缺少监听器或存在其他问题， 请考虑调用 \n<code>nativeElement.dispatchEvent(eventObject)</code>。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>listeners</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7u1nehjgwkm0mak5cwjvpwiim\">附加到组件的 \n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 属性和/或元素的事件属性的回调。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>providerTokens</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5due6oge0lqufmpj72ll14g0a\">此组件的注入器查找令牌。 包括组件本身以及组件在其 \n<code>providers</code> 元数据中列出的令牌。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>source</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c7lcmcwim9iwpl92zy0tpdn9\">在源组件模板中查找此元素的位置。</p>\n    </td>\n  </tr>\n  <tr>\n    <td style=\"vertical-align: top\">\n      <code>references</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7n75l7dicwpjm2h6pbzwimwsr\">与模板局部变量（例如 \n<code>#foo</code>）关联的对象字典， 以局部变量名称为键。</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"query-predicate\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"k0pcf628o2bvzper9ap3gnko\"><code>DebugElement.query(predicate)</code> 和 \n<code>DebugElement.queryAll(predicate)</code> 方法接受一个 谓词，该谓词会过滤源元素的子树以查找匹配的 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7khwhyi0djva20qs82kiizt8k\">谓词是任何接受 \n<code><a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a></code> 并返回 \n<em>真值</em> 的方法。 以下示例查找所有具有对名为 \"content\" 的模板局部变量的引用的 \n<code>DebugElements</code>：</p>\n<code-example path=\"testing/src/app/demo/demo.testbed.spec.ts\" region=\"custom-predicate\" title=\"app/demo/demo.testbed.spec.ts\" linenums=\"false\">\n// Filter for DebugElements with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> #content reference\nconst contentRefs = el.queryAll( de =&gt; de.references['content']);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2g7nx3c239ssvmer9ummwxmd1\">Angular \n<code><a href=\"api/platform-browser/By\" class=\"code-anchor\">By</a></code> 类具有三种用于常见谓词的静态方法：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2z3estkkci4lveyotsrms5chp\"><code>By.all</code> - 返回所有元素。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84gcezv8njq80cbcou501ormu\"><code>By.css(selector)</code> - 返回与 CSS 选择器匹配的元素。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5eqhc3tiik96h8yfw9qoebtml\"><code>By.directive(directive)</code> - 返回 Angular 与指令类实例匹配的元素。</li>\n</ul>\n<code-example path=\"testing/src/app/hero/hero-list.component.spec.ts\" region=\"by\" title=\"app/hero/hero-list.component.spec.ts\" linenums=\"false\">\n// Can find <a href=\"api/core/DebugElement\" class=\"code-anchor\">DebugElement</a> either by css selector or by directive\nconst h2        = fixture.debugElement.query(By.css('h2'));\nconst directive = fixture.debugElement.query(By.directive(HighlightDirective));\n\n</code-example>\n<hr>\n<a id=\"faq\"></a>\n<h2 id=\"frequently-asked-questions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4z2ris4lq84izy0gkq4s2l2gu\"><i class=\"material-icons\">link</i>常见问题解答</h2>\n<a id=\"q-spec-file-location\"></a>\n<h4 id=\"why-put-spec-file-next-to-the-file-it-tests\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4nlf3k6fowll8e5ml6234a1q\"><i class=\"material-icons\">link</i>为什么将规范文件放在它测试的文件旁边？</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1w6h4s3byl6lkb9eziur1dzxy\">最好把单元测试规约文件放到与它们测试的应用源码文件相同的文件夹中：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3w2erdakqbtad9fny756yqwhh\">这样更容易找到测试。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1dk3sys6a7el9dm3f84lfrjb0\">你可以一目了然地看到应用程序的哪个部分缺少测试。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72iwopoe1ftffpx1s1bf4o6p0\">附近的测试可以揭示某个部分在上下文中的工作方式。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2oyzhvxvz4imqqnwd1xs9t318\">当你移动源代码（不可避免）时，你会记得移动测试。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5x1m04heqsitsd10tc39e2ybn\">当你重命名源文件（不可避免）时，你会记得重命名测试文件。</li>\n</ul>\n<hr>\n<a id=\"q-specs-in-test-folder\"></a>\n<h4 id=\"when-would-i-put-specs-in-a-test-folder\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vw00xiyu82t2jc46qjpvfquj\"><i class=\"material-icons\">link</i>什么时候我会将规范放在测试文件夹中？</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c65r6dw3b922y9gk4sfd2we3g\">应用的集成测试规范可以测试跨文件夹和模块的多个部分之间的交互。它们并不属于任何一个特定的部分，所以把它们放在任何一个文件旁都很不自然。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8dur4tu2f3hv2gydei57rqnmy\">最好在 <code>tests</code> 目录下为它们创建一个合适的文件夹。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"byv0pfv3h0bcohahbdnchd4lt\">当然，用来测试那些测试助手的规约也位于 <code>test</code> 目录下，紧挨着相应的测试助手文件。</p>\n<a id=\"q-e2e\"></a>\n<h4 id=\"why-not-rely-on-e2e-tests-of-dom-integration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7apfulm4e4lye65m48jxntlbc\"><i class=\"material-icons\">link</i>为什么不依赖于 DOM 集成的 E2E 测试？</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6jjvwkzdl8ixhoc1zghacdsfq\">本指南中描述的组件 DOM 测试通常需要大量的设置和高级技术，而 \n<a href=\"guide/testing#component-class-testing\">仅限类的测试</a> 相对简单。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9zupuasmtqt4egsrifkfk045i\">为什么不将 DOM 集成测试推迟到端到端 (E2E) 测试？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93gx09qdeoqr6313ldhtmlli0\">E2E 测试非常适合对整个系统进行高级验证。但它们无法提供你从单元测试中期望的全面测试覆盖率。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ambjxzm6v4aargtre7w9m2l6\">与单元测试相比，E2E 测试难以编写且性能较差。它们很容易出现故障，通常是由于远离故障位置的更改或错误行为造成的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bj9jbgl8zluos9992gykyhpqo\">E2E 测试无法轻松地揭示组件在出现问题时的行为，例如缺少或错误的数据、连接丢失以及远程服务故障。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qyl9hptq0jh3j8jtich592bn\">更新数据库、发送发票或收取信用卡的应用程序的 E2E 测试需要特殊的技巧和后门，以防止意外损坏远程资源。甚至很难导航到要测试的组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rsxj9ur15p1fq3sgfwyy27pm\">由于存在这些障碍，你应该尽可能使用单元测试技术来测试 DOM 交互。</p>\n\n</div>\n<!-- links to this doc:\n - guide/architecture-next-steps\n - guide/dependency-injection\n - guide/setup-systemjs-anatomy\n-->\n<!-- links from this doc:\n - api/animations/browser\n - api/animations/query\n - api/animations/trigger\n - api/common/AsyncPipe\n - api/common/CommonModule\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/TitleCasePipe\n - api/common/UpperCasePipe\n - api/common/http/HttpClient\n - api/common/http/HttpErrorResponse\n - api/common/http/testing/HttpClientTestingModule\n - api/core/ChangeDetectionStrategy#OnPush\n - api/core/ChangeDetectorRef\n - api/core/Component\n - api/core/Component#styleUrls\n - api/core/Component#styles\n - api/core/Component#template\n - api/core/Component#templateUrl\n - api/core/DebugElement\n - api/core/DebugElement#nativeElement\n - api/core/DebugElement#properties\n - api/core/DebugElement#query\n - api/core/DebugElement#styles\n - api/core/DebugNode\n - api/core/Directive\n - api/core/ElementRef\n - api/core/EventEmitter\n - api/core/Inject\n - api/core/Injectable\n - api/core/Input\n - api/core/NO_ERRORS_SCHEMA\n - api/core/NgModule\n - api/core/OnChanges\n - api/core/OnInit\n - api/core/Output\n - api/core/Pipe\n - api/core/PipeTransform\n - api/core/PlatformRef\n - api/core/Predicate\n - api/core/SchemaMetadata\n - api/core/testing/ComponentFixture\n - api/core/testing/ComponentFixture#nativeElement\n - api/core/testing/ComponentFixtureAutoDetect\n - api/core/testing/MetadataOverride\n - api/core/testing/TestBed\n - api/core/testing/TestModuleMetadata\n - api/core/testing/async\n - api/core/testing/discardPeriodicTasks\n - api/core/testing/fakeAsync\n - api/core/testing/flush\n - api/core/testing/flushMicrotasks\n - api/core/testing/getTestBed\n - api/core/testing/inject\n - api/core/testing/tick\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/http/HttpModule\n - api/platform-browser/BrowserModule\n - api/platform-browser/By\n - api/platform-browser/By#css\n - api/platform-browser/Title\n - api/router/ActivatedRoute\n - api/router/ActivatedRoute#paramMap\n - api/router/ParamMap\n - api/router/Params\n - api/router/Router\n - api/router/Router#events\n - api/router/RouterLink\n - api/router/RouterLinkWithHref\n - api/router/RouterModule\n - api/router/RouterOutlet\n - api/router/convertToParamMap\n - api/router/testing/RouterTestingModule\n - guide/dependency-injection\n - guide/feature-modules\n - guide/http\n - guide/http#testing-http-requests\n - guide/lifecycle-hooks\n - guide/ngmodules\n - guide/router#route-parameters\n - guide/testing#activatedroutestub\n - guide/testing#always-get-the-service-from-an-injector\n - guide/testing#angular-testbed\n - guide/testing#async\n - guide/testing#async-observable-helpers\n - guide/testing#async-observables\n - guide/testing#async-test-with-async\n - guide/testing#async-test-with-fakeasync\n - guide/testing#attribute-directive-testing\n - guide/testing#automatic-change-detection\n - guide/testing#beforeeach\n - guide/testing#bycss\n - guide/testing#bydirective-and-injected-directives\n - guide/testing#calling-compilecomponents\n - guide/testing#change-an-input-value-with-dispatchevent\n - guide/testing#cli-generated-tests\n - guide/testing#click-helper\n - guide/testing#click-the-element\n - guide/testing#clicking\n - guide/testing#cold-observable\n - guide/testing#compile-components\n - guide/testing#compilecomponents-is-async\n - guide/testing#compilecomponents-is-harmless\n - guide/testing#component-binding\n - guide/testing#component-class-testing\n - guide/testing#component-dom-testing\n - guide/testing#component-fixture\n - guide/testing#component-fixture-api-summary\n - guide/testing#component-inside-a-test-host\n - guide/testing#component-marble-tests\n - guide/testing#component-override\n - guide/testing#component-test-basics\n - guide/testing#component-test-scenarios\n - guide/testing#component-with-a-dependency\n - guide/testing#component-with-async-service\n - guide/testing#component-with-external-files\n - guide/testing#component-with-inputs-and-outputs\n - guide/testing#componentfixture\n - guide/testing#componentfixture-methods\n - guide/testing#componentfixture-properties\n - guide/testing#components-with-routerlink\n - guide/testing#configuration\n - guide/testing#consolidated-setup\n - guide/testing#createcomponent\n - guide/testing#createcomponent-does-not-bind-data\n - guide/testing#dashboard-hero-component\n - guide/testing#debug-element-details\n - guide/testing#debugelement\n - guide/testing#debugelement-1\n - guide/testing#detectchanges\n - guide/testing#fake-async\n - guide/testing#feature-module-import\n - guide/testing#final-setup-and-tests\n - guide/testing#frequently-asked-questions\n - guide/testing#get-injected-services\n - guide/testing#httpclienttestingmodule\n - guide/testing#import-a-feature-module\n - guide/testing#import-a-shared-module\n - guide/testing#jasmine-done\n - guide/testing#learn-about-marble-testing\n - guide/testing#marble-error-testing\n - guide/testing#marble-frame\n - guide/testing#marble-testing\n - guide/testing#metadata-override-object\n - guide/testing#more-async-tests\n - guide/testing#more-overrides\n - guide/testing#nativeelement\n - guide/testing#nested-component-tests\n - guide/testing#no_errors_schema\n - guide/testing#other-test-frameworks\n - guide/testing#override-component-providers\n - guide/testing#page-object\n - guide/testing#pipe-testing\n - guide/testing#provide-a-spy-stub-herodetailservicespy\n - guide/testing#provide-service-test-doubles\n - guide/testing#query-for-the-h1\n - guide/testing#query-predicate\n - guide/testing#reduce-the-setup\n - guide/testing#routed-components\n - guide/testing#routerlink\n - guide/testing#routing-component\n - guide/testing#service-tests\n - guide/testing#services-with-dependencies\n - guide/testing#setup\n - guide/testing#setup-with-module-imports\n - guide/testing#spy-stub\n - guide/testing#stubbing-unneeded-components\n - guide/testing#synchronous-tests\n - guide/testing#test-dashboardherocomponent-stand-alone\n - guide/testing#test-debugging\n - guide/testing#test-file-name-and-location\n - guide/testing#testbed-api-summary\n - guide/testing#testbed-class-summary\n - guide/testing#testbedget\n - guide/testing#testing\n - guide/testing#testing-http-services\n - guide/testing#testing-services-with-the-testbed\n - guide/testing#testing-utility-apis\n - guide/testing#testing-with-a-spy\n - guide/testing#testing-with-activatedroutestub\n - guide/testing#testing-without-beforeeach\n - guide/testing#tests-w-test-double\n - guide/testing#the-async-beforeeach\n - guide/testing#the-componentfixture\n - guide/testing#the-override-tests\n - guide/testing#the-overridecomponent-method\n - guide/testing#the-synchronous-beforeeach\n - guide/testing#the-tick-function\n - guide/testing#tick\n - guide/testing#trigger-event-handler\n - guide/testing#triggereventhandler\n - guide/testing#use-a-page-object\n - guide/testing#use-both-techniques-together\n - guide/testing#what-good-are-these-tests\n - guide/testing#when-stable\n - guide/testing#when-would-i-put-specs-in-a-test-folder\n - guide/testing#whenstable\n - guide/testing#why-not-rely-on-e2e-tests-of-dom-integration\n - guide/testing#why-put-spec-file-next-to-the-file-it-tests\n - guide/testing#why-stubbed-routerlink-tests\n - guide/testing#write-dom-tests-too\n - tutorial\n - http://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support\n - http://jasmine.github.io/2.4/introduction.html\n - http://plnkr.co/\n - http://reactivex.io/documentation/operators/defer.html\n - http://rxmarbles.com/\n - https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n - https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API\n - https://developer.mozilla.org/en-US/docs/Web/CSS/:not\n - https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_started/Selectors\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\n - https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md\n - https://github.com/angular/devkit\n - https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n - https://jasmine.github.io/2.0/introduction.html#section-Spies\n - https://karma-runner.github.io/1.0/index.html\n-->"
}