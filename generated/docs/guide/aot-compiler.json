{
  "id" : "guide/aot-compiler",
  "title" : "预先编译 (AOT) 编译器",
  "contents" : "<div class=\"content\">\n<h1 id=\"the-ahead-of-time-aot-compiler\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9p8bxyo8tvim1ieoe2kkm0cyd\"><i class=\"material-icons\">link</i>预先编译 (AOT) 编译器</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9o79shzbsktdtr79g8f8fh3fw\">Angular 预先编译 (AOT) 编译器在浏览器下载并运行代码\n<em>之前</em>，在构建阶段将你的 Angular HTML 和 TypeScript 代码转换为高效的 JavaScript 代码。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ge9yku5t16qrlc314h30ane3\">本指南介绍了如何使用不同的编译器选项使用 AOT 编译器进行构建，以及如何编写 AOT 可以编译的 Angular 元数据。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3pd9ualg3qya10don20bqz4a5\"><a href=\"https://www.youtube.com/watch?v=kW9cJsvcsGo\">观看编译器作者 Tobias Bosch 在 AngularConnect 2016 上解释 Angular 编译器</a>。</p>\n</div>\n<a id=\"overview\"></a>\n<h2 id=\"angular-compilation\">Angular compilation</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13x97t7kom8rhan0thqqqdkw0\">Angular 应用程序主要由组件及其 HTML 模板组成。 在浏览器可以渲染应用程序之前， 组件和模板必须由\n<em>Angular 编译器</em>转换为可执行的 JavaScript。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7tmjeukt2ijvkq5fzld60dksf\">Angular 提供了两种方式来编译你的应用：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5zbmnyt3ejpn6l5abb06x9i0j\"><strong><em>即时</em> (JIT)</strong>，在运行时在浏览器中编译你的应用程序</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0jiessusnt56xgr4sv4yattl\"><strong><em>预先</em> (AOT)</strong>，在构建时编译你的应用程序。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2mtwrbz0nke4qi4157v0qo6g5\">当你运行\n<em>仅构建</em>或\n<em>构建并本地服务</em> CLI 命令时，JIT 编译是默认的：</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng build\n  ng serve\n</code-example>\n<a id=\"compile\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbmg44u0hvj5ebsn5sna5m1be\">对于 AOT 编译，将 \n<code>--aot</code> 标志附加到\n<em>仅构建</em>或\n<em>构建并本地服务</em> CLI 命令：</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng build --aot\n  ng serve --aot\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9grqddlgh29eb47vop760ev9f\"><code>--prod</code> 元标志默认情况下使用 AOT 进行编译。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3qls5um8haukss9w2uf8pbot\">有关详细信息，请参阅 \n<a href=\"https://github.com/angular/angular-cli/wiki\">CLI 文档</a>，尤其是 \n<a href=\"https://github.com/angular/angular-cli/wiki/build\"><code>build</code> 主题</a>。</p>\n</div>\n<a id=\"why-aot\"></a>\n<h2 id=\"why-compile-with-aot\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e34uql48a2nf8k0co484axeyq\"><i class=\"material-icons\">link</i>为什么要使用 AOT 进行编译？</h2>\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"50yas5hchrolvftacmen7qcip\">更快的渲染</em></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2igz0j4qq2jkk21ee0hscxuiv\">使用 AOT，浏览器会下载应用程序的预编译版本。 浏览器加载可执行代码，因此它可以立即渲染应用程序，而无需等待先编译应用程序。</p>\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qw9t9851prcg2xm3dx5fdjwp\">更少的异步请求</em></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2gwzdeyv3qtldpyeyn3hbtbg1\">编译器将外部 HTML 模板和 CSS 样式表\n<em>内联</em>到应用程序 JavaScript 中， 从而消除了对这些源文件的单独 ajax 请求。</p>\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fdxpt550vicfbbcri4m76afc\">更小的 Angular 框架下载大小</em></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aojov9hbgl3m00n22ov39nv7o\">如果应用程序已经编译，则无需下载 Angular 编译器。 编译器大约是 Angular 本身的一半，因此省略它会大大减少应用程序负载。</p>\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4lqtwpylqmhgjuvpdbq9aq9hc\">更早地检测模板错误</em></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4yjbmh7wrfdr1rr68jytb5tm0\">AOT 编译器在构建步骤中检测并报告模板绑定错误， 在用户看到它们之前。</p>\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"29jgs05nbj8s9dyo4ys70vpfx\">更好的安全性</em></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4o3zhin6rbf61mz4yf76dbs1m\">AOT 将 HTML 模板和组件编译成 JavaScript 文件，时间远早于它们被提供给客户端。 由于没有模板可读，也没有危险的客户端 HTML 或 JavaScript 评估， 因此注入攻击的机会更少。</p>\n<a id=\"compiler-options\"></a>\n<h2 id=\"angular-compiler-options\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2v0kkqvyev97ta0i0h8umsfo\"><i class=\"material-icons\">link</i>Angular 编译器选项</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59z81vbuyz7jy0ijyrigog662\">你可以通过在 \n<code>tsconfig.json</code> 文件中提供模板编译器选项以及提供给 TypeScript 编译器的选项来控制应用程序编译。模板编译器选项被指定为 \n<code>\"angularCompilerOptions\"</code> 对象的成员，如下所示：</p>\n<code-example language=\"json\">\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    ...\n  },\n  \"angularCompilerOptions\": {\n    \"fullTemplateTypeCheck\": true,\n    \"preserveWhitespaces\": false,\n    ...\n  }\n}\n</code-example>\n<h3 id=\"skipmetadataemit\"><em>skipMetadataEmit</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9g7dee8p4j2d1jzz566iohvir\">此选项告诉编译器不要生成 \n<code>.metadata.json</code> 文件。 此选项默认情况下为 \n<code>false</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bexpljjypom42qo87eok349y2\"><code>.metadata.json</code> 文件包含模板编译器从 \n<code>.ts</code> 文件中需要的，但未包含在 TypeScript 编译器生成的 \n<code>.d.ts</code> 文件中的信息。此信息包含， 例如，注释的内容（例如组件的模板），TypeScript 会将其输出到 \n<code>.js</code> 文件，但不会输出到 \n<code>.d.ts</code> 文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vc4i1r2fikasib0j0moveatz\">如果使用 TypeScript 的 \n<code>--outFile</code> 选项，则应将此选项设置为 \n<code>true</code>，因为元数据文件 对于这种类型的 TypeScript 输出无效。不建议将 \n<code>--outFile</code> 与 Angular 一起使用。请改用捆绑器，例如 \n<a href=\"https://webpack.js.org/\">webpack</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wesouwmqb0yut21lxdya6wcn\">当使用工厂摘要时，此选项也可以设置为 \n<code>true</code>，因为工厂摘要 包含 \n<code>.metadata.json</code> 文件中信息的副本。</p>\n<h3 id=\"strictmetadataemit\"><em>strictMetadataEmit</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmv4epqqxmv6iy4iyoaw3yj1m\">此选项告诉模板编译器如果 \n<code>\"skipMetadataEmit\"</code> 为 \n<code>false</code>，则向 \n<code>.metadata.json</code> 文件报告错误。此选项默认情况下为 \n<code>false</code>。这仅应在 \n<code>\"skipMetadataEmit\"</code> 为 \n<code>false</code> 且 \n<code>\"skipTemplateCodeGen\"</code> 为 \n<code>true</code> 时使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7neuhijuv7pgbqocv6o9v98t7\">它旨在验证为使用 \n<code>npm</code> 包进行捆绑而发出的 \n<code>.metadata.json</code> 文件。验证过于严格，可能会为元数据发出错误，而这些元数据在模板编译器使用时永远不会产生错误。你可以选择通过在记录符号的注释中包含 \n<code>@dynamic</code> 来抑制此选项发出的错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2jr067bwx5tdpx5o9btazm8no\"><code>.metadata.json</code> 文件中包含错误是有效的。如果元数据用于确定注释的内容，模板编译器会报告这些错误。元数据 收集器无法预测在注释中使用的符号，因此它会为导出的符号预先 在元数据中包含错误节点。然后，模板编译器可以使用错误 节点来报告错误，如果这些符号被使用。如果库的客户端打算在注释中使用符号，模板编译器通常不会报告 这种情况，直到客户端使用该符号。此选项允许在库的构建阶段检测这些错误，例如，在生成 Angular 库本身时使用。</p>\n<h3 id=\"skiptemplatecodegen\"><em>skipTemplateCodegen</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7x4upvadevyapjklnjvcu95q6\">此选项告诉编译器抑制发出 \n<code>.ngfactory.js</code> 和 \n<code>.ngstyle.js</code> 文件。设置后， 这会关闭大多数模板编译器并禁用报告模板诊断。 此选项可用于指示 模板编译器为使用 \n<code>npm</code> 包进行分发生成 \n<code>.metadata.json</code> 文件，同时 避免生成无法分发到 \n<code>npm</code> 的 \n<code>.ngfactory.js</code> 和 \n<code>.ngstyle.js</code> 文件。</p>\n<h3 id=\"strictinjectionparameters\"><em>strictInjectionParameters</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9l4zxmsg7n1wv8nec5w2i0a4p\">当设置为 \n<code>true</code> 时，此选项告诉编译器为提供的参数报告错误， 其注入类型无法确定。当此值选项未提供或为 \n<code>false</code> 时，用 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 标记的类的构造函数参数，其类型无法解析，将 产生警告。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chh7ryqh8hd735nfpj5sp5y2v\"><em>注意</em>：建议明确将此选项更改为 \n<code>true</code>，因为此选项将来将默认设置为 \n<code>true</code>。</p>\n<h3 id=\"flatmoduleoutfile\"><em>flatModuleOutFile</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aieel1sz4mz0us3gd2ipzee7s\">当设置为 \n<code>true</code> 时，此选项告诉模板编译器生成给定文件名的扁平模块 索引以及相应的扁平模块元数据。在创建 与 \n<code>@angular/core</code> 和 \n<code>@angular/common</code> 类似打包的扁平模块时，使用此选项。当此选项 使用时，库的 \n<code>package.json</code> 应引用 生成的扁平模块索引，而不是库索引文件。使用此 选项，只生成一个 \n<code>.metadata.json</code> 文件，其中包含从库索引导出的符号所需的所有元数据。在生成的 \n<code>.ngfactory.js</code> 文件中，扁平 模块索引用于导入符号，其中包括来自库索引的公共 API 以及隐藏的内部符号。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9zzgu83rhf84r34cmf71ih8l3\">默认情况下，\n<code>files</code> 字段中提供的 \n<code>.ts</code> 文件被认为是库索引。 如果指定了多个 \n<code>.ts</code> 文件，则 \n<code>libraryIndex</code> 用于选择要使用的文件。 如果提供了多个 \n<code>.ts</code> 文件但没有 \n<code>libraryIndex</code>，则会产生错误。一个扁平模块索引 \n<code>.d.ts</code> 和 \n<code>.js</code> 将使用给定的 \n<code>flatModuleOutFile</code> 名称在与库索引 \n<code>.d.ts</code> 文件相同的位置创建。例如，如果库使用 \n<code>public_api.ts</code> 文件作为模块的库索引，则 \n<code>tsconfig.json</code> 的 \n<code>files</code> 字段 将是 \n<code>[\"public_api.ts\"]</code>。然后，\n<code>flatModuleOutFile</code> 选项可以设置为例如 \n<code>\"index.js\"</code>，这将生成 \n<code>index.d.ts</code> 和 \n<code>index.metadata.json</code> 文件。库的 \n<code>package.json</code> 的 \n<code>module</code> 字段将是 \n<code>\"index.js\"</code>，而 \n<code>typings</code> 字段 将是 \n<code>\"index.d.ts\"</code>。</p>\n<h3 id=\"flatmoduleid\"><em>flatModuleId</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9g7sea9j1iy526wq1onsi3d5y\">此选项指定用于导入扁平模块的首选模块 ID。 模板编译器生成的引用将在从扁平模块导入符号时使用此模块名称。 这只有在也提供了 \n<code>flatModuleOutFile</code> 时才有意义。否则，编译器会忽略 此选项。</p>\n<h3 id=\"generatecodeforlibraries\"><em>generateCodeForLibraries</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjhxkz9wr7ufzh4gnjzazs81b\">此选项告诉模板编译器为具有相应 \n<code>.metadata.json</code> 文件的 \n<code>.d.ts</code> 文件生成工厂文件（\n<code>.ngfactory.js</code> 和 \n<code>.ngstyle.js</code>）。此选项默认为 \n<code>true</code>。当此选项为 \n<code>false</code> 时，仅为 \n<code>.ts</code> 文件生成工厂文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"473ko5fg2iir13ipb56snu5x3\">使用工厂摘要时，此选项应设置为 \n<code>false</code>。</p>\n<h3 id=\"fulltemplatetypecheck\"><em>fullTemplateTypeCheck</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ehr2g46zsr7fb5yzbef69s86n\">此选项告诉编译器启用模板编译器的 \n<a href=\"guide/aot-compiler#binding-expresion-validation\">绑定表达式验证</a> 阶段，该阶段使用 TypeScript 来验证绑定表达式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tc2aie9v32qh9u4n7k903ce9\">此选项默认情况下为 \n<code>false</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"84zbobdld9kqjve1q7h06mpff\"><em>注意</em>：建议将此设置为 \n<code>true</code>，因为此选项将来将默认设置为 \n<code>true</code>。</p>\n<h3 id=\"annotateforclosurecompiler\"><em>annotateForClosureCompiler</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5r6aqyy6z1srnbvpvlsozxlko\">此选项告诉编译器使用 \n<a href=\"https://github.com/angular/tsickle\">Tsickle</a> 来用 \n<a href=\"http://usejsdoc.org/\">JsDoc</a> 注释对发出的 JavaScript 进行注释，这些注释是 \n<a href=\"https://github.com/google/closure-compiler\">Closure Compiler</a> 所需的。此选项默认为 \n<code>false</code>。</p>\n<h3 id=\"annotationsas\"><em>annotationsAs</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnewla0xrax8unjvk40nibncq\">使用此选项修改 Angular 特定注释的发出方式，以改进摇树优化。非 Angular 注释和装饰器不受影响。默认值为 \n<code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> fields</code>。</p>\n<table>\n<thead>\n<tr>\n<th>value</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>decorators</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qyzw7o0lc84snr2h63wve9sg\">将装饰器保留在原位。这使得编译更快。TypeScript 将发出对 __decorate 帮助程序的调用。使用 \n<code>--emitDecoratorMetadata</code> 用于运行时反射。但是，生成的代码将无法正确地进行摇树优化。</td>\n</tr>\n<tr>\n<td><code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> fields</code></td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66pz9x9hljqnaod17dge6uqp7\">用类中的静态字段替换装饰器。允许高级摇树优化器（如 \n<a href=\"https://github.com/google/closure-compiler\">Closure Compiler</a> ）删除未使用的类。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"trace\"><em>trace</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6q8c2wu92az7jg1xehcv3kfbg\">这告诉编译器在编译模板时打印额外的信息。</p>\n<h3 id=\"enablelegacytemplate\"><em>enableLegacyTemplate</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgy5t6qufka3mgjrrnwwfe1yb\">从 Angular 4.0 开始，\n<code>&lt;template&gt;</code> 元素的使用已弃用，取而代之的是使用 \n<code>&lt;ng-template&gt;</code> 以避免与同名的 DOM 元素发生冲突。将此选项设置为 \n<code>true</code> 启用已弃用的 \n<code>&lt;template&gt;</code> 元素的使用。此选项 默认情况下为 \n<code>false</code>。某些第三方 Angular 库可能需要此选项。</p>\n<h3 id=\"disableexpressionlowering\"><em>disableExpressionLowering</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4lkveuk58sus4apmp6wkqqor\">Angular 模板编译器转换在注释中使用或可能使用的代码，以允许从模板工厂模块导入它。见 \n<a href=\"guide/aot-compiler#metadata-rewriting\">元数据重写</a> 以获取更多信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7lo97q5jbi8uqtwzw3lqiizn5\">将此选项设置为 \n<code>false</code> 将禁用此重写，需要手动完成重写。</p>\n<h3 id=\"preservewhitespaces\"><em>preserveWhitespaces</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25hz6ul3m6zrewxuwvacqanjt\">此选项告诉编译器是否从已编译的模板中删除空白文本节点。 此选项默认情况下为 \n<code>true</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0avbvgsuozvl68bn2027msn4\"><em>注意</em>：建议明确地将此设置为 \n<code>false</code>，因为它会发出更小的模板工厂模块，并且将来可能会默认设置为 \n<code>false</code>。</p>\n<h3 id=\"allowemptycodegenfiles\"><em>allowEmptyCodegenFiles</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"escro6z2p1jk6fa3xgcwwi0cl\">告诉编译器生成所有可能的生成文件，即使它们为空。此选项 默认情况下为 \n<code>false</code>。这是 \n<code>bazel</code> 构建规则使用的选项，并且需要简化 \n<code>bazel</code> 规则跟踪文件依赖项的方式。不建议在 \n<code>bazel</code> 规则之外使用此选项。</p>\n<h2 id=\"angular-metadata-and-aot\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"awj1zyg4v0rn3qdvrz6fd7ssf\"><i class=\"material-icons\">link</i>Angular 元数据和 AOT</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fqg871gm7ok00oiwgrgqpoi9\">Angular \n<strong>AOT 编译器</strong>提取并解释 Angular 应该管理的应用程序部分的 \n<strong>元数据</strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cpssrlcjbf9j57ns9ivu4ojso\">Angular 元数据告诉 Angular 如何构造应用程序类的实例并在运行时与它们交互。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7qehrvikpksu3zzcrz4y2bpjb\">使用 \n<strong>装饰器</strong>（如 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 和 \n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>）指定元数据。 你还在这些装饰类的构造函数声明中隐式地指定元数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5egctqhwd0u5p9hrxjmetbpqt\">在以下示例中，\n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> 元数据对象和类构造函数告诉 Angular 如何创建和显示 \n<code>TypicalComponent</code> 的实例。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  template: '&lt;div&gt;A typical component for {{data.name}}&lt;/div&gt;'\n)}\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { ... }\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8o0cggrvcqgkzhifhq10c32kk\">Angular 编译器\n<em>一次</em>提取元数据并为 \n<code>TypicalComponent</code> 生成一个\n<em>工厂</em>。 当需要创建 \n<code>TypicalComponent</code> 实例时，Angular 会调用工厂，工厂会生成一个新的可视元素，该元素绑定到组件类的新的实例，并具有其注入的依赖项。</p>\n<h2 id=\"metadata-restrictions\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"e706ncbspohkemcmgs4ogupag\"><i class=\"material-icons\">link</i>元数据的限制</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aan2l7eqmpe37mn1b7ti2upf0\">你用 TypeScript 的\n<em>子集</em>编写元数据，该子集必须符合以下一般约束：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wfr1sbwll1kbr5hb33anazg6\">将 \n<a href=\"guide/aot-compiler#expression-syntax\">表达式语法</a> 限制为支持的 JavaScript 子集。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7v3w2oqrt6cytuc1yztkxjis7\">仅在 \n<a href=\"guide/aot-compiler#folding\">代码折叠</a> 后引用导出的符号。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ew4f3rajw9yx99utm34f1nt6e\">仅调用编译器 \n<a href=\"guide/aot-compiler#supported-functions\">支持的函数</a>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ag3eg7j50dcwyiafmqxkoiria\">装饰的和数据绑定的类成员必须是公共的。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgjmcpbj41nkj3sk42gwnq57d\">接下来的部分将详细说明这些要点。</p>\n<h2 id=\"how-aot-works\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bq8bjvfxhrq96dcf9fhcg9uh3\"><i class=\"material-icons\">link</i>AOT 如何工作</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3lqyo3tdenbnh88muh1t8gvfq\">将 AOT 编译器视为有两个阶段：一个代码分析阶段，它只是记录源代码的表示；以及一个代码生成阶段，其中编译器的 \n<code>StaticReflector</code> 处理解释以及对解释内容进行限制。</p>\n<h2 id=\"phase-1-analysis\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8dxzr7gg8i31t1bxol1tyl9av\"><i class=\"material-icons\">link</i>阶段 1：分析</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4drrrt5vt5thq4a2fx9lsewq4\">TypeScript 编译器执行第一阶段的一些分析工作。它发出 \n<code>.d.ts</code> \n<em>类型定义文件</em>，其中包含 AOT 编译器需要生成应用程序代码的类型信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b5tk5tzg631yicfd59co0vimf\">同时，AOT \n<strong><em>收集器</em></strong> 分析记录在 Angular 装饰器中的元数据，并在 \n<strong><code>.metadata.json</code></strong> 文件中输出元数据信息，每个 \n<code>.d.ts</code> 文件一个。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1o3lgq9ylbxbnas7dl9miwveg\">可以将 \n<code>.metadata.json</code> 视为装饰器元数据的整体结构图，表示为 \n<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">抽象语法树 (AST)</a>。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5d6a8vtu1l7yjojqtei1sfnfp\">Angular 的 \n<a href=\"https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a> 描述 JSON 格式为 TypeScript 接口的集合。</p>\n</div>\n<a id=\"expression-syntax\"></a>\n<h3 id=\"expression-syntax\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2asvuq94sq1fmo1l11qeamcio\"><i class=\"material-icons\">link</i>表达式语法</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nlrak5km619i3fengdq2726x\"><em>收集器</em>只理解 JavaScript 的一个子集。 使用以下有限语法定义元数据对象：</p>\n<table>\n<thead>\n<tr>\n<th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8p44mx807exjp3s0k9dwbuxla\">语法</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"lzz2v4ucg07faxnpe2bu1wa1\">范例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pawdo4v1ftsqb7hgncivrrtr\">字面量对象</td>\n<td><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"celil1s9fvdj5h001ggxww2wg\">字面量数组</td>\n<td><code>['cherries', 'flour', 'sugar']</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jcubru2hcec6y1xoseq584lw\">在字面量数组中展开</td>\n<td><code>['apples', 'flour', ...the_rest]</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajlqvrq9or76b4immqohnkbvt\">调用</td>\n<td><code>bake(ingredients)</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80lep37b3pz9v0caoqb21dem\">新建</td>\n<td><code>new Oven()</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hlklpuzu6n50x3rnyjh8ica5\">属性访问</td>\n<td><code>pie.slice</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8nkjm5j5wf05rwfytv4oe8oi\">数组索引</td>\n<td><code>ingredients[0]</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ya2ti5no4qrlym9hiwjicjjo\">标识符引用</td>\n<td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7dg3oxut0wds57hvogtnhfyr6\">模板字符串</td>\n<td><code>\n`\npie is ${multiplier} times better than cake\n`\n</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6km60trrfnc4j65n50ltmrz6\">字面量字符串</td>\n<td><code>'pi'</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9whhr0otfdhciw4ompg2p3y28\">字面量数字</td>\n<td><code>3.14153265</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3n8z4687qnsdmn5y6xmbmnnxi\">字面量布尔值</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3915mfsp6yfqt6ltma1w5m19h\">字面量 null</td>\n<td><code>null</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qfkr5r9jpuemmic1t6z59ubs\">支持的前缀运算符</td>\n<td><code>!cake</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2l5fsca8nl2lb3sb54z3vdqzi\">支持的二元运算符</td>\n<td><code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> + b</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yferwjkhuahg79erz4z23rnm\">条件运算符</td>\n<td><code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> ? b : c</code></td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99vy3rp3vy14fnojqf6hj1uc7\">圆括号</td>\n<td><code>(<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> + b)</code></td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dafazc9cebh2k0gqt01d8grcu\">如果表达式使用不支持的语法，则\n<em>收集器</em>会将错误节点写入 \n<code>.metadata.json</code> 文件。编译器在需要该元数据来生成应用程序代码时，会报告此错误。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qq43x9moov1bniigbapvoh4z\">如果你希望 \n<code>ngc</code> 立即报告语法错误，而不是生成包含错误的 \n<code>.metadata.json</code> 文件，请在 \n<code>tsconfig</code> 中设置 \n<code>strictMetadataEmit</code> 选项。</p>\n<code-example>\n  \"angularCompilerOptions\": {\n   ...\n   \"strictMetadataEmit\" : true\n }\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"3ac5sprw2ka9jfacn5388cxqb\">Angular 库通过这个选项来确保所有的 Angular <code>.metadata.json</code> 文件都是干净的。当你要构建自己的代码库时，这也同样是一项最佳实践。</p>\n</div>\n<a id=\"function-expression\"></a>\n<a id=\"arrow-functions\"></a>\n<h3 id=\"no-arrow-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmk4vwqqg3ck95hzsdiojv725\"><i class=\"material-icons\">link</i>不支持箭头函数</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e17ey0ff9c8cb1ubt09bym38p\">AOT 编译器不支持 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\">函数表达式</a> 和 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">箭头函数</a>（也称为\n<em>lambda</em> 函数）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"v429s9ycivh9f3gg5fph1ota\">考虑如下组件装饰器：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: () =&gt; new Server()}]\n})\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3dfjbipbrm49o6xv9wbhtirk9\">AOT \n<em>收集器</em>不支持元数据表达式中的箭头函数 \n<code>() =&gt; new Server()</code>。 它会在函数位置生成一个错误节点。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ev04zu1j6mnzh094s8f2at2f\">当编译器稍后解释此节点时，它会报告一个错误，提示你将箭头函数转换为\n<em>导出函数</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1sadqhpcharplmexeezc3ksd\">你可以把它改写成这样来修复这个错误：</p>\n<code-example language=\"typescript\">\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: serverFactory}]\n})\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9b05xudvobq6y58f1ukzr6wiq\">从版本 5 开始，编译器在发出 \n<code>.js</code> 文件时会自动执行此重写操作。</p>\n<a id=\"function-calls\"></a>\n<h3 id=\"limited-function-calls\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4vrcko0s73eza51vd428bkqr9\"><i class=\"material-icons\">link</i>有限的函数调用</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ndc5skyx9dqix3ucjgyw8t87\">只要语法有效，\n<em>收集器</em>就可以用 \n<code>new</code> 表示函数调用或对象创建。\n<em>收集器</em>只关心语法是否正确。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91islsrgqpc4y4476th419yql\">但要注意。编译器可能稍后拒绝生成对\n<em>特定</em>函数的调用或对\n<em>特定</em>对象的创建。 编译器只支持对一小部分函数的调用，并且只对少数指定类使用 \n<code>new</code>。这些函数和类在 \n<a href=\"guide/aot-compiler#supported-functions\">下面的表格</a> 中。</p>\n<h3 id=\"folding\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3i2t7zgw2h0u8tu0yumhycglh\"><i class=\"material-icons\">link</i>折叠</h3>\n<a id=\"exported-symbols\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5dikcj8rk6x34a15edd5ovoh\">编译器只能解析对\n<strong><em>导出</em></strong>符号的引用。 幸运的是，\n<em>收集器</em>通过\n<em>折叠</em>支持有限地使用非导出符号。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rfyb4kef0x2ppw4zns25aydu\"><em>收集器</em>可能能够在收集期间计算表达式，并将结果记录在 \n<code>.metadata.json</code> 中，而不是原始表达式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwv80d4qaaphmcm4n6c5hab08\">例如，\n<em>收集器</em>可以计算表达式 \n<code>1 + 2 + 3 + 4</code> 并将其替换为结果 \n<code>10</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2bgigmcayded54somoonrkzga\">此过程称为\n<em>折叠</em>。可以以这种方式简化的表达式是\n<em>可折叠的</em>。</p>\n<a id=\"var-declaration\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad8i0zueotjizj3dpaqvnbaqe\">收集器可以计算对模块局部 \n<code>const</code> 声明和已初始化的 \n<code>var</code> 和 \n<code>let</code> 声明的引用，从而有效地将它们从 \n<code>.metadata.json</code> 文件中删除。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bmvammydlsjz5rief6bf16fep\">考虑下列组件定义：</p>\n<code-example language=\"typescript\">\nconst template = '&lt;div&gt;{{hero.name}}&lt;/div&gt;';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jcehryk4yp9lja7fyxyupj88\">编译器无法引用 \n<code>template</code> 常量，因为它没有导出。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6b9sm2h2jiczahg697ikyt5w3\">但\n<em>收集器</em>可以通过内联其内容将 \n<code>template</code> 常量\n<em>折叠</em>到元数据定义中。 效果与你编写以下内容相同：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: '&lt;div&gt;{{hero.name}}&lt;/div&gt;'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekrp7dvp100dbq8yjxs1msfle\">不再有对 \n<code>template</code> 的引用，因此，当编译器稍后解释 \n<code>.metadata.json</code> 中\n<em>收集器</em>的输出时，不会出现任何问题。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"245sbav4ip29byr0ft4ji202p\">你还可以通过把 <code>template</code> 常量包含在其它表达式中来让这个例子深入一点：</p>\n<code-example language=\"typescript\">\nconst template = '&lt;div&gt;{{hero.name}}&lt;/div&gt;';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template + '&lt;div&gt;{{hero.title}}&lt;/div&gt;'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0b9sf5gb96pxkt85fhki3c6c\"><em>收集器</em>将此表达式简化为等效的\n<em>折叠</em>字符串：</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cuuqi7i0rq5uupqzntkabx4s\"><code>'&lt;div&gt;{{hero.name}}&lt;/div&gt;&lt;div&gt;{{hero.title}}&lt;/div&gt;'</code>。</p>\n<h4 id=\"foldable-syntax\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66w5yow6rvxff09rca2895ux1\"><i class=\"material-icons\">link</i>可折叠语法</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ddc3kl3jx4o9uhs85nfcudv4\">下表描述了\n<em>收集器</em>可以折叠和不能折叠的表达式：</p>\n<table>\n<thead>\n<tr>\n<th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8p44mx807exjp3s0k9dwbuxla\">语法</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8js8rcvbhx832x0aa5btafxm0\">可折叠</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pawdo4v1ftsqb7hgncivrrtr\">字面量对象</td>\n<td>yes</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"celil1s9fvdj5h001ggxww2wg\">字面量数组</td>\n<td>yes</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jcubru2hcec6y1xoseq584lw\">在字面量数组中展开</td>\n<td>no</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ajlqvrq9or76b4immqohnkbvt\">调用</td>\n<td>no</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80lep37b3pz9v0caoqb21dem\">新建</td>\n<td>no</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8hlklpuzu6n50x3rnyjh8ica5\">属性访问</td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eu2xtjafpdelexixad8s29kiu\">是，如果目标是可折叠的</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8nkjm5j5wf05rwfytv4oe8oi\">数组索引</td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"606o23hk8xjq0aqug6gp3ysxk\">是，如果目标和索引是可折叠的</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ya2ti5no4qrlym9hiwjicjjo\">标识符引用</td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a621jxv32k4getbglk8v5t158\">是，如果它是对局部的引用</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2x8b3uzq2e1c9x6pxn2h0f0k\">没有替换的模板</td>\n<td>yes</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vm7wzo9yufzneso1bvy92rd2\">有替换的模板</td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4426iokopml0k64ar8cz4tklj\">是，如果替换是可折叠的</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6km60trrfnc4j65n50ltmrz6\">字面量字符串</td>\n<td>yes</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9whhr0otfdhciw4ompg2p3y28\">字面量数字</td>\n<td>yes</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3n8z4687qnsdmn5y6xmbmnnxi\">字面量布尔值</td>\n<td>yes</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3915mfsp6yfqt6ltma1w5m19h\">字面量 null</td>\n<td>yes</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qfkr5r9jpuemmic1t6z59ubs\">支持的前缀运算符</td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8w7u9s5tktg84igoky5nmk1x8\">是，如果操作数是可折叠的</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do39fzcuk0e5ooxm62kmz4lhm\">支持的二元运算符</td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ffs9xizd3pr7cdvr2rbehme2\">是，如果左右两边都是可折叠的</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yferwjkhuahg79erz4z23rnm\">条件运算符</td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"amjha0tbhse041jeyjuvedlp5\">是，如果条件是可折叠的</td>\n</tr>\n<tr>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99vy3rp3vy14fnojqf6hj1uc7\">圆括号</td>\n<td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nk3eg924z3m839az0x2w9x9\">是，如果表达式是可折叠的</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2n7kqe0gh5hnyy7ubutzssi1\">如果表达式不可折叠，则收集器会将其写入 \n<code>.metadata.json</code>，作为编译器要解析的 \n<a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a>。</p>\n<h2 id=\"phase-2-code-generation\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7dkuta9n5b71mcf4ecwtx9flg\"><i class=\"material-icons\">link</i>阶段 2：代码生成</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2lcss4wpt1uv54myhj25jnsfn\"><em>收集器</em>不会尝试理解它收集并输出到 \n<code>.metadata.json</code> 的元数据。它会尽力表示元数据，并在检测到元数据语法违规时记录错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dlviox5nae7qrzh2zivpb1ja\">编译器的工作是在代码生成阶段解释 \n<code>.metadata.json</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9r771owxmc2cpee0cyl9jty83\">编译器理解\n<em>收集器</em>支持的所有语法形式，但如果\n<em>语义</em>违反编译器规则，它可能会拒绝\n<em>语法上</em>正确的元数据。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"23227kuy1ppw38thjxd1egtg0\">编译器只能引用<em>已导出的符号</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aevo81ijqhdsrdkgo61uzv3yk\">带装饰器的组件类成员必须是公共的。你不能将 \n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 属性设为私有或内部。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5n0zafejya5csygb5fpmta0nj\">数据绑定的属性也必须是公开的。</p>\n<code-example language=\"typescript\">\n// BAD CODE - title is private\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&lt;h1&gt;{{title}}&lt;/h1&gt;'\n})\nexport class AppComponent {\n  private title = 'My App'; // Bad\n}\n</code-example>\n<a id=\"supported-functions\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3m82bjb0brlgtixxju0s2872c\">最重要的是，编译器只生成代码来创建某些类的实例，支持某些装饰器，并从以下列表中调用某些函数。</p>\n<h3 id=\"new-instances\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70c03lcwyg7vctfl5zpgdkgx\"><i class=\"material-icons\">link</i>新实例</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d8m27q5u62wppyr8dwa09ndc9\">编译器只允许创建来自 \n<code>@angular/core</code> 的 \n<code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 类的实例的元数据。</p>\n<h3 id=\"annotationsdecorators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9e04bgon69zzpxus55p3epo7h\"><i class=\"material-icons\">link</i>注解/装饰器</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eziz2a88s4yrbkjbmekreubbh\">编译器只支持这些 Angular 装饰器的元数据。</p>\n<table>\n<thead>\n<tr>\n<th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4r1vymjzypb8fhx3r1lipqcf9\">装饰器</th>\n<th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"dkuxw56x8curh875ge5tvqede\">模块</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code><a href=\"api/core/Attribute\" class=\"code-anchor\">Attribute</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"macro-functions-and-macro-static-methods\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"856jtrstlp6htw9ksxyfx66mc\"><i class=\"material-icons\">link</i>宏函数和宏静态方法</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"57bmbau9pb9mlk5c0ehl3ohqc\">编译器还支持以函数或静态方法形式存在的\n<em>宏</em>，这些函数或静态方法返回一个表达式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"88mt6000uk9b639d21izbyc9x\">例如，考虑如下函数：</p>\n<code-example language=\"typescript\">\nexport function wrapInArray&lt;T&gt;(value: T): T[] {\n  return [value];\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"chtium6n6l36ulxrwux8ux4wy\">你可以在元数据定义中调用 <code>wrapInArray</code>，因为它所返回的表达式的值满足编译器支持的 JavaScript 受限子集。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"avtcedibccqkly4kkpyllg8uq\">你还可以这样使用 <code>wrapInArray()</code>：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"cxe1c38pqqvbbjyri66x67hjg\">编译器会把这种用法处理成你以前的写法：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [TypicalComponent]\n})\nexport class TypicalModule {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ll868hfryc5xrtzo16hw2sy1\">收集器在确定什么符合宏函数的条件方面很简单；它只能包含一个 \n<code>return</code> 语句。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9k588au8sqglkxjvddm5bc1jm\">Angular 的 \n<a href=\"api/router/RouterModule\"><code>RouterModule</code></a> 导出两个宏静态方法，\n<code>forRoot</code> 和 \n<code>forChild</code>，以帮助声明根路由和子路由。 查看 \n<a href=\"https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">源代码</a> 以了解这些方法如何简化复杂 \n<a href=\"guide/ngmodules\">NgModules</a> 的配置。</p>\n<a id=\"metadata-rewriting\"></a>\n<h3 id=\"metadata-rewriting\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"80apurgqc66e7jogku2jtp62a\"><i class=\"material-icons\">link</i>元数据重写</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ya7q3m01brk185qjxwc98r14\">编译器对包含 \n<code>useClass</code>、\n<code>useValue</code>、\n<code>useFactory</code> 和 \n<code>data</code> 字段的对象字面量进行特殊处理。编译器将初始化这些字段之一的表达式转换为一个导出的变量，该变量替换了表达式。此重写这些表达式的过程消除了对它们内容的所有限制，因为 编译器不需要知道表达式的值——它只需要能够生成对该值的引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"dn54lv55obipr2bwr6zanx61m\">你可以这样写：</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: () =&gt; TypicalServer}]\n})\nexport class TypicalModule {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7f7813hmmkwbtrzijx4zgndyo\">如果不进行重写，这将是无效的，因为不支持 lambda，并且 \n<code>TypicalServer</code> 未导出。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eits01bfws7vbery9q6ubtyln\">为了允许这样做，编译器会自动将其重写为类似以下内容：</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\nexport const ɵ0 = () =&gt; new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: ɵ0}]\n})\nexport class TypicalModule {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"87kd9o6ivoge3b0iryeu5jdkl\">这使得编译器能够在工厂中生成对 \n<code>ɵ0</code> 的引用，而无需知道 \n<code>ɵ0</code> 的值包含什么。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aig3nlr0hlb8ev50icevks522\">编译器在 \n<code>.js</code> 文件的发出过程中进行重写。但是，这不会重写 \n<code>.d.ts</code> 文件，因此 TypeScript 不会将其识别为导出。因此，它不会污染 ES 模块的导出 API。</p>\n<h2 id=\"metadata-errors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ttjthpqbmb1gjm6nh0d8ku6r\"><i class=\"material-icons\">link</i>元数据错误</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"dryuujvcj34rk8wuw1s30ktxu\">以下是你可能会遇到的元数据错误，带有解释和建议的更正。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lslotjmb8ffy8i9fy728gix1\"><a href=\"guide/aot-compiler#expression-form-not-supported\">不支持表达式形式</a>\n<br> \n<a href=\"guide/aot-compiler#reference-to-a-local-symbol\">对局部（未导出）符号的引用</a>\n<br> \n<a href=\"guide/aot-compiler#only-initialized-variables\">仅初始化的变量和常量</a>\n<br> \n<a href=\"guide/aot-compiler#reference-to-a-non-exported-class\">对未导出类的引用</a>\n<br> \n<a href=\"guide/aot-compiler#reference-to-a-non-exported-function\">对未导出函数的引用</a>\n<br> \n<a href=\"guide/aot-compiler#function-calls-not-supported\">不支持函数调用</a>\n<br> \n<a href=\"guide/aot-compiler#destructured-variable-not-supported\">不支持解构的变量或常量</a>\n<br> \n<a href=\"guide/aot-compiler#could-not-resolve-type\">无法解析类型</a>\n<br> \n<a href=\"guide/aot-compiler#name-expected\">预期名称</a>\n<br> \n<a href=\"guide/aot-compiler#unsupported-enum-member-name\">不支持的枚举成员名称</a>\n<br> \n<a href=\"guide/aot-compiler#tagged-template-expressions-not-supported\">不支持标记的模板表达式</a>\n<br> \n<a href=\"guide/aot-compiler#symbol-reference-expected\">预期符号引用</a>\n<br></p>\n<hr>\n<h3 class=\"no-toc\" id=\"expression-form-not-supported\">Expression form not supported</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hzmkt1r1zgzosqy1axohpvd1\">编译器在评估 Angular 元数据时遇到了一个它不理解的表达式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dyrshl29i8qtlzio9qxaobde\">编译器 \n<a href=\"guide/aot-compiler#expression-syntax\">受限表达式语法</a> 之外的语言特性可能会产生此错误，如以下示例所示：</p>\n<code-example>\n// ERROR\nexport class Fooish { ... }\n...\nconst prop = typeof Fooish; // typeof is not valid in metadata\n  ...\n  // bracket notation is not valid in metadata\n  { provide: 'token', useValue: { [prop]: 'value' } };\n  ...\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"54u85983876b6lqdbwybq93yb\">你可以在普通的应用代码中使用 <code>typeof</code> 和方括号标记法来指定属性名，但是这些特性不能在定义 Angular 元数据的表达式中使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5avrv4heswvydblo41bsllucz\">在编写 Angular 元数据时，请坚持使用编译器的 \n<a href=\"guide/aot-compiler#expression-syntax\">受限表达式语法</a> ，并注意新的或不常见的 TypeScript 特性。</p>\n<hr>\n<a id=\"reference-to-a-local-symbol\"></a>\n<h3 class=\"no-toc\" id=\"reference-to-a-local-non-exported-symbol\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"18u6us3sdhgpp4ewlcai2o99k\"><i class=\"material-icons\">link</i>引用本地（未导出的）符号（Reference to a local (non-exported) symbol）</h3>\n<div class=\"alert is-helpful\">\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtouj5xycre7vahlshfguwr7p\">对局部（未导出）符号“符号名称”的引用。考虑导出该符号。</em></p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"925x7v7bkznhugrhi3ott25yj\">编译器遇到了对局部定义的符号的引用，该符号要么未导出，要么未初始化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7dzuj5v4jlutmq3tm3ogu7mxg\">下面就是存在该问题的 <code>provider</code> 范例。</p>\n<code-example>\n// ERROR\nlet foo: number; // neither exported nor initialized\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8s7sixxj2x77j1t1gel64dfsw\">编译器会生成这个组件工厂，其中包含 <code>useValue</code> 提供者的代码。<em>那个</em>工厂模块不能访问<em>这个</em>源码模块，无法访问这个（未导出的）<code>foo</code> 变量。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"d7ckchu1w4936zkwov1vu76zt\">你可以通过初始化 <code>foo</code> 来修正这个错误。</p>\n<code-example>\nlet foo = 42; // initialized\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsqc8zvt9nvvbt5acesnk5g1n\">编译器将 \n<a href=\"guide/aot-compiler#folding\">折叠</a> 该表达式到提供者中，就像你写了这样一样。</p>\n<code-example>\n  providers: [\n    { provide: Foo, useValue: 42 }\n  ]\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5ugs77pyww18k58s9ctnpmy97\">另外，你也可以通过导出 <code>foo</code> 来解决它，这样 <code>foo</code> 将会在运行期间你真正知道它的值的时候被赋值。</p>\n<code-example>\n// CORRECTED\nexport let foo: number; // exported\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vmljfr3rvlvgdhrr7mdt8j8w\">在元数据（如 \n<code>providers</code> 和 \n<code>animations</code>）中引用的变量，添加 \n<code>export</code> 通常有效，因为编译器可以在这些表达式中生成对导出变量的\n<em>引用</em>。它不需要这些变量的\n<em>值</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6opjdkqkkhcamlcrxhputipos\">当编译器需要知道<em>真正的值</em>以生成代码时，添加 <code>export</code> 的方式就是无效的。比如这里的 <code>template</code> 属性。</p>\n<code-example>\n// ERROR\nexport let someTemplate: string; // exported but not initialized\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ahwqcz0v3jf1k5nwlbbtdrgx\">编译器\n<em>现在</em>就需要 \n<code>template</code> 属性的值来生成组件工厂。 仅引用变量是不够的。 在声明前加上 \n<code>export</code> 只是会产生一个新的错误，“\n<a href=\"guide/aot-compiler#only-initialized-variables\"><code>只能引用初始化的变量和常量</code></a>”。</p>\n<hr>\n<a id=\"only-initialized-variables\"></a>\n<h3 class=\"no-toc\" id=\"only-initialized-variables-and-constants\">Only initialized variables and constants</h3>\n<div class=\"alert is-helpful\">\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9x8w40p8u7t6vka9zt7zr4x68\">只能引用初始化的变量和常量，因为模板编译器需要此变量的值。</em></p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c6o8bnucpqy36z0h0srfie601\">编译器发现某个到已导出的变量或静态字段的引用是没有初始化过的。而它需要根据那个变量的值来生成代码。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9yia0s0cpwdzk8m8lzx1n24yt\">以下示例尝试将组件的 \n<code>template</code> 属性设置为导出变量 \n<code>someTemplate</code> 的值，该变量已声明但\n<em>未赋值</em>。</p>\n<code-example>\n// ERROR\nexport let someTemplate: string;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4oneyif8k5kulbxrhtfrza87z\">如果你从其它模块中导入了 <code>someTemplate</code>，但那个模块中忘了初始化它，就会看到这个错误。</p>\n<code-example>\n// ERROR - not initialized there either\nimport { someTemplate } from './config';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3oys48e0ydp54igrd8nk7apir\">编译器不能等到运行时才能获取模板信息。 它必须从源代码中静态地推导出 \n<code>someTemplate</code> 变量的值，以便它可以生成组件工厂，其中包括 根据模板构建元素的指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8vgc43m3ssj65jzb71iag1qmc\">要纠正这个错误，请在<em>同一行</em>的初始化子句中初始化这个变量的值。</p>\n<code-example>\n// CORRECTED\nexport let someTemplate = '&lt;h1&gt;Greetings from Angular&lt;/h1&gt;';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"reference-to-a-non-exported-class\">Reference to a non-exported class</h3>\n<div class=\"alert is-helpful\">\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ch9u4xnh88x9tr3sivp9ie30\">对未导出类 \n<class name=\"\">\n  的引用。考虑导出该类。\n</class></em></p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7aam8ulnuk8pm034q1u7doe1u\">元数据引用了一个未导出的类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3y4rdztsly2lam6lj6f7bygkp\">例如，你可能定义了一个类，并在提供者数组中将其用作注入令牌， 但忘记导出该类。</p>\n<code-example>\n// ERROR\nabstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"39wcutosex9if6oos6eftu385\">Angular 在一个单独的模块中生成一个类工厂，并且该 工厂 \n<a href=\"guide/aot-compiler#exported-symbols\">只能访问导出的类</a>。 要更正此错误，请导出引用的类。</p>\n<code-example>\n// CORRECTED\nexport abstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"reference-to-a-non-exported-function\">Reference to a non-exported function</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"57xbu5pcajswwaldqaknku9m9\">元数据引用了一个未导出的函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5x86r11utsllqop4p99g1vpvy\">比如，你可能已经把某个服务提供者的 <code>useFactory</code> 属性设置成了一个局部定义但忘了导出的函数。</p>\n<code-example>\n// ERROR\nfunction myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5sc3p8cqcz72t1og85gyd0cep\">Angular 在一个单独的模块中生成一个类工厂，并且该 工厂 \n<a href=\"guide/aot-compiler#exported-symbols\">只能访问导出的函数</a>。 要更正此错误，请导出该函数。</p>\n<code-example>\n// CORRECTED\nexport function myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"function-calls-not-supported\"></a>\n<h3 class=\"no-toc\" id=\"function-calls-are-not-supported\">Function calls are not supported</h3>\n<div class=\"alert is-helpful\">\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bvwq6fxr2rioogkiu4a3xmtf1\">不支持函数调用。考虑用对导出函数的引用替换函数或 lambda。</em></p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4etvbft6bbm0u1f8l49cvb9ct\">编译器目前不支持 \n<a href=\"guide/aot-compiler#function-expression\">函数表达式或 lambda 函数</a>。 例如，你不能将提供者的 \n<code>useFactory</code> 设置为匿名函数或箭头函数，如下所示。</p>\n<code-example>\n// ERROR\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: function() { ... } },\n    { provide: OtherStrategy, useFactory: () =&gt; { ... } }\n  ]\n  ...\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"34bn7s0rlik57m97her4y40xp\">如果你在某个提供者的 <code>useValue</code> 中调用函数或方法，也会导致这个错误。</p>\n<code-example>\n// ERROR\nimport { calculateValue } from './utilities';\n\n  ...\n  providers: [\n    { provide: SomeValue, useValue: calculateValue() }\n  ]\n  ...\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"qikbuc6qz1xrlc4oxi39qi67\">要改正这个问题，就要从模块中导出这个函数，并改成在服务提供者的 <code>useFactory</code> 中引用该函数。</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { calculateValue } from './utilities';\n\nexport function myStrategy() { ... }\nexport function otherStrategy() { ... }\nexport function someValueFactory() {\n  return calculateValue();\n}\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy },\n    { provide: OtherStrategy, useFactory: otherStrategy },\n    { provide: SomeValue, useFactory: someValueFactory }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"destructured-variable-not-supported\"></a>\n<h3 class=\"no-toc\" id=\"destructured-variable-or-constant-not-supported\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"e3qxudjj67h4qwrpdswxics9s\"><i class=\"material-icons\">link</i>不支持解构变量或常量（Destructured variable or constant not supported）</h3>\n<div class=\"alert is-helpful\">\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b96hwk73fso35nc3gc67arjsw\">模板编译器不支持引用导出解构的变量或常量。考虑简化此操作以避免解构。</em></p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm03emkidfoni29cv279g3iys\">编译器不支持对通过 \n<a href=\"https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\">解构</a> 赋值的变量的引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8fq18w42jnibzm2a9cmak4g17\">比如，你不能这么写：</p>\n<code-example linenums=\"false\">\n// ERROR\nimport { configuration } from './configuration';\n\n// destructured assignment to foo and bar\nconst {foo, bar} = configuration;\n  ...\n  providers: [\n    {provide: Foo, useValue: foo},\n    {provide: Bar, useValue: bar},\n  ]\n  ...\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"el4xro44cn3bltwycnoemwk0q\">要纠正这个错误，就要引用非解构方式的变量。</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { configuration } from './configuration';\n  ...\n  providers: [\n    {provide: Foo, useValue: configuration.foo},\n    {provide: Bar, useValue: configuration.bar},\n  ]\n  ...\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"could-not-resolve-type\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"b4qfeuvukgarfelvtnl8c15tf\"><i class=\"material-icons\">link</i>无法解析类型（Could not resolve type）</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q2l8xvo7u9jelkoshzwitblb\">编译器遇到了一个类型，但无法确定哪个模块导出该类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d97gcqfa71rmzgmopoyco2dyu\">如果引用了环境类型，就会发生这种情况。 例如，\n<code>Window</code> 类型是在全局 \n<code>.d.ts</code> 文件中声明的环境类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6rcam0c0zjfokdsypil7oe9po\">如果在组件构造函数中引用它，就会出现错误， 因为编译器必须对其进行静态分析。</p>\n<code-example>\n// ERROR\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ })\nexport class MyComponent {\n  constructor (private win: Window) { ... }\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1z7v3oq75mbrvkguf53yszbah\">TypeScript 理解环境类型，因此你不需要导入它们。 Angular 编译器不理解你忘记导出或导入的类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"35a3dqzvzkxpn4tg40v6z6nq1\">这种情况下，编译器就无法理解如何使用这个 <code>Window</code> 令牌来进行注入。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"vfqr3fxqfahumzpvd8znoatv\">不要在元数据表达式中引用环境类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2iymw6l1qha4z6d1akan0u039\">如果必须注入环境类型的实例， 你可以通过四个步骤来解决这个问题：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"biduk1kzfkq82qktm6uflqaqi\">为环境类型的实例创建一个注入令牌。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"as49x53ncygxk5upognv5e526\">创建一个返回该实例的工厂函数。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5wsh1apbzvey7sh9blen7a389\">使用该工厂函数添加一个 <code>useFactory</code> 提供者。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zhqm0bzo408g0gpj5upjdfjh\">使用 \n<code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> 注入该实例。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7e2ujetaxxophkq8txsishde0\">下面的例子说明了这一点。</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nexport const WINDOW = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>('Window');\nexport function _window() { return window; }\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [\n    { provide: WINDOW, useFactory: _window }\n  ]\n})\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW) private win: Window) { ... }\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhvjhmiqvxk1hh1s6tzek6wjf\">构造函数中的 \n<code>Window</code> 类型不再是编译器的问题，因为它 使用 \n<code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW)</code> 生成注入代码。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e919cnku0vq80koisd7xg4l2b\">Angular 对 \n<code><a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a></code> 令牌做了类似的事情，因此你可以注入浏览器的 \n<code>document</code> 对象（或它的抽象，具体取决于应用程序运行的平台）。</p>\n<code-example linenums=\"false\">\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> }   from '@angular/core';\nimport { <a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ ... })\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(<a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a>) private doc: Document) { ... }\n}\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"name-expected\">Name expected</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ai0jjeqvbq7zi7zc7c3h6oxrl\">编译器在评估表达式时预期一个名称。 如果使用数字作为属性名称，就会发生这种情况，如以下示例所示。</p>\n<code-example>\n// ERROR\nprovider: [{ provide: Foo, useValue: { 0: 'test' } }]\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2oy2f5ul3pwf6aly2b8tj4hdw\">把该属性的名字改为非数字类型。</p>\n<code-example>\n// CORRECTED\nprovider: [{ provide: Foo, useValue: { '0': 'test' } }]\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"unsupported-enum-member-name\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"91k4pa8bmfa28ljb31gcg0w1m\"><i class=\"material-icons\">link</i>不支持的枚举成员名称（Unsupported enum member name）</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jlkfa6pwfsi3ahjq9pgat1ds\">Angular 无法确定你在元数据中引用的 \n<a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\">枚举成员</a> 的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"44vrhjlw85r36polyudo1x4cx\">编译器可以理解简单的枚举值，但不能理解复杂的，比如从那些计算属性中派生出来的。</p>\n<code-example linenums=\"false\">\n// ERROR\nenum Colors {\n  Red = 1,\n  White,\n  Blue = \"Blue\".length // computed\n}\n\n  ...\n  providers: [\n    { provide: BaseColor,   useValue: Colors.White } // ok\n    { provide: DangerColor, useValue: Colors.Red }   // ok\n    { provide: StrongColor, useValue: Colors.Blue }  // bad\n  ]\n  ...\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"9b6kg6vcz6z7tgibkp4qf1cpr\">避免引用那些使用了复杂初始化对象或计算属性的枚举。</p>\n<hr>\n<a id=\"tagged-template-expressions-not-supported\"></a>\n<h3 class=\"no-toc\" id=\"tagged-template-expressions-are-not-supported\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8g7442isf97t6c4w10pzfe3so\"><i class=\"material-icons\">link</i>不支持带标签的模板表达式（Tagged template expressions are not supported）</h3>\n<div class=\"alert is-helpful\">\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ak2jgz0li34qw7hyev8bk1ofj\">元数据中不支持标记的模板表达式。</em></p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yit06hq311cyajuj3fy680l7\">编译器遇到一个 JavaScript ES2015 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\">带标记的模板表达式</a>，例如：</p>\n<code-example>\n// ERROR\nconst expression = 'funky';\nconst raw = String.raw`A tagged template ${expression} string`;\n ...\n template: '&lt;div&gt;' + raw + '&lt;/div&gt;'\n ...\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"er3wrj9hwcpc4e6twj60880mx\"><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\"><code>String.raw()</code></a> 是 JavaScript ES2015 中的\n<em>标记函数</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"41une5bp1qaqjgdw76rhm85zx\">AOT 编译器不支持带标签函数的模板表达式，避免在元数据表达式中使用它们。</p>\n<hr>\n<h3 class=\"no-toc\" id=\"symbol-reference-expected\">Symbol reference expected</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cr1y9iy8pg409e7ovenqrns3i\">编译器期望在错误消息中指定的位置找到对某个符号的引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"dh6v9vsn475y4uq6u6buorexh\">当你在类的 <code>extends</code> 子句中使用表达式时就会出现这个错误。</p>\n<!--\n\nChuck: After reviewing your PR comment I'm still at a loss. See [comment there](https://github.com/angular/angular/pull/17712#discussion_r132025495).\n\n-->\n<a id=\"binding-expresion-validation\"></a>\n<h2 id=\"phase-3-binding-expression-validation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3369ftm8e8m18xw0w5wxdtgzk\"><i class=\"material-icons\">link</i>阶段 3：绑定表达式验证</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6pn0s34149fqpdz6zsezzpor1\">在验证阶段，Angular 模板编译器使用 TypeScript 编译器来验证模板中的绑定表达式。通过在项目 \n<code>tsconfig.json</code> 的 \n<code>\"angularCompilerOptions\"</code> 中添加编译器选项 \n<code>\"fullTemplateTypeCheck\"</code> 来显式启用此阶段（参见 \n<a href=\"guide/aot-compiler#compiler-options\">Angular 编译器选项</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"agqdxfh24q29mllfmn982a7l5\">当模板绑定表达式中检测到类型错误时，进行模板验证时就会生成错误。这和 TypeScript 编译器在处理 <code>.ts</code> 文件中的代码时报告错误很相似。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8bqijkd4tza5839uykhka8nef\">比如，考虑下列组件：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{person.addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2qyd2xnxfgr1k5p7c80grfm38\">这将产生以下错误：</p>\n<code-example>\nmy.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5zqg3pujfpbs8v2mo11ey5ht4\">错误消息中报告的文件名 \n<code>my.component.ts.MyComponent.html</code> 是模板编译器生成的合成文件，它包含 \n<code>MyComponent</code> 类模板的内容。 编译器从不将此文件写入磁盘。行号和列号相对于类 \n<code>MyComponent</code> 的 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 注解中的模板字符串，在本例中为 \n<code>MyComponent</code>。如果组件使用 \n<code>templateUrl</code> 而不是 \n<code>template</code>，则错误将在 \n<code>templateUrl</code> 引用的 HTML 文件中报告，而不是合成文件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7p79qft2xappvcnsqxwdeuxqn\">错误位置是包含带有错误的插值表达式的文本节点的开头。如果错误出现在属性绑定中，例如 \n<code>[value]=\"person.address.street\"</code>，则错误位置是包含错误的属性的位置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xqx3l8uhlh6pp724ozhf2pic\">验证使用 TypeScript 类型检查器和提供给 TypeScript 编译器的选项来控制 类型验证的详细程度。例如，如果指定了 \n<code>strictTypeChecks</code>，则会报告错误 \n<code>my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'</code> 以及上述错误消息。</p>\n<h3 id=\"type-narrowing\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"62jrtenq1nrag23qeufytd223\"><i class=\"material-icons\">link</i>类型窄化</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"994bx38o89i033xij3y9uxf11\">在 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 指令中使用的表达式用于在 Angular 模板编译器中缩小类型联合，与 TypeScript 中的 \n<code>if</code> 表达式相同。例如，为了避免 在上面的模板中出现 \n<code>Object is possibly 'undefined'</code> 错误，请修改它，使其仅在 \n<code>person</code> 的值已初始化时才发出插值，如下所示：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"&gt; {{person.addresss.street}} &lt;/span&gt;'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ce1bti9ppah2cot9sdl903fhe\">使用 \n<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 允许 TypeScript 编译器推断出绑定表达式中使用的 \n<code>person</code> 永远不会是 \n<code>undefined</code>。</p>\n<h4 id=\"custom-ngif-like-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ctshl82vt0btrbgdgjzcxp7wn\"><i class=\"material-icons\">link</i>自定义 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 类指令</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97jx3ksar8w1htz2huis8be4\">行为类似于 \n<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 的指令可以通过包含 一个静态成员标记来声明它们希望得到相同的处理，该标记是模板编译器将它们 视为 \n<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 的信号。\n<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 的此静态成员是：</p>\n<code-example language=\"typescript\">\n  public <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngIfUseIfTypeGuard: void;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rl2swpgf82vpmr6zvbhpqmam\">这声明了 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 指令的输入属性 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 应该被视为其模板使用的 保护，这意味着只有当 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 输入属性为真时，才会实例化该模板。</p>\n<h3 id=\"non-null-type-assertion-operator\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aeavaaxa4o1gdak39uwwggmvg\"><i class=\"material-icons\">link</i>非空类型断言运算符</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e2qsozap94fufbunky84vxmks\">使用 \n<a href=\"guide/template-syntax#non-null-assertion-operator\">非空类型断言运算符</a> 来抑制 \n<code>Object is possibly 'undefined'</code> 错误，当使用 \n<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 不方便或组件中的某些约束确保绑定表达式被插值时表达式始终 非空时。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4nggyspwver62umt159chqwd\">在以下示例中，\n<code>person</code> 和 \n<code>address</code> 属性始终一起设置， 这意味着如果 \n<code>person</code> 非空，则 \n<code>address</code> 始终非空。没有方便的方法 将此约束描述给 TypeScript 和模板编译器，但通过使用 \n<code>address!.street</code>，示例中的错误 被抑制了。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"&gt; {{person.name}} lives on {{address!.street}} &lt;/span&gt;'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4qat8j4njaxshsp3wi295eq4\">非空断言运算符应该谨慎使用，因为组件的重构 可能会破坏此约束。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51mugjz13npsgphid0tpj8yul\">在此示例中，建议在 \n<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 中包含对 \n<code>address</code> 的检查，如下所示：</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person &amp;&amp; address\"&gt; {{person.name}} lives on {{address.street}} &lt;/span&gt;'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n</code-example>\n<h3 id=\"disabling-type-checking-using-any\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bldjm4zyg5yaly0v6npnm5j8e\"><i class=\"material-icons\">link</i>使用 <code>$any()</code> 禁用类型检查</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aul24sxvixbw12jl70lqompdn\">通过将表达式 包围在对 \n<a href=\"guide/template-syntax\"><code>$any()</code> 转换伪函数</a> 的调用中来禁用对绑定表达式的检查。 编译器将其视为对 \n<code>any</code> 类型的转换，就像在 TypeScript 中使用 \n<code>&lt;any&gt;</code> 或 \n<code>as any</code> 转换一样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f40kdidsoafvp8gvw0cr3acov\">在以下示例中，错误 \n<code>Property addresss does not exist</code> 被抑制 通过将 \n<code>person</code> 转换为 \n<code>any</code> 类型。</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{$any(person).addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<h2 id=\"summary\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2fflknbbur8ttwdtn3o9w4vat\"><i class=\"material-icons\">link</i>总结</h2>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"182q6kbfr8vr52klq7cxnqzfr\">AOT 编译器做了什么以及为什么它很重要。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rqfc9i7t4japw6tw9tf1acvt\">为什么元数据必须用 JavaScript 的一个子集编写。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bm1id0664bzkze4bt1oxkx6yi\">该子集是什么。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ek0ih9hsh4qo5bxqahxptix5c\">元数据定义的其他限制。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5t9j31un0sknlasnvzmm5ptjr\">宏函数和宏静态方法。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9thfz33zsl0kboekbr795ienf\">与元数据相关的编译器错误。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjlbs9960am7b7nrd7uy1jzb\">绑定表达式的验证</li>\n</ul>\n\n</div>\n<!-- links to this doc:\n - api/upgrade/UpgradeAdapter\n - api/upgrade/UpgradeAdapterRef\n - guide/architecture-next-steps\n - guide/browser-support\n - guide/change-log\n - guide/deployment\n - guide/npm-packages\n - guide/quickstart\n - guide/universal\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/common/DOCUMENT\n - api/common/NgIf\n - api/core/Attribute\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/Host\n - api/core/HostBinding\n - api/core/HostListener\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/core/Optional\n - api/core/Output\n - api/core/Pipe\n - api/core/Self\n - api/core/SkipSelf\n - api/core/ViewChild\n - api/router/RouterLinkWithHref\n - api/router/RouterModule\n - api/upgrade/static\n - guide/aot-compiler#allowemptycodegenfiles\n - guide/aot-compiler#angular-compilation\n - guide/aot-compiler#angular-compiler-options\n - guide/aot-compiler#angular-metadata-and-aot\n - guide/aot-compiler#annotateforclosurecompiler\n - guide/aot-compiler#annotationsas\n - guide/aot-compiler#annotationsdecorators\n - guide/aot-compiler#binding-expresion-validation\n - guide/aot-compiler#compiler-options\n - guide/aot-compiler#could-not-resolve-type\n - guide/aot-compiler#custom-ngif-like-directives\n - guide/aot-compiler#destructured-variable-not-supported\n - guide/aot-compiler#destructured-variable-or-constant-not-supported\n - guide/aot-compiler#disableexpressionlowering\n - guide/aot-compiler#disabling-type-checking-using-any\n - guide/aot-compiler#enablelegacytemplate\n - guide/aot-compiler#exported-symbols\n - guide/aot-compiler#expression-form-not-supported\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#flatmoduleid\n - guide/aot-compiler#flatmoduleoutfile\n - guide/aot-compiler#foldable-syntax\n - guide/aot-compiler#folding\n - guide/aot-compiler#fulltemplatetypecheck\n - guide/aot-compiler#function-calls-are-not-supported\n - guide/aot-compiler#function-calls-not-supported\n - guide/aot-compiler#function-expression\n - guide/aot-compiler#generatecodeforlibraries\n - guide/aot-compiler#how-aot-works\n - guide/aot-compiler#limited-function-calls\n - guide/aot-compiler#macro-functions-and-macro-static-methods\n - guide/aot-compiler#metadata-errors\n - guide/aot-compiler#metadata-restrictions\n - guide/aot-compiler#metadata-rewriting\n - guide/aot-compiler#name-expected\n - guide/aot-compiler#new-instances\n - guide/aot-compiler#no-arrow-functions\n - guide/aot-compiler#non-null-type-assertion-operator\n - guide/aot-compiler#only-initialized-variables\n - guide/aot-compiler#only-initialized-variables-and-constants\n - guide/aot-compiler#phase-1-analysis\n - guide/aot-compiler#phase-2-code-generation\n - guide/aot-compiler#phase-3-binding-expression-validation\n - guide/aot-compiler#preservewhitespaces\n - guide/aot-compiler#reference-to-a-local-non-exported-symbol\n - guide/aot-compiler#reference-to-a-local-symbol\n - guide/aot-compiler#reference-to-a-non-exported-class\n - guide/aot-compiler#reference-to-a-non-exported-function\n - guide/aot-compiler#skipmetadataemit\n - guide/aot-compiler#skiptemplatecodegen\n - guide/aot-compiler#strictinjectionparameters\n - guide/aot-compiler#strictmetadataemit\n - guide/aot-compiler#summary\n - guide/aot-compiler#supported-functions\n - guide/aot-compiler#symbol-reference-expected\n - guide/aot-compiler#tagged-template-expressions-are-not-supported\n - guide/aot-compiler#tagged-template-expressions-not-supported\n - guide/aot-compiler#the-ahead-of-time-aot-compiler\n - guide/aot-compiler#trace\n - guide/aot-compiler#type-narrowing\n - guide/aot-compiler#unsupported-enum-member-name\n - guide/aot-compiler#why-compile-with-aot\n - guide/ngmodules\n - guide/template-syntax\n - guide/template-syntax#non-null-assertion-operator\n - http://usejsdoc.org/\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\n - https://en.wikipedia.org/wiki/Abstract_syntax_tree\n - https://github.com/angular/angular-cli/wiki\n - https://github.com/angular/angular-cli/wiki/build\n - https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\n - https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\n - https://github.com/angular/tsickle\n - https://github.com/google/closure-compiler\n - https://webpack.js.org/\n - https://www.typescriptlang.org/docs/handbook/enums.html\n - https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\n - https://www.youtube.com/watch?v=kW9cJsvcsGo\n-->"
}