{
  "id": "guide/aot-compiler",
  "title": "The Ahead-of-Time (AOT) Compiler",
  "contents": "\n<div class=\"content\">\n<h1 id=\"the-ahead-of-time-aot-compiler\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#the-ahead-of-time-aot-compiler\"><i class=\"material-icons\">link</i></a>The Ahead-of-Time (AOT) Compiler</h1>\n<p>The Angular Ahead-of-Time (AOT) compiler converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase <em>before</em> the browser downloads and runs that code.</p>\n<p>This guide explains how to build with the AOT compiler using different compiler options and how to write Angular metadata that AOT can compile.</p>\n<div class=\"l-sub-section\">\n<p>  <a href=\"https://www.youtube.com/watch?v=kW9cJsvcsGo\">Watch compiler author Tobias Bosch explain the Angular Compiler</a> at AngularConnect 2016.</p>\n</div>\n<a id=\"overview\"></a>\n<h2 id=\"angular-compilation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#angular-compilation\"><i class=\"material-icons\">link</i></a>Angular compilation</h2>\n<p>An Angular application consists largely of components and their HTML templates.\nBefore the browser can render the application,\nthe components and templates must be converted to executable JavaScript by an <em>Angular compiler</em>.</p>\n<p>Angular offers two ways to compile your application:</p>\n<ol>\n<li><strong><em>Just-in-Time</em> (JIT)</strong>, which compiles your app in the browser at runtime</li>\n<li><strong><em>Ahead-of-Time</em> (AOT)</strong>, which compiles your app at build time.</li>\n</ol>\n<p>JIT compilation is the default when you run the <em>build-only</em> or the <em>build-and-serve-locally</em> CLI commands:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng build\n  ng serve\n</code-example>\n<a id=\"compile\"></a>\n<p>For AOT compilation, append the <code>--aot</code> flags to the <em>build-only</em> or the <em>build-and-serve-locally</em> CLI commands:</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  ng build --aot\n  ng serve --aot\n</code-example>\n<div class=\"l-sub-section\">\n<p>The <code>--prod</code> meta-flag compiles with AOT by default.</p>\n<p>See the <a href=\"https://github.com/angular/angular-cli/wiki\">CLI documentation</a> for details, especially the <a href=\"https://github.com/angular/angular-cli/wiki/build\"><code>build</code> topic</a>.</p>\n</div>\n<a id=\"why-aot\"></a>\n<h2 id=\"why-compile-with-aot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#why-compile-with-aot\"><i class=\"material-icons\">link</i></a>Why compile with AOT?</h2>\n<p><em>Faster rendering</em></p>\n<p>With AOT, the browser downloads a pre-compiled version of the application.\nThe browser loads executable code so it can render the application immediately, without waiting to compile the app first.</p>\n<p><em>Fewer asynchronous requests</em></p>\n<p>The compiler <em>inlines</em> external HTML templates and CSS style sheets within the application JavaScript,\neliminating separate ajax requests for those source files.</p>\n<p><em>Smaller Angular framework download size</em></p>\n<p>There's no need to download the Angular compiler if the app is already compiled.\nThe compiler is roughly half of Angular itself, so omitting it dramatically reduces the application payload.</p>\n<p><em>Detect template errors earlier</em></p>\n<p>The AOT compiler detects and reports template binding errors during the build step\nbefore users can see them.</p>\n<p><em>Better security</em></p>\n<p>AOT compiles HTML templates and components into JavaScript files long before they are served to the client.\nWith no templates to read and no risky client-side HTML or JavaScript evaluation,\nthere are fewer opportunities for injection attacks.</p>\n<a id=\"compiler-options\"></a>\n<h2 id=\"angular-compiler-options\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#angular-compiler-options\"><i class=\"material-icons\">link</i></a>Angular Compiler Options</h2>\n<p>You can control your app compilation by providing template compiler options in the <code>tsconfig.json</code> file along with the options supplied to the TypeScript compiler. The template compiler options are specified as members of\n<code>\"angularCompilerOptions\"</code> object as shown below:</p>\n<code-example language=\"json\">\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    ...\n  },\n  \"angularCompilerOptions\": {\n    \"fullTemplateTypeCheck\": true,\n    \"preserveWhitespaces\": false,\n    ...\n  }\n}\n</code-example>\n<h3 id=\"skipmetadataemit\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#skipmetadataemit\"><i class=\"material-icons\">link</i></a><em>skipMetadataEmit</em></h3>\n<p>This option tells the compiler not to produce <code>.metadata.json</code> files.\nThe option is <code>false</code> by default.</p>\n<p><code>.metadata.json</code> files contain information needed by the template compiler from a <code>.ts</code>\nfile that is not included in the <code>.d.ts</code> file produced by the TypeScript compiler. This information contains,\nfor example, the content of annotations (such as a component's template) which TypeScript\nemits to the <code>.js</code> file but not to the <code>.d.ts</code> file.</p>\n<p>This option should be set to <code>true</code> if using TypeScript's <code>--outFile</code> option, as the metadata files\nare not valid for this style of TypeScript output. It is not recommeded to use <code>--outFile</code> with\nAngular. Use a bundler, such as <a href=\"https://webpack.js.org/\">webpack</a>, instead.</p>\n<p>This option can also be set to <code>true</code> when using factory summaries as the factory summaries\ninclude a copy of the information that is in the <code>.metadata.json</code> file.</p>\n<h3 id=\"strictmetadataemit\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#strictmetadataemit\"><i class=\"material-icons\">link</i></a><em>strictMetadataEmit</em></h3>\n<p>This option tells the template compiler to report an error to the <code>.metadata.json</code>\nfile if <code>\"skipMetadataEmit\"</code> is <code>false</code> . This option is <code>false</code> by default. This should only be used when <code>\"skipMetadataEmit\"</code> is <code>false</code> and <code>\"skipTemplateCodeGen\"</code> is <code>true</code>.</p>\n<p>It is intended to validate the <code>.metadata.json</code> files emitted for bundling with an <code>npm</code> package. The validation is overly strict and can emit errors for metadata that would never produce an error when used by the template compiler. You can choose to suppress the error emitted by this option for an exported symbol by including <code>@dynamic</code> in the comment documenting the symbol.</p>\n<p>It is valid for <code>.metadata.json</code> files to contain errors. The template compiler reports these errors\nif the metadata is used to determine the contents of an annotation. The metadata\ncollector cannot predict the symbols that are designed to use in an annotation, so it will preemptively\ninclude error nodes in the metadata for the exported symbols. The template compiler can then use the error\nnodes to report an error if these symbols are used. If the client of a library intends to use a symbol in an annotation, the template compiler will not normally report\nthis until the client uses the symbol. This option allows detecting these errors during the build phase of\nthe library and is used, for example, in producing Angular libraries themselves.</p>\n<h3 id=\"skiptemplatecodegen\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#skiptemplatecodegen\"><i class=\"material-icons\">link</i></a><em>skipTemplateCodegen</em></h3>\n<p>This option tells the compiler to suppress emitting <code>.ngfactory.js</code> and <code>.ngstyle.js</code> files. When set,\nthis turns off most of the template compiler and disables reporting template diagnostics.\nThis option can be used to instruct the\ntemplate compiler to produce <code>.metadata.json</code> files for distribution with an <code>npm</code> package while\navoiding the production of <code>.ngfactory.js</code> and <code>.ngstyle.js</code> files that cannot be distributed to\n<code>npm</code>.</p>\n<h3 id=\"strictinjectionparameters\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#strictinjectionparameters\"><i class=\"material-icons\">link</i></a><em>strictInjectionParameters</em></h3>\n<p>When set to <code>true</code>, this options tells the compiler to report an error for a parameter supplied\nwhose injection type cannot be determined. When this value option is not provided or is <code>false</code>, constructor parameters of classes marked with <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> whose type cannot be resolved will\nproduce a warning.</p>\n<p><em>Note</em>: It is recommended to change this option explicitly to <code>true</code> as this option will default to <code>true</code> in the future.</p>\n<h3 id=\"flatmoduleoutfile\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#flatmoduleoutfile\"><i class=\"material-icons\">link</i></a><em>flatModuleOutFile</em></h3>\n<p>When set to <code>true</code>, this option tells the template compiler to generate a flat module\nindex of the given file name and the corresponding flat module metadata. Use this option when creating\nflat modules that are packaged similarly to <code>@angular/core</code> and <code>@angular/common</code>. When this option\nis used, the <code>package.json</code> for the library should refer\nto the generated flat module index instead of the library index file. With this\noption only one <code>.metadata.json</code> file is produced that contains all the metadata necessary\nfor symbols exported from the library index. In the generated <code>.ngfactory.js</code> files, the flat\nmodule index is used to import symbols that includes both the public API from the library index\nas well as shrowded internal symbols.</p>\n<p>By default the <code>.ts</code> file supplied in the <code>files</code> field is assumed to be library index.\nIf more than one <code>.ts</code> file is specified, <code>libraryIndex</code> is used to select the file to use.\nIf more than one <code>.ts</code> file is supplied without a <code>libraryIndex</code>, an error is produced. A flat module\nindex <code>.d.ts</code> and <code>.js</code> will be created with the given <code>flatModuleOutFile</code> name in the same\nlocation as the library index <code>.d.ts</code> file. For example, if a library uses\n<code>public_api.ts</code> file as the library index of the module, the <code>tsconfig.json</code> <code>files</code> field\nwould be <code>[\"public_api.ts\"]</code>. The <code>flatModuleOutFile</code> options could then be set to, for\nexample <code>\"index.js\"</code>, which produces <code>index.d.ts</code> and  <code>index.metadata.json</code> files. The\nlibrary's <code>package.json</code>'s <code>module</code> field would be <code>\"index.js\"</code> and the <code>typings</code> field\nwould be <code>\"index.d.ts\"</code>.</p>\n<h3 id=\"flatmoduleid\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#flatmoduleid\"><i class=\"material-icons\">link</i></a><em>flatModuleId</em></h3>\n<p>This option specifies the preferred module id to use for importing a flat module.\nReferences generated by the template compiler will use this module name when importing symbols\nfrom the flat module.\nThis is only meaningful when <code>flatModuleOutFile</code> is also supplied. Otherwise the compiler ignores\nthis option.</p>\n<h3 id=\"generatecodeforlibraries\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#generatecodeforlibraries\"><i class=\"material-icons\">link</i></a><em>generateCodeForLibraries</em></h3>\n<p>This option tells the template compiler to generate factory files (<code>.ngfactory.js</code> and <code>.ngstyle.js</code>)\nfor <code>.d.ts</code> files with a corresponding <code>.metadata.json</code> file. This option defaults to\n<code>true</code>. When this option is <code>false</code>, factory files are generated only for <code>.ts</code> files.</p>\n<p>This option should be set to <code>false</code> when using factory summaries.</p>\n<h3 id=\"fulltemplatetypecheck\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#fulltemplatetypecheck\"><i class=\"material-icons\">link</i></a><em>fullTemplateTypeCheck</em></h3>\n<p>This option tells the compiler to enable the <a href=\"guide/aot-compiler#binding-expresion-validation\">binding expression validation</a>\nphase of the template compiler which uses TypeScript to validate binding expressions.</p>\n<p>This option is <code>false</code> by default.</p>\n<p><em>Note</em>: It is recommended to set this to <code>true</code> as this option will default to <code>true</code> in the future.</p>\n<h3 id=\"annotateforclosurecompiler\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#annotateforclosurecompiler\"><i class=\"material-icons\">link</i></a><em>annotateForClosureCompiler</em></h3>\n<p>This option tells the compiler to use <a href=\"https://github.com/angular/tsickle\">Tsickle</a> to annotate the emitted\nJavaScript with <a href=\"http://usejsdoc.org/\">JsDoc</a> comments needed by the\n<a href=\"https://github.com/google/closure-compiler\">Closure Compiler</a>. This option defaults to <code>false</code>.</p>\n<h3 id=\"annotationsas\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#annotationsas\"><i class=\"material-icons\">link</i></a><em>annotationsAs</em></h3>\n<p>Use this option to modify how the Angular specific annotations are emitted to improve tree-shaking. Non-Angular\nannotations and decorators are unaffected. Default is <code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> fields</code>.</p>\n<table>\n<thead>\n<tr>\n<th>value</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>decorators</code></td>\n<td>Leave the Decorators in-place. This makes compilation faster. TypeScript will emit calls to the __decorate helper.  Use \n<code>--emitDecoratorMetadata</code>\n for runtime reflection.  However, the resulting code will not properly tree-shake.</td>\n</tr>\n<tr>\n<td><code><a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> fields</code></td>\n<td>Replace decorators with a static field in the class. Allows advanced tree-shakers like \n<a href=\"https://github.com/google/closure-compiler\">Closure Compiler</a>\n to remove unused classes.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"trace\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#trace\"><i class=\"material-icons\">link</i></a><em>trace</em></h3>\n<p>This tells the compiler to print extra information while compiling templates.</p>\n<h3 id=\"enablelegacytemplate\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#enablelegacytemplate\"><i class=\"material-icons\">link</i></a><em>enableLegacyTemplate</em></h3>\n<p>The use of <code>&#x3C;template></code> element was deprecated starting in Angular 4.0 in favor of using\n<code>&#x3C;ng-template></code> to avoid colliding with the DOM's element of the same name. Setting this option to\n<code>true</code> enables the use of the deprecated <code>&#x3C;template></code> element . This option\nis <code>false</code> by default. This option might be required by some third-party Angular libraries.</p>\n<h3 id=\"disableexpressionlowering\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#disableexpressionlowering\"><i class=\"material-icons\">link</i></a><em>disableExpressionLowering</em></h3>\n<p>The Angular template compiler transforms code that is used, or could be used, in an annotation\nto allow it to be imported from template factory modules. See\n<a href=\"guide/aot-compiler#metadata-rewriting\">metadata rewriting</a> for more information.</p>\n<p>Setting this option to <code>false</code> disables this rewriting, requiring the rewriting to be\ndone manually.</p>\n<h3 id=\"preservewhitespaces\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#preservewhitespaces\"><i class=\"material-icons\">link</i></a><em>preserveWhitespaces</em></h3>\n<p>This option tells the compiler whether to remove blank text nodes from compiled templates.\nThis option is <code>true</code> by default.</p>\n<p><em>Note</em>: It is recommended to set this explicitly to <code>false</code> as it emits smaller template factory modules and might be set to <code>false</code> by default in the future.</p>\n<h3 id=\"allowemptycodegenfiles\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#allowemptycodegenfiles\"><i class=\"material-icons\">link</i></a><em>allowEmptyCodegenFiles</em></h3>\n<p>Tells the compiler to generate all the possible generated files even if they are empty. This option is\n<code>false</code> by default. This is an option used by <code>bazel</code> build rules and is needed to simplify\nhow <code>bazel</code> rules track file dependencies. It is not recommended to use this option outside of the <code>bazel</code>\nrules.</p>\n<h2 id=\"angular-metadata-and-aot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#angular-metadata-and-aot\"><i class=\"material-icons\">link</i></a>Angular Metadata and AOT</h2>\n<p>The Angular <strong>AOT compiler</strong> extracts and interprets <strong>metadata</strong> about the parts of the application that Angular is supposed to manage.</p>\n<p>Angular metadata tells Angular how to construct instances of your application classes and interact with them at runtime.</p>\n<p>You specify the metadata with <strong>decorators</strong> such as <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> and <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>.\nYou also specify metadata implicitly in the constructor declarations of these decorated classes.</p>\n<p>In the following example, the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata object and the class constructor tell Angular how to create and display an instance of <code>TypicalComponent</code>.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  template: '&#x3C;div>A typical component for {{data.name}}&#x3C;/div>'\n)}\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { ... }\n}\n</code-example>\n<p>The Angular compiler extracts the metadata <em>once</em> and generates a <em>factory</em> for <code>TypicalComponent</code>.\nWhen it needs to create a <code>TypicalComponent</code> instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.</p>\n<h2 id=\"metadata-restrictions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-restrictions\"><i class=\"material-icons\">link</i></a>Metadata restrictions</h2>\n<p>You write metadata in a <em>subset</em> of TypeScript that must conform to the following general constraints:</p>\n<ol>\n<li>Limit <a href=\"guide/aot-compiler#expression-syntax\">expression syntax</a> to the supported subset of JavaScript.</li>\n<li>Only reference exported symbols after <a href=\"guide/aot-compiler#folding\">code folding</a>.</li>\n<li>Only call <a href=\"guide/aot-compiler#supported-functions\">functions supported</a> by the compiler.</li>\n<li>Decorated and data-bound class members must be public.</li>\n</ol>\n<p>The next sections elaborate on these points.</p>\n<h2 id=\"how-aot-works\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#how-aot-works\"><i class=\"material-icons\">link</i></a>How AOT works</h2>\n<p>It helps to think of the AOT compiler as having two phases: a code analysis phase in which it simply records a representation of the source; and a code generation phase in which the compiler's <code>StaticReflector</code> handles the interpretation as well as places restrictions on what it interprets.</p>\n<h2 id=\"phase-1-analysis\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-1-analysis\"><i class=\"material-icons\">link</i></a>Phase 1: analysis</h2>\n<p>The TypeScript compiler does some of the analytic work of the first phase. It emits the <code>.d.ts</code> <em>type definition files</em> with type information that the AOT compiler needs to generate application code.</p>\n<p>At the same time, the AOT <strong><em>collector</em></strong> analyzes the metadata recorded in the Angular decorators and outputs metadata information in <strong><code>.metadata.json</code></strong> files, one per <code>.d.ts</code> file.</p>\n<p>You can think of <code>.metadata.json</code> as a diagram of the overall structure of a decorator's metadata, represented as an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">abstract syntax tree (AST)</a>.</p>\n<div class=\"l-sub-section\">\n<p>Angular's <a href=\"https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\">schema.ts</a>\ndescribes the JSON format as a collection of TypeScript interfaces.</p>\n</div>\n<a id=\"expression-syntax\"></a>\n<h3 id=\"expression-syntax\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-syntax\"><i class=\"material-icons\">link</i></a>Expression syntax</h3>\n<p>The <em>collector</em> only understands a subset of JavaScript.\nDefine metadata objects with the following limited syntax:</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Literal object</td>\n<td><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n</tr>\n<tr>\n<td>Literal array</td>\n<td><code>['cherries', 'flour', 'sugar']</code></td>\n</tr>\n<tr>\n<td>Spread in literal array</td>\n<td><code>['apples', 'flour', ...the_rest]</code></td>\n</tr>\n<tr>\n<td>Calls</td>\n<td><code>bake(ingredients)</code></td>\n</tr>\n<tr>\n<td>New</td>\n<td><code>new Oven()</code></td>\n</tr>\n<tr>\n<td>Property access</td>\n<td><code>pie.slice</code></td>\n</tr>\n<tr>\n<td>Array index</td>\n<td><code>ingredients[0]</code></td>\n</tr>\n<tr>\n<td>Identifier reference</td>\n<td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n</tr>\n<tr>\n<td>A template string</td>\n<td><code>\n`\npie is ${multiplier} times better than cake\n`\n</code></td>\n</tr>\n<tr>\n<td>Literal string</td>\n<td><code>'pi'</code></td>\n</tr>\n<tr>\n<td>Literal number</td>\n<td><code>3.14153265</code></td>\n</tr>\n<tr>\n<td>Literal boolean</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td>Literal null</td>\n<td><code>null</code></td>\n</tr>\n<tr>\n<td>Supported prefix operator</td>\n<td><code>!cake</code></td>\n</tr>\n<tr>\n<td>Supported Binary operator</td>\n<td><code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> + b</code></td>\n</tr>\n<tr>\n<td>Conditional operator</td>\n<td><code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> ? b : c</code></td>\n</tr>\n<tr>\n<td>Parentheses</td>\n<td><code>(<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> + b)</code></td>\n</tr>\n</tbody>\n</table>\n<p>If an expression uses unsupported syntax, the <em>collector</em> writes an error node to the <code>.metadata.json</code> file. The compiler later reports the error if it needs that\npiece of metadata to generate the application code.</p>\n<div class=\"l-sub-section\">\n<p> If you want <code>ngc</code> to report syntax errors immediately rather than produce a <code>.metadata.json</code> file with errors, set the <code>strictMetadataEmit</code> option in <code>tsconfig</code>.</p>\n<code-example>\n  \"angularCompilerOptions\": {\n   ...\n   \"strictMetadataEmit\" : true\n }\n</code-example>\n<p>Angular libraries have this option to ensure that all Angular <code>.metadata.json</code> files are clean and it is a best practice to do the same when building your own libraries.</p>\n</div>\n<a id=\"function-expression\"></a>\n<a id=\"arrow-functions\"></a>\n<h3 id=\"no-arrow-functions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#no-arrow-functions\"><i class=\"material-icons\">link</i></a>No arrow functions</h3>\n<p>The AOT compiler does not support <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\">function expressions</a>\nand <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow functions</a>, also called <em>lambda</em> functions.</p>\n<p>Consider the following component decorator:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: () => new Server()}]\n})\n</code-example>\n<p>The AOT <em>collector</em> does not support the arrow function, <code>() => new Server()</code>, in a metadata expression.\nIt generates an error node in place of the function.</p>\n<p>When the compiler later interprets this node, it reports an error that invites you to turn the arrow function into an <em>exported function</em>.</p>\n<p>You can fix the error by converting to this:</p>\n<code-example language=\"typescript\">\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: serverFactory}]\n})\n</code-example>\n<p>Beginning in version 5, the compiler automatically performs this rewritting while emitting the <code>.js</code> file.</p>\n<a id=\"function-calls\"></a>\n<h3 id=\"limited-function-calls\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#limited-function-calls\"><i class=\"material-icons\">link</i></a>Limited function calls</h3>\n<p>The <em>collector</em> can represent a function call or object creation with <code>new</code> as long as the syntax is valid. The <em>collector</em> only cares about proper syntax.</p>\n<p>But beware. The compiler may later refuse to generate a call to a <em>particular</em> function or creation of a <em>particular</em> object.\nThe compiler only supports calls to a small set of functions and will use <code>new</code> for only a few designated classes. These functions and classes are in a table of <a href=\"guide/aot-compiler#supported-functions\">below</a>.</p>\n<h3 id=\"folding\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#folding\"><i class=\"material-icons\">link</i></a>Folding</h3>\n<a id=\"exported-symbols\"></a>\n<p>The compiler can only resolve references to <strong><em>exported</em></strong> symbols.\nFortunately, the <em>collector</em> enables limited use of non-exported symbols through <em>folding</em>.</p>\n<p>The <em>collector</em> may be able to evaluate an expression during collection and record the result in the <code>.metadata.json</code> instead of the original expression.</p>\n<p>For example, the <em>collector</em> can evaluate the expression <code>1 + 2 + 3 + 4</code> and replace it with the result, <code>10</code>.</p>\n<p>This process is called <em>folding</em>. An expression that can be reduced in this manner is <em>foldable</em>.</p>\n<a id=\"var-declaration\"></a>\n<p>The collector can evaluate references to\nmodule-local <code>const</code> declarations and initialized <code>var</code> and <code>let</code> declarations, effectively removing them from the <code>.metadata.json</code> file.</p>\n<p>Consider the following component definition:</p>\n<code-example language=\"typescript\">\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p>The compiler could not refer to the <code>template</code> constant because it isn't exported.</p>\n<p>But the <em>collector</em> can <em>fold</em> the <code>template</code> constant into the metadata definition by inlining its contents.\nThe effect is the same as if you had written:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: '&#x3C;div>{{hero.name}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p>There is no longer a reference to <code>template</code> and, therefore, nothing to trouble the compiler when it later interprets the <em>collector's</em> output in <code>.metadata.json</code>.</p>\n<p>You can take this example a step further by including the <code>template</code> constant in another expression:</p>\n<code-example language=\"typescript\">\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template + '&#x3C;div>{{hero.title}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p>The <em>collector</em> reduces this expression to its equivalent <em>folded</em> string:</p>\n<p><code>'&#x3C;div>{{hero.name}}&#x3C;/div>&#x3C;div>{{hero.title}}&#x3C;/div>'</code>.</p>\n<h4 id=\"foldable-syntax\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#foldable-syntax\"><i class=\"material-icons\">link</i></a>Foldable syntax</h4>\n<p>The following table describes which expressions the <em>collector</em> can and cannot fold:</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Foldable</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Literal object</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal array</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Spread in literal array</td>\n<td>no</td>\n</tr>\n<tr>\n<td>Calls</td>\n<td>no</td>\n</tr>\n<tr>\n<td>New</td>\n<td>no</td>\n</tr>\n<tr>\n<td>Property access</td>\n<td>yes, if target is foldable</td>\n</tr>\n<tr>\n<td>Array index</td>\n<td>yes, if target and index are foldable</td>\n</tr>\n<tr>\n<td>Identifier reference</td>\n<td>yes, if it is a reference to a local</td>\n</tr>\n<tr>\n<td>A template with no substitutions</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>A template with substitutions</td>\n<td>yes, if the substitutions are foldable</td>\n</tr>\n<tr>\n<td>Literal string</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal number</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal boolean</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal null</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Supported prefix operator</td>\n<td>yes, if operand is foldable</td>\n</tr>\n<tr>\n<td>Supported binary operator</td>\n<td>yes, if both left and right are foldable</td>\n</tr>\n<tr>\n<td>Conditional operator</td>\n<td>yes, if condition is foldable</td>\n</tr>\n<tr>\n<td>Parentheses</td>\n<td>yes, if the expression is foldable</td>\n</tr>\n</tbody>\n</table>\n<p>If an expression is not foldable, the collector writes it to <code>.metadata.json</code> as an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a> for the compiler to resolve.</p>\n<h2 id=\"phase-2-code-generation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-2-code-generation\"><i class=\"material-icons\">link</i></a>Phase 2: code generation</h2>\n<p>The <em>collector</em> makes no attempt to understand the metadata that it collects and outputs to <code>.metadata.json</code>. It represents the metadata as best it can and records errors when it detects a metadata syntax violation.</p>\n<p>It's the compiler's job to interpret the <code>.metadata.json</code> in the code generation phase.</p>\n<p>The compiler understands all syntax forms that the <em>collector</em> supports, but it may reject <em>syntactically</em> correct metadata if the <em>semantics</em> violate compiler rules.</p>\n<p>The compiler can only reference <em>exported symbols</em>.</p>\n<p>Decorated component class members must be public. You cannot make an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> property private or internal.</p>\n<p>Data bound properties must also be public.</p>\n<code-example language=\"typescript\">\n// BAD CODE - title is private\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;h1>{{title}}&#x3C;/h1>'\n})\nexport class AppComponent {\n  private title = 'My App'; // Bad\n}\n</code-example>\n<a id=\"supported-functions\"></a>\n<p>Most importantly, the compiler only generates code to create instances of certain classes, support certain decorators, and call certain functions from the following lists.</p>\n<h3 id=\"new-instances\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#new-instances\"><i class=\"material-icons\">link</i></a>New instances</h3>\n<p>The compiler only allows metadata that create instances of the class <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> from <code>@angular/core</code>.</p>\n<h3 id=\"annotationsdecorators\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#annotationsdecorators\"><i class=\"material-icons\">link</i></a>Annotations/Decorators</h3>\n<p>The compiler only supports metadata for these Angular decorators.</p>\n<table>\n<thead>\n<tr>\n<th>Decorator</th>\n<th>Module</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code><a href=\"api/core/Attribute\" class=\"code-anchor\">Attribute</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"macro-functions-and-macro-static-methods\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#macro-functions-and-macro-static-methods\"><i class=\"material-icons\">link</i></a>Macro-functions and macro-static methods</h3>\n<p>The compiler also supports <em>macros</em> in the form of functions or static\nmethods that return an expression.</p>\n<p>For example, consider the following function:</p>\n<code-example language=\"typescript\">\nexport function wrapInArray&#x3C;T>(value: T): T[] {\n  return [value];\n}\n</code-example>\n<p>You can call the <code>wrapInArray</code> in a metadata definition because it returns the value of an expression that conforms to the compiler's restrictive JavaScript subset.</p>\n<p>You might use  <code>wrapInArray()</code> like this:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n</code-example>\n<p>The compiler treats this usage as if you had written:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [TypicalComponent]\n})\nexport class TypicalModule {}\n</code-example>\n<p>The collector is simplistic in its determination of what qualifies as a macro\nfunction; it can only contain a single <code>return</code> statement.</p>\n<p>The Angular <a href=\"api/router/RouterModule\"><code>RouterModule</code></a> exports two macro static methods, <code>forRoot</code> and <code>forChild</code>, to help declare root and child routes.\nReview the <a href=\"https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">source code</a>\nfor these methods to see how macros can simplify configuration of complex <a href=\"guide/ngmodules\">NgModules</a>.</p>\n<a id=\"metadata-rewriting\"></a>\n<h3 id=\"metadata-rewriting\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-rewriting\"><i class=\"material-icons\">link</i></a>Metadata rewriting</h3>\n<p>The compiler treats object literals containing the fields <code>useClass</code>, <code>useValue</code>, <code>useFactory</code>, and <code>data</code> specially. The compiler converts the expression initializing one of these fields into an exported variable, which replaces the expression. This process of rewriting these expressions removes all the restrictions on what can be in them because\nthe compiler doesn't need to know the expression's value—it just needs to be able to generate a reference to the value.</p>\n<p>You might write something like:</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: () => TypicalServer}]\n})\nexport class TypicalModule {}\n</code-example>\n<p>Without rewriting, this would be invalid because lambdas are not supported and <code>TypicalServer</code> is not exported.</p>\n<p>To allow this, the compiler automatically rewrites this to something like:</p>\n<code-example language=\"typescript\">\nclass TypicalServer {\n\n}\n\nexport const ɵ0 = () => new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: ɵ0}]\n})\nexport class TypicalModule {}\n</code-example>\n<p>This allows the compiler to generate a reference to <code>ɵ0</code> in the\nfactory without having to know what the value of <code>ɵ0</code> contains.</p>\n<p>The compiler does the rewriting during the emit of the <code>.js</code> file. This doesn't rewrite the <code>.d.ts</code> file, however, so TypeScript doesn't recognize it as being an export. Thus, it does not pollute the ES module's exported API.</p>\n<h2 id=\"metadata-errors\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#metadata-errors\"><i class=\"material-icons\">link</i></a>Metadata Errors</h2>\n<p>The following are metadata errors you may encounter, with explanations and suggested corrections.</p>\n<p><a href=\"guide/aot-compiler#expression-form-not-supported\">Expression form not supported</a><br>\n<a href=\"guide/aot-compiler#reference-to-a-local-symbol\">Reference to a local (non-exported) symbol</a><br>\n<a href=\"guide/aot-compiler#only-initialized-variables\">Only initialized variables and constants</a><br>\n<a href=\"guide/aot-compiler#reference-to-a-non-exported-class\">Reference to a non-exported class</a><br>\n<a href=\"guide/aot-compiler#reference-to-a-non-exported-function\">Reference to a non-exported function</a><br>\n<a href=\"guide/aot-compiler#function-calls-not-supported\">Function calls are not supported</a><br>\n<a href=\"guide/aot-compiler#destructured-variable-not-supported\">Destructured variable or constant not supported</a><br>\n<a href=\"guide/aot-compiler#could-not-resolve-type\">Could not resolve type</a><br>\n<a href=\"guide/aot-compiler#name-expected\">Name expected</a><br>\n<a href=\"guide/aot-compiler#unsupported-enum-member-name\">Unsupported enum member name</a><br>\n<a href=\"guide/aot-compiler#tagged-template-expressions-not-supported\">Tagged template expressions are not supported</a><br>\n<a href=\"guide/aot-compiler#symbol-reference-expected\">Symbol reference expected</a><br></p>\n<hr>\n<h3 class=\"no-toc\" id=\"expression-form-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#expression-form-not-supported\"><i class=\"material-icons\">link</i></a>Expression form not supported</h3>\n<p>The compiler encountered an expression it didn't understand while evalutating Angular metadata.</p>\n<p>Language features outside of the compiler's <a href=\"guide/aot-compiler#expression-syntax\">restricted expression syntax</a>\ncan produce this error, as seen in the following example:</p>\n<code-example>\n// ERROR\nexport class Fooish { ... }\n...\nconst prop = typeof Fooish; // typeof is not valid in metadata\n  ...\n  // bracket notation is not valid in metadata\n  { provide: 'token', useValue: { [prop]: 'value' } };\n  ...\n</code-example>\n<p>You can use <code>typeof</code> and bracket notation in normal application code.\nYou just can't use those features within expressions that define Angular metadata.</p>\n<p>Avoid this error by sticking to the compiler's <a href=\"guide/aot-compiler#expression-syntax\">restricted expression syntax</a>\nwhen writing Angular metadata\nand be wary of new or unusual TypeScript features.</p>\n<hr>\n<a id=\"reference-to-a-local-symbol\"></a>\n<h3 class=\"no-toc\" id=\"reference-to-a-local-non-exported-symbol\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#reference-to-a-local-non-exported-symbol\"><i class=\"material-icons\">link</i></a>Reference to a local (non-exported) symbol</h3>\n<div class=\"alert is-helpful\">\n<p><em>Reference to a local (non-exported) symbol 'symbol name'. Consider exporting the symbol.</em></p>\n</div>\n<p>The compiler encountered a referenced to a locally defined symbol that either wasn't exported or wasn't initialized.</p>\n<p>Here's a <code>provider</code> example of the problem.</p>\n<code-example>\n// ERROR\nlet foo: number; // neither exported nor initialized\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p>The compiler generates the component factory, which includes the <code>useValue</code> provider code, in a separate module. <em>That</em> factory module can't reach back to <em>this</em> source module to access the local (non-exported) <code>foo</code> variable.</p>\n<p>You could fix the problem by initializing <code>foo</code>.</p>\n<code-example>\nlet foo = 42; // initialized\n</code-example>\n<p>The compiler will <a href=\"guide/aot-compiler#folding\">fold</a> the expression into the provider as if you had written this.</p>\n<code-example>\n  providers: [\n    { provide: Foo, useValue: 42 }\n  ]\n</code-example>\n<p>Alternatively, you can fix it by exporting <code>foo</code> with the expectation that <code>foo</code> will be assigned at runtime when you actually know its value.</p>\n<code-example>\n// CORRECTED\nexport let foo: number; // exported\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p>Adding <code>export</code> often works for variables referenced in metadata such as <code>providers</code> and <code>animations</code> because the compiler can generate <em>references</em> to the exported variables in these expressions. It doesn't need the <em>values</em> of those variables.</p>\n<p>Adding <code>export</code> doesn't work when the compiler needs the <em>actual value</em>\nin order to generate code.\nFor example, it doesn't work for the <code>template</code> property.</p>\n<code-example>\n// ERROR\nexport let someTemplate: string; // exported but not initialized\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p>The compiler needs the value of the <code>template</code> property <em>right now</em> to generate the component factory.\nThe variable reference alone is insufficient.\nPrefixing the declaration with <code>export</code> merely produces a new error, \"<a href=\"guide/aot-compiler#only-initialized-variables\"><code>Only initialized variables and constants can be referenced</code></a>\".</p>\n<hr>\n<a id=\"only-initialized-variables\"></a>\n<h3 class=\"no-toc\" id=\"only-initialized-variables-and-constants\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#only-initialized-variables-and-constants\"><i class=\"material-icons\">link</i></a>Only initialized variables and constants</h3>\n<div class=\"alert is-helpful\">\n<p><em>Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler.</em></p>\n</div>\n<p>The compiler found a reference to an exported variable or static field that wasn't initialized.\nIt needs the value of that variable to generate code.</p>\n<p>The following example tries to set the component's <code>template</code> property to the value of\nthe exported <code>someTemplate</code> variable which is declared but <em>unassigned</em>.</p>\n<code-example>\n// ERROR\nexport let someTemplate: string;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p>You'd also get this error if you imported <code>someTemplate</code> from some other module and neglected to initialize it there.</p>\n<code-example>\n// ERROR - not initialized there either\nimport { someTemplate } from './config';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p>The compiler cannot wait until runtime to get the template information.\nIt must statically derive the value of the <code>someTemplate</code> variable from the source code\nso that it can generate the component factory, which includes\ninstructions for building the element based on the template.</p>\n<p>To correct this error, provide the initial value of the variable in an initializer clause <em>on the same line</em>.</p>\n<code-example>\n// CORRECTED\nexport let someTemplate = '&#x3C;h1>Greetings from Angular&#x3C;/h1>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"reference-to-a-non-exported-class\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#reference-to-a-non-exported-class\"><i class=\"material-icons\">link</i></a>Reference to a non-exported class</h3>\n<div class=\"alert is-helpful\">\n<p><em>Reference to a non-exported class <class name=\"\">. Consider exporting the class.</class></em></p>\n</div>\n<p>Metadata referenced a class that wasn't exported.</p>\n<p>For example, you may have defined a class and used it as an injection token in a providers array\nbut neglected to export that class.</p>\n<code-example>\n// ERROR\nabstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<p>Angular generates a class factory in a separate module and that\nfactory <a href=\"guide/aot-compiler#exported-symbols\">can only access exported classes</a>.\nTo correct this error, export the referenced class.</p>\n<code-example>\n// CORRECTED\nexport abstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"reference-to-a-non-exported-function\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#reference-to-a-non-exported-function\"><i class=\"material-icons\">link</i></a>Reference to a non-exported function</h3>\n<p>Metadata referenced a function that wasn't exported.</p>\n<p>For example, you may have set a providers <code>useFactory</code> property to a locally defined function that you neglected to export.</p>\n<code-example>\n// ERROR\nfunction myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<p>Angular generates a class factory in a separate module and that\nfactory <a href=\"guide/aot-compiler#exported-symbols\">can only access exported functions</a>.\nTo correct this error, export the function.</p>\n<code-example>\n// CORRECTED\nexport function myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"function-calls-not-supported\"></a>\n<h3 class=\"no-toc\" id=\"function-calls-are-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#function-calls-are-not-supported\"><i class=\"material-icons\">link</i></a>Function calls are not supported</h3>\n<div class=\"alert is-helpful\">\n<p><em>Function calls are not supported. Consider replacing the function or lambda with a reference to an exported function.</em></p>\n</div>\n<p>The compiler does not currently support <a href=\"guide/aot-compiler#function-expression\">function expressions or lambda functions</a>.\nFor example, you cannot set a provider's <code>useFactory</code> to an anonymous function or arrow function like this.</p>\n<code-example>\n// ERROR\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: function() { ... } },\n    { provide: OtherStrategy, useFactory: () => { ... } }\n  ]\n  ...\n</code-example>\n<p>You also get this error if you call a function or method in a provider's <code>useValue</code>.</p>\n<code-example>\n// ERROR\nimport { calculateValue } from './utilities';\n\n  ...\n  providers: [\n    { provide: SomeValue, useValue: calculateValue() }\n  ]\n  ...\n</code-example>\n<p>To correct this error, export a function from the module and refer to the function in a <code>useFactory</code> provider instead.</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { calculateValue } from './utilities';\n\nexport function myStrategy() { ... }\nexport function otherStrategy() { ... }\nexport function someValueFactory() {\n  return calculateValue();\n}\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy },\n    { provide: OtherStrategy, useFactory: otherStrategy },\n    { provide: SomeValue, useFactory: someValueFactory }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"destructured-variable-not-supported\"></a>\n<h3 class=\"no-toc\" id=\"destructured-variable-or-constant-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#destructured-variable-or-constant-not-supported\"><i class=\"material-icons\">link</i></a>Destructured variable or constant not supported</h3>\n<div class=\"alert is-helpful\">\n<p><em>Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring.</em></p>\n</div>\n<p>The compiler does not support references to variables assigned by <a href=\"https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\">destructuring</a>.</p>\n<p>For example, you cannot write something like this:</p>\n<code-example linenums=\"false\">\n// ERROR\nimport { configuration } from './configuration';\n\n// destructured assignment to foo and bar\nconst {foo, bar} = configuration;\n  ...\n  providers: [\n    {provide: Foo, useValue: foo},\n    {provide: Bar, useValue: bar},\n  ]\n  ...\n</code-example>\n<p>To correct this error, refer to non-destructured values.</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { configuration } from './configuration';\n  ...\n  providers: [\n    {provide: Foo, useValue: configuration.foo},\n    {provide: Bar, useValue: configuration.bar},\n  ]\n  ...\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"could-not-resolve-type\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#could-not-resolve-type\"><i class=\"material-icons\">link</i></a>Could not resolve type</h3>\n<p>The compiler encountered a type and can't determine which module exports that type.</p>\n<p>This can happen if you refer to an ambient type.\nFor example, the <code>Window</code> type is an ambiant type declared in the global <code>.d.ts</code> file.</p>\n<p>You'll get an error if you reference it in the component constructor,\nwhich the compiler must statically analyze.</p>\n<code-example>\n// ERROR\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ })\nexport class MyComponent {\n  constructor (private win: Window) { ... }\n}\n</code-example>\n<p>TypeScript understands ambiant types so you don't import them.\nThe Angular compiler does not understand a type that you neglect to export or import.</p>\n<p>In this case, the compiler doesn't understand how to inject something with the <code>Window</code> token.</p>\n<p>Do not refer to ambient types in metadata expressions.</p>\n<p>If you must inject an instance of an ambiant type,\nyou can finesse the problem in four steps:</p>\n<ol>\n<li>Create an injection token for an instance of the ambiant type.</li>\n<li>Create a factory function that returns that instance.</li>\n<li>Add a <code>useFactory</code> provider with that factory function.</li>\n<li>Use <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> to inject the instance.</li>\n</ol>\n<p>Here's an illustrative example.</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nexport const WINDOW = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>('Window');\nexport function _window() { return window; }\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [\n    { provide: WINDOW, useFactory: _window }\n  ]\n})\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW) private win: Window) { ... }\n}\n</code-example>\n<p>The <code>Window</code> type in the constructor is no longer a problem for the compiler because it\nuses the <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW)</code> to generate the injection code.</p>\n<p>Angular does something similar with the <code><a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a></code> token so you can inject the browser's <code>document</code> object (or an abstraction of it, depending upon the platform in which the application runs).</p>\n<code-example linenums=\"false\">\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> }   from '@angular/core';\nimport { <a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a> } from '@angular/platform-browser';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ ... })\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(<a href=\"api/common/DOCUMENT\" class=\"code-anchor\">DOCUMENT</a>) private doc: Document) { ... }\n}\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"name-expected\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#name-expected\"><i class=\"material-icons\">link</i></a>Name expected</h3>\n<p>The compiler expected a name in an expression it was evaluating.\nThis can happen if you use a number as a property name as in the following example.</p>\n<code-example>\n// ERROR\nprovider: [{ provide: Foo, useValue: { 0: 'test' } }]\n</code-example>\n<p>Change the name of the property to something non-numeric.</p>\n<code-example>\n// CORRECTED\nprovider: [{ provide: Foo, useValue: { '0': 'test' } }]\n</code-example>\n<hr>\n<h3 class=\"no-toc\" id=\"unsupported-enum-member-name\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#unsupported-enum-member-name\"><i class=\"material-icons\">link</i></a>Unsupported enum member name</h3>\n<p>Angular couldn't determine the value of the <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\">enum member</a>\nthat you referenced in metadata.</p>\n<p>The compiler can understand simple enum values but not complex values such as those derived from computed properties.</p>\n<code-example linenums=\"false\">\n// ERROR\nenum Colors {\n  Red = 1,\n  White,\n  Blue = \"Blue\".length // computed\n}\n\n  ...\n  providers: [\n    { provide: BaseColor,   useValue: Colors.White } // ok\n    { provide: DangerColor, useValue: Colors.Red }   // ok\n    { provide: StrongColor, useValue: Colors.Blue }  // bad\n  ]\n  ...\n</code-example>\n<p>Avoid referring to enums with complicated initializers or computed properties.</p>\n<hr>\n<a id=\"tagged-template-expressions-not-supported\"></a>\n<h3 class=\"no-toc\" id=\"tagged-template-expressions-are-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#tagged-template-expressions-are-not-supported\"><i class=\"material-icons\">link</i></a>Tagged template expressions are not supported</h3>\n<div class=\"alert is-helpful\">\n<p><em>Tagged template expressions are not supported in metadata.</em></p>\n</div>\n<p>The compiler encountered a JavaScript ES2015 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\">tagged template expression</a> such as,</p>\n<code-example>\n// ERROR\nconst expression = 'funky';\nconst raw = String.raw`A tagged template ${expression} string`;\n ...\n template: '&#x3C;div>' + raw + '&#x3C;/div>'\n ...\n</code-example>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\"><code>String.raw()</code></a>\nis a <em>tag function</em> native to JavaScript ES2015.</p>\n<p>The AOT compiler does not support tagged template expressions; avoid them in metadata expressions.</p>\n<hr>\n<h3 class=\"no-toc\" id=\"symbol-reference-expected\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#symbol-reference-expected\"><i class=\"material-icons\">link</i></a>Symbol reference expected</h3>\n<p>The compiler expected a reference to a symbol at the location specified in the error message.</p>\n<p>This error can occur if you use an expression in the <code>extends</code> clause of a class.</p>\n<!--\n\nChuck: After reviewing your PR comment I'm still at a loss. See [comment there](https://github.com/angular/angular/pull/17712#discussion_r132025495).\n\n-->\n<a id=\"binding-expresion-validation\"></a>\n<h2 id=\"phase-3-binding-expression-validation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#phase-3-binding-expression-validation\"><i class=\"material-icons\">link</i></a>Phase 3: binding expression validation</h2>\n<p>  In the validation phase, the Angular template compiler uses the TypeScript compiler to validate the\nbinding expressions in templates. Enable this phase explicity by adding the compiler\noption <code>\"fullTemplateTypeCheck\"</code> in the <code>\"angularCompilerOptions\"</code> of the project's <code>tsconfig.json</code> (see\n<a href=\"guide/aot-compiler#compiler-options\">Angular Compiler Options</a>).</p>\n<p>  Template validation produces error messages when a type error is detected in a template binding\nexpression, similar to how type errors are reported by the TypeScript compiler against code in a <code>.ts</code>\nfile.</p>\n<p>  For example, consider the following component:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{person.addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<p>  This will produce the following error:</p>\n<code-example>\nmy.component.ts.MyComponent.html(1,1): : Property 'addresss' does not exist on type 'Person'. Did you mean 'address'?\n</code-example>\n<p>  The file name reported in the error message, <code>my.component.ts.MyComponent.html</code>, is a synthetic file\ngenerated by the template compiler that holds contents of the <code>MyComponent</code> class template.\nCompiler never writes this file to disk. The line and column numbers are relative to the template string\nin the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> annotation of the class, <code>MyComponent</code> in this case. If a component uses\n<code>templateUrl</code> instead of <code>template</code>, the errors are reported in the HTML file refereneced by the\n<code>templateUrl</code> instead of a synthetic file.</p>\n<p>  The error location is the beginning of the text node that contains the interpolation expression with\nthe error. If the error is in an attribute binding such as <code>[value]=\"person.address.street\"</code>, the error\nlocation is the location of the attribute that contains the error.</p>\n<p>  The validation uses the TypeScript type checker and the options supplied to the TypeScript compiler to control\nhow detailed the type validation is. For example, if the <code>strictTypeChecks</code> is specified, the error  <code>my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'</code> is reported as well as the above error message.</p>\n<h3 id=\"type-narrowing\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#type-narrowing\"><i class=\"material-icons\">link</i></a>Type narrowing</h3>\n<p>  The expression used in an <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> directive is used to narrow type unions in the Angular\ntemplate compiler, the same way the <code>if</code> expression does in TypeScript. For example, to avoid\n<code>Object is possibly 'undefined'</code> error in the template above, modify it to only emit the\ninterpolation if the value of <code>person</code> is initialized as shown below:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.addresss.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<p>  Using <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> allows the TypeScript compiler to infer that the <code>person</code> used in the\nbinding expression will never be <code>undefined</code>.</p>\n<h4 id=\"custom-ngif-like-directives\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#custom-ngif-like-directives\"><i class=\"material-icons\">link</i></a>Custom <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> like directives</h4>\n<p>  Directives that behave like <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> can declare that they want the same treatment by including\na static member marker that is a signal to the template compiler to treat them\nlike <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>. This static member for <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> is:</p>\n<code-example language=\"typescript\">\n  public <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> ngIfUseIfTypeGuard: void;\n</code-example>\n<p>  This declares that the input property <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> of the <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> directive should be treated as a\nguard to the use of its template, implying that the template will only be instantiated if\nthe <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> input property is true.</p>\n<h3 id=\"non-null-type-assertion-operator\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#non-null-type-assertion-operator\"><i class=\"material-icons\">link</i></a>Non-null type assertion operator</h3>\n<p>  Use the <a href=\"guide/template-syntax#non-null-assertion-operator\">non-null type assertion operator</a>\nto suppress the <code>Object is possibly 'undefined'</code> error when it is incovienent to use\n<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> or when some constraint in the component ensures that the expression is always\nnon-null when the binding expression is interpolated.</p>\n<p>  In the following example, the <code>person</code> and <code>address</code> properties are always set together,\nimplying that <code>address</code> is always non-null if <code>person</code> is non-null. There is no convenient\nway to describe this constraint to TypeScript and the template compiler, but the error\nis suppressed in the example by using <code>address!.street</code>.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person\"> {{person.name}} lives on {{address!.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n</code-example>\n<p>  The non-null assertion operator should be used sparingly as refactoring of the component\nmight break this constraint.</p>\n<p>  In this example it is recommended to include the checking of <code>address</code>\nin the <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>as shown below:</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '&#x3C;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"person &#x26;&#x26; address\"> {{person.name}} lives on {{address.street}} &#x3C;/span>'\n})\nclass MyComponent {\n  person?: Person;\n  address?: Address;\n\n  setData(person: Person, address: Address) {\n    this.person = person;\n    this.address = address;\n  }\n}\n</code-example>\n<h3 id=\"disabling-type-checking-using-any\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#disabling-type-checking-using-any\"><i class=\"material-icons\">link</i></a>Disabling type checking using <code>$any()</code></h3>\n<p>  Disable checking of a binding expression by surrounding the expression\nin a call to the <a href=\"guide/template-syntax\"><code>$any()</code> cast pseudo-function</a>.\nThe compiler treats it as a cast to the <code>any</code> type just like in TypeScript when a <code>&#x3C;any></code>\nor <code>as any</code> cast is used.</p>\n<p>  In the following example, the error <code>Property addresss does not exist</code> is suppressed\nby casting <code>person</code> to the <code>any</code> type.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: '{{$any(person).addresss.street}}'\n})\nclass MyComponent {\n  person?: Person;\n}\n</code-example>\n<h2 id=\"summary\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/aot-compiler#summary\"><i class=\"material-icons\">link</i></a>Summary</h2>\n<ul>\n<li>What the AOT compiler does and why it is important.</li>\n<li>Why metadata must be written in a subset of JavaScript.</li>\n<li>What that subset is.</li>\n<li>Other restrictions on metadata definition.</li>\n<li>Macro-functions and macro-static methods.</li>\n<li>Compiler errors related to metadata.</li>\n<li>Validation of binding expressions</li>\n</ul>\n\n</div>\n<!-- links to this doc:\n - api/upgrade/UpgradeAdapter\n - api/upgrade/UpgradeAdapterRef\n - guide/architecture-next-steps\n - guide/browser-support\n - guide/change-log\n - guide/deployment\n - guide/npm-packages\n - guide/quickstart\n - guide/universal\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/common/DOCUMENT\n - api/common/NgIf\n - api/core/Attribute\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/Host\n - api/core/HostBinding\n - api/core/HostListener\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/core/Optional\n - api/core/Output\n - api/core/Pipe\n - api/core/Self\n - api/core/SkipSelf\n - api/core/ViewChild\n - api/router/RouterLinkWithHref\n - api/router/RouterModule\n - api/upgrade/static\n - guide/aot-compiler#allowemptycodegenfiles\n - guide/aot-compiler#angular-compilation\n - guide/aot-compiler#angular-compiler-options\n - guide/aot-compiler#angular-metadata-and-aot\n - guide/aot-compiler#annotateforclosurecompiler\n - guide/aot-compiler#annotationsas\n - guide/aot-compiler#annotationsdecorators\n - guide/aot-compiler#binding-expresion-validation\n - guide/aot-compiler#compiler-options\n - guide/aot-compiler#could-not-resolve-type\n - guide/aot-compiler#custom-ngif-like-directives\n - guide/aot-compiler#destructured-variable-not-supported\n - guide/aot-compiler#destructured-variable-or-constant-not-supported\n - guide/aot-compiler#disableexpressionlowering\n - guide/aot-compiler#disabling-type-checking-using-any\n - guide/aot-compiler#enablelegacytemplate\n - guide/aot-compiler#exported-symbols\n - guide/aot-compiler#expression-form-not-supported\n - guide/aot-compiler#expression-syntax\n - guide/aot-compiler#flatmoduleid\n - guide/aot-compiler#flatmoduleoutfile\n - guide/aot-compiler#foldable-syntax\n - guide/aot-compiler#folding\n - guide/aot-compiler#fulltemplatetypecheck\n - guide/aot-compiler#function-calls-are-not-supported\n - guide/aot-compiler#function-calls-not-supported\n - guide/aot-compiler#function-expression\n - guide/aot-compiler#generatecodeforlibraries\n - guide/aot-compiler#how-aot-works\n - guide/aot-compiler#limited-function-calls\n - guide/aot-compiler#macro-functions-and-macro-static-methods\n - guide/aot-compiler#metadata-errors\n - guide/aot-compiler#metadata-restrictions\n - guide/aot-compiler#metadata-rewriting\n - guide/aot-compiler#name-expected\n - guide/aot-compiler#new-instances\n - guide/aot-compiler#no-arrow-functions\n - guide/aot-compiler#non-null-type-assertion-operator\n - guide/aot-compiler#only-initialized-variables\n - guide/aot-compiler#only-initialized-variables-and-constants\n - guide/aot-compiler#phase-1-analysis\n - guide/aot-compiler#phase-2-code-generation\n - guide/aot-compiler#phase-3-binding-expression-validation\n - guide/aot-compiler#preservewhitespaces\n - guide/aot-compiler#reference-to-a-local-non-exported-symbol\n - guide/aot-compiler#reference-to-a-local-symbol\n - guide/aot-compiler#reference-to-a-non-exported-class\n - guide/aot-compiler#reference-to-a-non-exported-function\n - guide/aot-compiler#skipmetadataemit\n - guide/aot-compiler#skiptemplatecodegen\n - guide/aot-compiler#strictinjectionparameters\n - guide/aot-compiler#strictmetadataemit\n - guide/aot-compiler#summary\n - guide/aot-compiler#supported-functions\n - guide/aot-compiler#symbol-reference-expected\n - guide/aot-compiler#tagged-template-expressions-are-not-supported\n - guide/aot-compiler#tagged-template-expressions-not-supported\n - guide/aot-compiler#the-ahead-of-time-aot-compiler\n - guide/aot-compiler#trace\n - guide/aot-compiler#type-narrowing\n - guide/aot-compiler#unsupported-enum-member-name\n - guide/aot-compiler#why-compile-with-aot\n - guide/ngmodules\n - guide/template-syntax\n - guide/template-syntax#non-null-assertion-operator\n - http://usejsdoc.org/\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\n - https://en.wikipedia.org/wiki/Abstract_syntax_tree\n - https://github.com/angular/angular-cli/wiki\n - https://github.com/angular/angular-cli/wiki/build\n - https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts\n - https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\n - https://github.com/angular/tsickle\n - https://github.com/google/closure-compiler\n - https://webpack.js.org/\n - https://www.typescriptlang.org/docs/handbook/enums.html\n - https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\n - https://www.youtube.com/watch?v=kW9cJsvcsGo\n-->"
}