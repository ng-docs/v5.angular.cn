{
  "id" : "guide/template-syntax",
  "title" : "模板语法",
  "contents" : "<div class=\"content\">\n<h1 id=\"template-syntax\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvkmc885n2o215g352dg31de4\"><i class=\"material-icons\">link</i>模板语法</h1>\n<style>\n  h4 {font-size: 17px !important; text-transform: none !important;}\n  .syntax { font-family: Consolas, 'Lucida Sans', Courier, sans-serif; color: black; font-size: 85%; }\n  h4 .syntax { font-size: 100%; }\n</style>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wisgqvl5cxyhaah2nv9fjy8t\">Angular 应用管理着用户所见和所能做的事情，通过组件类实例（即\n<em>组件</em>）与其面向用户的模板之间的交互来实现。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ef1xtpibs48i1ypjpm1finr4\">你可能从模型-视图-控制器 (MVC) 或模型-视图-视图模型 (MVVM) 的经验中熟悉组件/模板的二元性。在 Angular 中，组件扮演着控制器/视图模型的角色，而模板则代表视图。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"euzetov76tg9k7l2fvn6nn07h\">此页面是 Angular 模板语言的全面技术参考。它解释了模板语言的基本原理，并描述了你在文档其他地方遇到的语法的大部分内容。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ddvwyd21tdp4kuw20gryx3is\">许多代码片段阐明了要点和概念，所有这些代码片段都可以在 \n<live-example title=\"Template Syntax Live Code\"></live-example> 中找到。</p>\n<a id=\"html\"></a>\n<h2 id=\"html-in-templates\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97us4aru33y86l9tnt9m0rwbb\"><i class=\"material-icons\">link</i>模板中的 HTML</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dc2gs79hd48fnm9dfk4zycf6x\">HTML 是 Angular 模板的语言。 几乎所有 HTML 语法都是有效的模板语法。 \n<code>&lt;script&gt;</code> 元素是一个显著的例外； 它是被禁止的，消除了脚本注入攻击的风险。 实际上，\n<code>&lt;script&gt;</code> 会被忽略，并在浏览器控制台中显示警告。 有关详细信息，请参阅 \n<a href=\"guide/security\">安全</a> 页面。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"js7lcc5f3g2qevs247vc2g2u\">某些合法的 HTML 在模板中没有意义。 \n<code>&lt;html&gt;</code>、\n<code>&lt;body&gt;</code> 和 \n<code>&lt;base&gt;</code> 元素没有用处。 几乎所有其他元素都可以使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aap5lo7gkk4w5bwixj0x1opek\">你可以使用组件和指令扩展模板的 HTML 词汇表，这些组件和指令会以新元素和属性的形式出现。 在接下来的部分中，你将学习如何通过数据绑定动态地获取和设置 DOM（文档对象模型）值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3bcqz16p1gno699g8kz3hx2wy\">从数据绑定的第一种形式——插值——开始，看看模板 HTML 可以变得多么丰富。</p>\n<hr>\n<a id=\"interpolation\"></a>\n<h2 id=\"interpolation----\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bilvnpv5pqtbb9urtgfgjoydq\"><i class=\"material-icons\">link</i>插值（\n<span class=\"syntax\">{﻿{...}}</span>）</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"79f9b45rxsffi9nquf8r3gss7\">你在学习 Angular 的早期就接触过插值语法中的双花括号 \n<code>{{</code> 和 \n<code>}}</code>。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"first-interpolation\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;p&gt;My current hero is {{currentHero.name}}&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4m0lz9rzqww4di6dmjcxbxcru\">你使用插值将计算后的字符串编织到 HTML 元素标签之间的文本中，以及属性赋值中。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"title+image\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;h3&gt;\n  {{title}}\n  &lt;img src=\"{{heroImageUrl}}\" <a href=\"api/animations/style\" class=\"code-anchor\">style</a>=\"height:30px\"&gt;\n&lt;/h3&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bmgwqsbvwdsk4ltd3lwxlfk4x\">花括号之间的文本通常是组件属性的名称。Angular 会将该名称替换为对应组件属性的字符串值。在上面的示例中，Angular 会求值 \n<code>title</code> 和 \n<code>heroImageUrl</code> 属性，并“填补空白”，首先显示一个粗体的应用程序标题，然后显示一个英雄图像。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6amjy3tud4n227m41wf2qyrl3\">更一般地说，花括号之间的文本是一个\n<strong>模板表达式</strong>，Angular 首先\n<strong>求值</strong>，然后\n<strong>转换为字符串</strong>。以下插值通过添加两个数字来说明这一点：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"sum-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- \"The sum of 1 + 1 is 2\" --&gt;\n&lt;p&gt;The sum of 1 + 1 is {{1 + 1}}&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xnk1hw683pzq2ocqfb5e5fb1\">表达式可以调用宿主组件的方法，例如 \n<code>getVal()</code>，这里可以看到：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"sum-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- \"The sum of 1 + 1 is not 4\" --&gt;\n&lt;p&gt;The sum of 1 + 1 is not {{1 + 1 + getVal()}}&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ewh8k9p2n8in8j28nlp2atji5\">Angular 会求值所有双花括号中的表达式，将表达式结果转换为字符串，并将它们与相邻的字面量字符串连接起来。最后，它将此组合的插值结果\n<strong>赋值给元素或指令属性</strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdnv7zrz0trqbs1cft39rarbe\">你似乎是在元素标签之间插入结果，并将其赋值给属性。这样想很方便，而且你很少会因为这个错误而吃亏。虽然这并不完全正确。插值是一种特殊的语法，Angular 会将其转换为\n<a href=\"guide/template-syntax#property-binding\">属性绑定</a>，正如\n<a href=\"guide/template-syntax#property-binding-or-interpolation\">下面</a>所解释的那样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwq76gvcc8ux8ay2shfg1tbe4\">但首先，让我们仔细看看模板表达式和语句。</p>\n<hr>\n<a id=\"template-expressions\"></a>\n<h2 id=\"template-expressions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"am4hh22tcldwj6j1mymej7k9a\"><i class=\"material-icons\">link</i>模板表达式</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"90w0kakwau7v1p5fov99tkbse\">模板\n<strong>表达式</strong>会产生一个值。Angular 会执行表达式，并将它赋值给绑定目标的属性；目标可能是 HTML 元素、组件或指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jwzbgnjy6tr9f89kkmkvp3kp\"><code>{{1 + 1}}</code> 中的插值花括号包围着模板表达式 \n<code>1 + 1</code>。在下面的\n<a href=\"guide/template-syntax#property-binding\">属性绑定</a>部分，模板表达式出现在 \n<code>=</code> 符号右边的引号中，如 \n<code>[property]=\"expression\"</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cmoh7lazbdfstggwgnxc4i2i\">你用一种看起来像 JavaScript 的语言编写这些模板表达式。许多 JavaScript 表达式都是合法的模板表达式，但并非所有表达式都是合法的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7zftgv2lmgxs4yroodah558mc\">禁止使用具有或促进副作用的 JavaScript 表达式，包括：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1d7xicy18z5k9s3dyuvfirelg\">赋值（\n<code>=</code>、\n<code>+=</code>、\n<code>-=</code>、...）</li>\n<li><code>new</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3saiq87tpn9j8wipkchmlja3s\">使用 \n<code>;</code> 或 \n<code>,</code> 连接表达式</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xjl6f5pj6h1qc776cw0gxaj8\">自增和自减运算符（\n<code>++</code> 和 \n<code>--</code>）</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1qccswl3y9mnxon20ey6ojp2y\">和 JavaScript 语法的其它显著差异包括：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71wvwou6v2uyt694sj2lusyaz\">不支持位运算符 \n<code>|</code> 和 \n<code>&amp;</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cg454sot86wcd22ax43vn96m\">新的\n<a href=\"guide/template-syntax#expression-operators\">模板表达式运算符</a>，例如 \n<code>|</code>、\n<code>?.</code> 和 \n<code>!</code>。</li>\n</ul>\n<a id=\"expression-context\"></a>\n<h3 id=\"expression-context\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"hlg7poy4z2utivz797sb1eid\"><i class=\"material-icons\">link</i>表达式上下文</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2oedcl80kar4fwyob8ydb26ff\"><em>表达式上下文</em>通常是\n<em>组件</em>实例。在以下代码片段中，双花括号中的 \n<code>title</code> 和引号中的 \n<code>isUnchanged</code> 指的是 \n<code>AppComponent</code> 的属性。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-component-expression\" title=\"src/app/app.component.html\" linenums=\"false\">\n{{title}}\n&lt;span [hidden]=\"isUnchanged\"&gt;changed&lt;/span&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9tdstbhto0dg0mf9gza1mfg6w\">表达式也可以引用\n<em>模板</em>上下文的属性，例如\n<a href=\"guide/template-syntax#template-input-variable\">模板输入变量</a>（\n<code>let hero</code>）或\n<a href=\"guide/template-syntax#ref-vars\">模板引用变量</a>（\n<code>#heroInput</code>）。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-var\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;\n&lt;input #heroInput&gt; {{heroInput.value}}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51g2uknwmcuns3k03c2fdza8o\">表达式中术语的上下文是\n<em>模板变量</em>、指令的\n<em>上下文</em>对象（如果有）和组件的\n<em>成员</em>的混合。如果你引用一个属于多个命名空间的名称，模板变量名称优先，其次是指令的\n<em>上下文</em>中的名称，最后是组件的成员名称。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drxiw9fwnyn4oo4n7vaeo0tyw\">前面的示例展示了这种名称冲突。组件有一个 \n<code>hero</code> 属性，\n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 定义了一个 \n<code>hero</code> 模板变量。\n<code>{{hero.name}}</code> 中的 \n<code>hero</code> 指的是模板输入变量，而不是组件的属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"19snq2p57jqmoqbw8ut6je199\">模板表达式不能引用全局命名空间中的任何内容（除了 \n<code>undefined</code>）。它们不能引用 \n<code>window</code> 或 \n<code>document</code>。它们不能调用 \n<code>console.log</code> 或 \n<code>Math.max</code>。它们仅限于引用表达式上下文的成员。</p>\n<a id=\"no-side-effects\"></a>\n<a id=\"expression-guidelines\"></a>\n<h3 id=\"expression-guidelines\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wg29zxk2gokyawy31egvc2rm\"><i class=\"material-icons\">link</i>表达式指南</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jwgusbjha65m9garwqs5h6v5\">模板表达式可以成就或毁掉一个应用程序。请遵循以下指南：</p>\n<ul>\n<li><a href=\"guide/template-syntax#no-visible-side-effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4pv194tfabfbvvfsaj7nupvm5\">没有可见的副作用</a></li>\n<li><a href=\"guide/template-syntax#quick-execution\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"onkjlktrx0o2qf6j55c3tbgi\">快速执行</a></li>\n<li><a href=\"guide/template-syntax#simplicity\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4usspaef115qgxkpvaadwipws\">简单性</a></li>\n<li><a href=\"guide/template-syntax#idempotence\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4si2ep9vhs6cekg7hgfdq9g1o\">幂等性</a></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axvdjnnfhxy3axxxbjdnca16j\">这些指南的唯一例外情况应该是你完全理解的特定情况。</p>\n<h4 id=\"no-visible-side-effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4pv194tfabfbvvfsaj7nupvm5\"><i class=\"material-icons\">link</i>没有可见的副作用</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6d8zrytvwbwx7hgpbas6nu2w2\">模板表达式不应更改任何应用程序状态，除了目标属性的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2pq6x7vwhz1haqjze8903pxg8\">此规则对于 Angular 的“单向数据流”策略至关重要。你不应该担心读取组件值可能会更改其他显示的值。在单个渲染过程中，视图应该保持稳定。</p>\n<h4 id=\"quick-execution\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"onkjlktrx0o2qf6j55c3tbgi\"><i class=\"material-icons\">link</i>快速执行</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dfw2v83a5y56l8ekppkruyzhy\">Angular 在每次变更检测周期后执行模板表达式。变更检测周期由许多异步活动触发，例如 Promise 求解、HTTP 结果、计时器事件、按键和鼠标移动。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"chz00pvfxqcufj8rxitk1s7d3\">表达式应该快速完成，否则用户体验可能会拖慢，尤其是在速度较慢的设备上。如果计算成本很高，请考虑缓存值。</p>\n<h4 id=\"simplicity\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4usspaef115qgxkpvaadwipws\"><i class=\"material-icons\">link</i>简单性</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8ihkikdkr8toh6gujzhq9t6z\">虽然可以编写相当复杂的模板表达式，但你应该避免它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bez9tdvfe9eir4i4idx2bt5m2\">属性名称或方法调用应该是常态。偶尔的布尔否定（\n<code>!</code>）是可以的。否则，将应用程序和业务逻辑限制在组件本身，这样更容易开发和测试。</p>\n<h4 id=\"idempotence\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4si2ep9vhs6cekg7hgfdq9g1o\"><i class=\"material-icons\">link</i>幂等性</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8t7juhztn8g96xgr484hmlvl9\">一个\n<a href=\"https://en.wikipedia.org/wiki/Idempotence\">幂等</a>表达式是理想的，因为它没有副作用，并且可以提高 Angular 的变更检测性能。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bp84wdv6ych6e4kdafdyv66z9\">在 Angular 术语中，幂等表达式始终返回\n<em>完全相同的东西</em>，直到它的某个依赖值发生变化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hv5xq1jpe6mlnd2ixee70h5y\">依赖值不应在事件循环的单个循环中发生变化。如果幂等表达式返回一个字符串或一个数字，那么它在连续两次调用时会返回相同的字符串或数字。如果表达式返回一个对象（包括一个 \n<code>array</code>），那么它在连续两次调用时会返回相同的对象\n<em>引用</em>。</p>\n<hr>\n<a id=\"template-statements\"></a>\n<h2 id=\"template-statements\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"a3h6h64ogldnmi7qf3gggut7p\"><i class=\"material-icons\">link</i>模板语句</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzo1z1vmquxf2il2kxdd15kh1\">模板\n<strong>语句</strong>会响应绑定目标（例如元素、组件或指令）引发的\n<strong>事件</strong>。你将在\n<a href=\"guide/template-syntax#event-binding\">事件绑定</a>部分看到模板语句，它们出现在 \n<code>=</code> 符号右边的引号中，如 \n<code>(event)=\"statement\"</code>。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-component-statement\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button (click)=\"deleteHero()\"&gt;Delete hero&lt;/button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brms3fcw62hhq4zxndvpv71zf\">模板语句\n<em>有副作用</em>。这就是事件的全部意义。它是从用户操作更新应用程序状态的方式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qvk8kdtnytc9qihyyw5cyhs7\">响应事件是 Angular 的“单向数据流”的另一面。你可以在事件循环的这次循环中自由地更改任何内容，任何地方。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8fz5zqbyd8hu2mnsg3a1v3048\">与模板表达式一样，模板\n<em>语句</em>使用一种看起来像 JavaScript 的语言。模板语句解析器与模板表达式解析器不同，它专门支持基本赋值（\n<code>=</code>）和链式表达式（使用 \n<code>;</code> 或 \n<code>,</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3j3v31bns33mjtd1vme2tf8sv\">但是，某些 JavaScript 语法是不允许的：</p>\n<ul>\n<li><code>new</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brtbf7vijrjyy471zzg5s9emr\">自增和自减运算符，\n<code>++</code> 和 \n<code>--</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d8yor9s079y7exgy0c9a867m8\">运算符赋值，例如 \n<code>+=</code> 和 \n<code>-=</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wvt2tee6ct858t60hp6196cw\">位运算符 \n<code>|</code> 和 \n<code>&amp;</code></li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3635bul1mue7jjj0hnfmzzsu\">模板\n<a href=\"guide/template-syntax#expression-operators\">表达式运算符</a></li>\n</ul>\n<h3 id=\"statement-context\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cguu1rzuch240shyt0c3o7thy\"><i class=\"material-icons\">link</i>语句上下文</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"exbmgnj3fa3hccxxt93cw3dxw\">与表达式一样，语句只能引用语句上下文中的内容，例如组件实例的事件处理方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0a8bm5apf9rztcg8prna78kh\"><em>语句上下文</em>通常是组件实例。 \n<code>(click)=\"deleteHero()\"</code> 中的 \n<em>deleteHero</em> 是数据绑定组件的方法。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-component-statement\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button (click)=\"deleteHero()\"&gt;Delete hero&lt;/button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azayfkq7oenkrqxwjek7qqhxt\">语句上下文也可以引用模板自身上下文的属性。 在以下示例中，模板 \n<code>$event</code> 对象、 \n<a href=\"guide/template-syntax#template-input-variable\">模板输入变量</a>（\n<code>let hero</code>） 和 \n<a href=\"guide/template-syntax#ref-vars\">模板引用变量</a>（\n<code>#heroForm</code>） 被传递给组件的事件处理方法。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"context-var-statement\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button (click)=\"onSave($event)\"&gt;Save&lt;/button&gt;\n&lt;button *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" (click)=\"deleteHero(hero)\"&gt;{{hero.name}}&lt;/button&gt;\n&lt;form #heroForm (ngSubmit)=\"onSubmit(heroForm)\"&gt; ... &lt;/form&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"743ov7lbrzifjcbnx6mlfasfy\">模板上下文名称优先于组件上下文名称。 在上面的 \n<code>deleteHero(hero)</code> 中，\n<code>hero</code> 是模板输入变量， 而不是组件的 \n<code>hero</code> 属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"83ywa8lf39ym2hnlcj30lv1hu\">模板语句不能引用全局命名空间中的任何内容。它们 不能引用 \n<code>window</code> 或 \n<code>document</code>。 它们不能调用 \n<code>console.log</code> 或 \n<code>Math.max</code>。</p>\n<h3 id=\"statement-guidelines\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4bs70dhai9on0lz0i3ves4zr4\"><i class=\"material-icons\">link</i>语句指南</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92jwz32dzwnmzt147wddi7j4g\">与表达式一样，避免编写复杂的模板语句。 方法调用或简单的属性赋值应该是常态。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4x8ermf5qltgq1kj9kx113nnj\">现在你已经对模板表达式和语句有所了解， 你已经准备好学习除了插值之外的各种数据绑定语法。</p>\n<hr>\n<a id=\"binding-syntax\"></a>\n<h2 id=\"binding-syntax-an-overview\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avgr3x1qxtuqxl6n0ug4bl9tb\"><i class=\"material-icons\">link</i>绑定语法：概述</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e31ge2sxzbhfdzy1091hc4185\">数据绑定是一种协调用户所见内容与应用程序数据值的机制。 虽然你可以将值推送到 HTML 并从 HTML 中拉取值， 但如果你将这些任务交给绑定框架，应用程序将更容易编写、阅读和维护。 你只需声明绑定源和目标 HTML 元素之间的绑定，并让框架完成工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"qp8ylto86w2atl2tno245u4j\">Angular 提供了许多种数据绑定。 本指南在介绍 Angular 数据绑定及其语法的高级视图之后，涵盖了其中大部分内容。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5afh9wfw52f70xrlbhvmd6xf4\">绑定类型可以分为三类，它们以数据流的方向区分： 从 \n<em>源到视图</em>、从 \n<em>视图到源</em>，以及双向序列：\n<em>视图到源到视图</em>：</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table width=\"100%\">\n  <colgroup><col width=\"30%\">\n  \n  <col width=\"50%\">\n  \n  <col width=\"20%\">\n  \n  </colgroup><tbody><tr>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7yb5og20at3evvqh9e544hlky\">数据方向</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"44qws0upbwdcbr12n38q0bn1o\">语法</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ah2oqitmaux6j3s30t2jfq45p\">类型</th>\n  </tr>\n  <tr>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0457fptdc4fu5tdq08j6tq29\">单向\n<br>从数据源\n<br>到视图目标</td>\n    <td>\n      <code-example>\n        {{expression}}\n        [target]=\"expression\"\n        bind-target=\"expression\"\n      </code-example>\n    </td>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3xkb0kgzirqyow6t00e1nqt3\">插值\n<br> 属性\n<br> 属性（Attribute）\n<br> 类\n<br> 样式</td>\n    </tr><tr>\n      <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8z4f3scpp7s42lzjm73wfs85w\">单向\n<br>从视图目标\n<br>到数据源</td>\n      <td>\n        <code-example>\n          (target)=\"statement\"\n          on-target=\"statement\"\n        </code-example>\n      </td>\n      <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xzfjw7fbe9y12ebkq06sl6bc\">事件</td>\n    </tr>\n    <tr>\n      <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ka8xfz8kd6k07pfl2vc0g79l\">双向</td>\n      <td>\n        <code-example>\n          [(target)]=\"expression\"\n          bindon-target=\"expression\"\n        </code-example>\n      </td>\n      <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ka8xfz8kd6k07pfl2vc0g79l\">双向</td>\n    </tr>\n  \n</tbody></table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wb4eztjoff6pzjburvpg4zli\">除了插值之外的绑定类型都有一个位于等号左侧的 \n<strong>目标名称</strong>， 要么用标点符号（\n<code>[]</code>、\n<code>()</code>）包围，要么以前缀（\n<code>bind-</code>、\n<code>on-</code>、\n<code>bindon-</code>）开头。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ahhvm8xmp6gafp7p8z9erdxa\">目标名称是 \n<em>属性</em> 的名称。它可能看起来像 \n<em>属性（Attribute）</em> 的名称，但它永远不是。 为了理解这种区别，你必须培养一种新的思维方式来思考模板 HTML。</p>\n<h3 id=\"a-new-mental-model\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62g213pt0ydi2wum3vsxzauux\"><i class=\"material-icons\">link</i>一种新的思维模型</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8oboc1lnh18jo0n1oagmqh0jt\">有了数据绑定的强大功能以及使用自定义标记扩展 HTML 词汇表的能力， 你很容易将模板 HTML 视为 \n<em>HTML Plus</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aeml1x8auy0c5c8cayypah5mr\">它确实 \n<em>是</em> HTML Plus。 但它也与你习惯的 HTML 大不相同。 它需要一种新的思维模型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d5lr5w7wyetrusmjr2krdqkbu\">在正常的 HTML 开发过程中，你使用 HTML 元素创建视觉结构，并 通过使用字符串常量设置元素属性来修改这些元素。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"img+button\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div class=\"special\"&gt;Mental Model&lt;/div&gt;\n&lt;img src=\"assets/images/hero.png\"&gt;\n&lt;button disabled&gt;Save&lt;/button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5n4irn4jp9t7xjy5ym01p2lv\">在 Angular 模板中，你仍然以这种方式创建结构并初始化属性值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pzsk93i7sv7430ebc8cdve2i\">然后你学习使用封装了 HTML 的组件创建新元素，并将它们像原生 HTML 元素一样放入模板中。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"hero-detail-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- Normal HTML --&gt;\n&lt;div class=\"special\"&gt;Mental Model&lt;/div&gt;\n&lt;!-- Wow! A new element! --&gt;\n&lt;app-hero-detail&gt;&lt;/app-hero-detail&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c8atni1mi5nn82adaly6foq68\">这就是 HTML Plus。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9t6ac1m5s5006c67lw3pfwfp7\">然后你学习数据绑定。你遇到的第一个绑定可能看起来像这样：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"disabled-button-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- Bind button disabled <a href=\"api/animations/state\" class=\"code-anchor\">state</a> to `isUnchanged` property --&gt;\n&lt;button [disabled]=\"isUnchanged\"&gt;Save&lt;/button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bp5u3o25y51qtgxgol2sq9w8e\">你很快就会了解到这种奇怪的方括号表示法。撇开它不谈， 你的直觉告诉你，你正在绑定到按钮的 \n<code>disabled</code> 属性，并将它设置为组件的 \n<code>isUnchanged</code> 属性的当前值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"xef7s0zah4s41hrz8wbtvvpr\">你的直觉是错误的！你日常的 HTML 思维模型具有误导性。 事实上，一旦你开始数据绑定，你就不再使用 HTML \n<em>属性（Attribute）</em>。你没有设置属性。 你正在设置 DOM 元素、组件和指令的 \n<em>属性（Property）</em>。</p>\n<div class=\"l-sub-section\">\n<h3 id=\"html-attribute-vs-dom-property\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9fnn1ay1i4ftppzczg21jtpx\"><i class=\"material-icons\">link</i>HTML 属性（Attribute）与 DOM 属性（Property）</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8kmidpheb8zxxrxrkmnmld6r\">理解 Angular 绑定工作原理的关键在于区分 HTML 属性（Attribute）和 DOM 属性（Property）。</p>\n<p><strong data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1rof7v30hk74n2w8gp223lcgb\">属性（Attribute）由 HTML 定义。属性（Property）由 DOM（文档对象模型）定义。</strong></p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8xue8nbggeoljom8rno1wl2by\">一些 HTML 属性（Attribute）与属性（Property）一一对应。\n<code>id</code> 就是一个例子。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mdvn3vkn5h5ziegc7ncfe85c\">一些 HTML 属性（Attribute）没有对应的属性（Property）。\n<code>colspan</code> 就是一个例子。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7mh0584jqnjmf9o2iaxae91uf\">一些 DOM 属性（Property）没有对应的属性（Attribute）。\n<code>textContent</code> 就是一个例子。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e2roo72cef4e25u88imtih53m\">许多 HTML 属性（Attribute）似乎映射到属性（Property）... 但并非你想象的那样！</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4k288j5msv2wnbgd4hgtukwer\">直到你掌握这条一般规则，最后一个类别才会变得清晰：</p>\n<p><strong data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4pwkzoll3bvvp1ek6oeae2vny\">属性（Attribute）\n<em>初始化</em> DOM 属性（Property），然后它们就完成了。 属性（Property）值可以更改；属性（Attribute）值不能更改。</strong></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yzqlhgucyndwpm1alukmipet\">例如，当浏览器渲染 \n<code>&lt;input type=\"text\" value=\"Bob\"&gt;</code> 时，它会创建一个 具有 \n<em>初始化</em> 为 \"Bob\" 的 \n<code>value</code> 属性（Property）的相应 DOM 节点。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cx6fhzly845x7hz9s4n1wplra\">当用户在输入框中输入 \"Sally\" 时，DOM 元素的 \n<code>value</code> \n<em>属性（Property）</em> 变成 \"Sally\"。 但 HTML \n<code>value</code> \n<em>属性（Attribute）</em> 保持不变，如果你询问输入元素 有关该属性的信息，你会发现：\n<code>input.getAttribute('value')</code> 返回 \"Bob\"。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2692y32ct4cvgwcygdx948c83\">HTML 属性（Attribute）\n<code>value</code> 指定 \n<em>初始</em> 值；DOM \n<code>value</code> 属性（Property）是 \n<em>当前</em> 值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6t2eb27qgfmgi6pt85p4w7fce\"><code>disabled</code> 属性（Attribute）是另一个特殊的例子。按钮的 \n<code>disabled</code> \n<em>属性（Property）</em> 默认情况下为 \n<code>false</code>，因此按钮处于启用状态。 当你添加 \n<code>disabled</code> \n<em>属性（Attribute）</em> 时，它本身就会将按钮的 \n<code>disabled</code> \n<em>属性（Property）</em> 初始化为 \n<code>true</code>， 因此按钮被禁用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dan8myqq368use30sss7y72s\">添加和删除 \n<code>disabled</code> \n<em>属性（Attribute）</em> 会禁用和启用按钮。\n<em>属性（Attribute）</em> 的值无关紧要， 这就是为什么你不能通过编写 \n<code>&lt;button disabled=\"false\"&gt;Still Disabled&lt;/button&gt;</code> 来启用按钮的原因。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hbt08glsh9vnw1dnbbw6dkmu\">设置按钮的 \n<code>disabled</code> \n<em>属性（Property）</em>（例如，使用 Angular 绑定）会禁用或启用按钮。 \n<em>属性（Property）</em> 的值很重要。</p>\n<p><strong data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6updg30h77tb886tuezhr0cdp\">HTML 属性（Attribute）和 DOM 属性（Property）不是一回事，即使它们具有相同的名称。</strong></p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6memhgie5oobj4gsuxueyms0m\">这个事实需要重复： \n<strong>模板绑定使用 <em>属性（Property）</em> 和 <em>事件</em>，而不是 <em>属性（Attribute）</em>。</strong></p>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5nfaag5smg51zpnb5kroxjawz\">一个没有属性（Attribute）的世界</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2ymwfcr881w2njs2glg3e3fd\">在 Angular 的世界中，属性（Attribute）的唯一作用是初始化元素和指令的状态。 当你编写数据绑定时，你只处理目标对象的属性（Property）和事件。 HTML 属性（Attribute）实际上消失了。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ckj63zwud44q2qn5pylolzwoj\">牢记此模型，继续阅读以了解绑定目标。</p>\n<h3 id=\"binding-targets\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bio31vfa1hjnlo6tpecj1e92u\"><i class=\"material-icons\">link</i>绑定目标</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9l99wuxlbvneuzxc6oq41uxcn\"><strong>数据绑定的目标</strong>是 DOM 中的某个东西。 根据绑定类型，目标可以是 （元素 | 组件 | 指令）属性，（元素 | 组件 | 指令）事件，或（很少）属性名称。 下表总结了这些内容：</p>\n<style>\n  td, th {vertical-align: top}\n</style>\n<table width=\"100%\">\n  <colgroup><col width=\"10%\">\n  \n  <col width=\"15%\">\n  \n  <col width=\"75%\">\n  \n  </colgroup><tbody><tr>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ah2oqitmaux6j3s30t2jfq45p\">类型</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ekwp3w1c7vpwhdpcum5n6znfs\">目标</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"12gfwdzwspkled7tdbx2r1dec\">示例</th>\n  </tr>\n  <tr>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8inopazehx1bfxu8m1odt9y8v\">属性</td>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2kgs97nz8ulwfa739j1864u52\">元素属性\n<br> 组件属性\n<br> 指令属性</td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-syntax-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;img [src]=\"heroImageUrl\"&gt;\n&lt;app-hero-detail [hero]=\"currentHero\"&gt;&lt;/app-hero-detail&gt;\n&lt;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{'special': isSpecial}\"&gt;&lt;/div&gt;\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cr33fw17z9f43aaxlp9b5raw1\">事件</td>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58kpkocugbf6na9j6igu71z6x\">元素事件\n<br> 组件事件\n<br> 指令事件</td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-syntax-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button (click)=\"onSave()\"&gt;Save&lt;/button&gt;\n&lt;app-hero-detail (deleteRequest)=\"deleteHero()\"&gt;&lt;/app-hero-detail&gt;\n&lt;div (myClick)=\"clicked=$event\" clickable&gt;click me&lt;/div&gt;\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ee40sompdxg7265myb2wk2s5n\">双向</td>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9o65ns1i5qjjddy9gf362p275\">事件和属性</td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"2-way-binding-syntax-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"name\"&gt;\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bz9mljfwc4dib7421g62rbd8f\">属性（Attribute）</td>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3a85mu0a3l6hvl6p7x2x0n6a0\">属性 （例外）</td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"attribute-binding-syntax-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button [attr.aria-label]=\"help\"&gt;help&lt;/button&gt;\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"aki6980bejn6w979onh1e78y4\">类</td>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1rby6xwva40zbkn3v65bys5ba\"><code>class</code> 属性</td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-syntax-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div [class.special]=\"isSpecial\"&gt;Special&lt;/div&gt;\n\n</code-example>\n    </td>\n  </tr>\n  <tr>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b4gpfi5y1qbvzmo3ivq2bzwj4\">样式</td>\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"890jzugtnwg0vjxbvy61vwaev\"><code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code> 属性</td>\n    <td>\n      <code-example path=\"template-syntax/src/app/app.component.html\" region=\"style-binding-syntax-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button [style.color]=\"isSpecial ? 'red' : 'green'\"&gt;\n\n</code-example>\n    </td>\n  </tr>\n</tbody></table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8x2p5ubst7gwqzcmaged8ndf\">牢记此广阔的视角，你就可以详细了解绑定类型了。</p>\n<hr>\n<a id=\"property-binding\"></a>\n<h2 id=\"property-binding--property-\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"anfqwr0mbxbe6tug7adck3y6\"><i class=\"material-icons\">link</i>属性绑定（\n<span class=\"syntax\">[property]</span>）</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9bmfgu0z8w0yx5apy3bd4urxj\">编写一个模板\n<strong>属性绑定</strong>来设置视图元素的属性。 绑定将属性设置为 \n<a href=\"guide/template-syntax#template-expressions\">模板表达式</a> 的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bbah2145r4lcmzywbmgmriqab\">最常见的属性绑定是将元素属性设置为组件属性值。例如，将图像元素的 \n<code>src</code> 属性绑定到组件的 \n<code>heroImageUrl</code> 属性：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;img [src]=\"heroImageUrl\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"byb5j9oiztwdn4ciu2ac08t4t\">另一个例子是当组件说它 \n<code>isUnchanged</code> 时禁用按钮：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button [disabled]=\"isUnchanged\"&gt;Cancel is disabled&lt;/button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5yx319zxn0d865fkooj5yg5f7\">另一个例子是设置指令的属性：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-3\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"classes\"&gt;[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] binding to the classes property&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bczakzpf59hg5fvajkbpsn8vs\">再一个例子是设置自定义组件的模型属性（这是父组件和子组件之间进行通信的好方法）：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-4\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;app-hero-detail [hero]=\"currentHero\"&gt;&lt;/app-hero-detail&gt;\n\n</code-example>\n<h3 id=\"one-way-in\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ml0qhuw3rlgt9n4k1ucaguwl\"><i class=\"material-icons\">link</i>单向输入</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4mrlsxrvrip5mt2nxmt5r14eo\">人们通常将属性绑定描述为\n<em>单向数据绑定</em>，因为它以单向方式传递值， 从组件的数据属性流入目标元素属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epb3t2y6tbvbka3nlhifjks9i\">你不能使用属性绑定从目标元素中\n<em>提取</em>值。 你不能绑定到目标元素的属性来\n<em>读取</em>它。你只能\n<em>设置</em>它。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bv8ouv65cma5ussz180xsd7x4\">同样，你不能使用属性绑定来\n<em>调用</em>目标元素上的方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6swvvb3x7xcrn3vnd4k0c9ccc\">如果元素引发事件，你可以使用 \n<a href=\"guide/template-syntax#event-binding\">事件绑定</a> 来监听它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2b6bmdrwhee41jqyrsqjwf69b\">如果你必须读取目标元素属性或调用其方法之一， 你需要使用不同的技术。 请参阅 API 参考以了解 \n<a href=\"api/core/ViewChild\">ViewChild</a> 和 \n<a href=\"api/core/ContentChild\">ContentChild</a>。</p>\n</div>\n<h3 id=\"binding-target\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"anu2op21mru85wpirapczf0yt\"><i class=\"material-icons\">link</i>绑定目标</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76mstjrucp9tahizvvm5afyfr\">包含在方括号中的元素属性标识目标属性。 以下代码中的目标属性是图像元素的 \n<code>src</code> 属性。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;img [src]=\"heroImageUrl\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b1em9gkb5zw6b43ov32h6dfch\">有些人更喜欢 \n<code>bind-</code> 前缀的替代方案，称为\n<em>规范形式</em>：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-5\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;img bind-src=\"heroImageUrl\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6wa2f41xawnwhqwxg9ecwizkn\">目标名称始终是属性的名称，即使它看起来像是其他东西的名称。 你看到 \n<code>src</code> 可能会认为它是属性的名称。不。它是图像元素属性的名称。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1aeksmwslfp2b2e69n5aiura8\">元素属性可能是更常见的目标， 但 Angular 首先会查看该名称是否是已知指令的属性， 就像以下示例一样：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-3\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"classes\"&gt;[<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>] binding to the classes property&lt;/div&gt;\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3af48krdtt2r0q1blwqrkfq23\">从技术上讲，Angular 将名称与指令 \n<a href=\"guide/template-syntax#inputs-outputs\">输入</a> 进行匹配， 即指令的 \n<code>inputs</code> 数组中列出的属性名称之一，或用 \n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 装饰的属性。 这些输入映射到指令自己的属性。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a389mkq4ona4ffh3yczzmebg9\">如果名称与已知指令或元素的属性不匹配，Angular 会报告“未知指令”错误。</p>\n<h3 id=\"avoid-side-effects\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bd4pltks40kz7847m4fkjfgpr\"><i class=\"material-icons\">link</i>避免副作用</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cetghrg7lqypthlihvd87h4yg\">如前所述，模板表达式的求值不应有任何可见的副作用。 表达式语言本身尽其所能来保证你的安全。 你不能在属性绑定表达式中为任何东西赋值，也不能使用自增和自减运算符。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eez7u233ajomp8l0vcdgyk2m8\">当然，表达式可能会调用具有副作用的属性或方法。 Angular 无法知道这一点，也无法阻止你。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9h4winn38by7u62rneej9mbou\">表达式可以调用类似 \n<code>getFoo()</code> 的东西。只有你知道 \n<code>getFoo()</code> 做了什么。 如果 \n<code>getFoo()</code> 改变了一些东西，而你恰好绑定到那个东西，你可能会遇到不愉快的体验。 Angular 可能会或可能不会显示更改后的值。Angular 可能会检测到更改并抛出警告错误。 一般来说，坚持使用数据属性和返回值且不做其他事情的方法。</p>\n<h3 id=\"return-the-proper-type\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2kt8h8ra9jbbm47w46aisqutl\"><i class=\"material-icons\">link</i>返回合适的类型</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9l1iucy900va2wz7swlm4bcri\">模板表达式应求解为目标属性期望的值类型。 如果目标属性期望字符串，则返回字符串。 如果目标属性期望数字，则返回数字。 如果目标属性期望对象，则返回对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8isz9fjwbjve5klm8v4sev8ns\"><code>HeroDetail</code> 组件的 \n<code>hero</code> 属性期望一个 \n<code>Hero</code> 对象，这正是你在属性绑定中发送的：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-4\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;app-hero-detail [hero]=\"currentHero\"&gt;&lt;/app-hero-detail&gt;\n\n</code-example>\n<h3 id=\"remember-the-brackets\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gn2h7p15tmxjmclmaw382tgg\"><i class=\"material-icons\">link</i>记住方括号</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dc0ih1iqphjdf2zbl7zwh7cpx\">方括号告诉 Angular 求解模板表达式。 如果你省略方括号，Angular 会将字符串视为常量， 并用该字符串\n<em>初始化目标属性</em>。 它\n<em>不会</em>求解字符串！</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6vlpconqo6ig6kjdlhjvcdufq\">不要犯以下错误：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-6\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- ERROR: HeroDetailComponent.hero expects <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>\n     Hero object, not the string \"currentHero\" --&gt;\n  &lt;app-hero-detail hero=\"currentHero\"&gt;&lt;/app-hero-detail&gt;\n\n</code-example>\n<a id=\"one-time-initialization\"></a>\n<h3 id=\"one-time-string-initialization\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bifuhrrllzpkvuxa1jpqfxfbd\"><i class=\"material-icons\">link</i>一次性字符串初始化</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7pva09q5gwa8yjb8j9gid7bcf\">当以下所有条件都为真时，你\n<em>应该</em>省略方括号：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"br4nf37atfp1r817sw3jc5wxa\">目标属性接受字符串值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjr4baci5r7jspqshm0h7lbvk\">该字符串是固定的值，你可以将其烘焙到模板中。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1wddt10619vo6pv4i1qrr0poh\">此初始值永远不会改变。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8vu0as8u543801zpymamkg390\">你通常以这种方式在标准 HTML 中初始化属性，它对指令和组件属性初始化同样有效。 以下示例将 \n<code>HeroDetailComponent</code> 的 \n<code>prefix</code> 属性初始化为固定字符串， 而不是模板表达式。Angular 设置它并忘记它。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-7\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;app-hero-detail prefix=\"You are my\" [hero]=\"currentHero\"&gt;&lt;/app-hero-detail&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7spspprp4n9lwt1n04exao753\">另一方面，\n<code>[hero]</code> 绑定仍然是组件 \n<code>currentHero</code> 属性的实时绑定。</p>\n<a id=\"property-binding-or-interpolation\"></a>\n<h3 id=\"property-binding-or-interpolation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2e12hewcwktpqs51xp3k8okl8\"><i class=\"material-icons\">link</i>属性绑定还是插值？</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"39hnmsf7hv19ivlse7ps9mj6c\">你通常可以在插值和属性绑定之间进行选择。 以下绑定对做同样的事情：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-vs-interpolation\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;p&gt;&lt;img src=\"{{heroImageUrl}}\"&gt; is the &lt;i&gt;interpolated&lt;/i&gt; image.&lt;/p&gt;\n&lt;p&gt;&lt;img [src]=\"heroImageUrl\"&gt; is the &lt;i&gt;property bound&lt;/i&gt; image.&lt;/p&gt;\n\n&lt;p&gt;&lt;span&gt;\"{{title}}\" is the &lt;i&gt;interpolated&lt;/i&gt; title.&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;\"&lt;span [innerHTML]=\"title\"&gt;&lt;/span&gt;\" is the &lt;i&gt;property bound&lt;/i&gt; title.&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjq5n1tl3gt09mlfp62dv3im9\">在许多情况下，\n<em>插值</em>是\n<em>属性绑定</em>的便捷替代方案。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7qpdmlx7l4tm0r1360lr1fr10\">在将数据值渲染为字符串时，从技术角度来说，没有理由偏好其中一种形式。你倾向于可读性，这往往有利于插值。你建议建立编码风格规则，并选择既符合规则又最适合当前任务的形式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ey1a8sl54vv782q50jinalngn\">当将元素属性设置为非字符串数据值时，你必须使用\n<em>属性绑定</em>。</p>\n<h4 id=\"content-security\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e4tlrbjpjbqzpelkelkdyiypr\"><i class=\"material-icons\">link</i>内容安全</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cryu4tb7c5z3o1kjuudjtvhje\">想象一下以下\n<em>恶意内容</em>。</p>\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"evil-title\" title=\"src/app/app.component.ts\" linenums=\"false\">\nevilTitle = 'Template &lt;script&gt;alert(\"evil never sleeps\")&lt;/script&gt;Syntax';\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"at8tr7r8xmop9b4jis17s8kr\">幸运的是，Angular 数据绑定会警惕危险的 HTML。它会\n<a href=\"guide/security#sanitization-and-security-contexts\"><em>无害化</em></a>这些值，然后再显示它们。它\n<strong>不会</strong>允许带有脚本标签的 HTML 泄露到浏览器中，无论是使用插值还是属性绑定。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"property-binding-vs-interpolation-sanitization\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!--\n  Angular generates warnings for these two lines as it sanitizes them\n  WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).\n --&gt;\n&lt;p&gt;&lt;span&gt;\"{{evilTitle}}\" is the &lt;i&gt;interpolated&lt;/i&gt; evil title.&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;\"&lt;span [innerHTML]=\"evilTitle\"&gt;&lt;/span&gt;\" is the &lt;i&gt;property bound&lt;/i&gt; evil title.&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7r9jvr7zd9scw1oecd0kql186\">插值处理脚本标签的方式与属性绑定不同，但两种方法都会以无害的方式渲染内容。</p>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/evil-title.png\" alt=\"evil title made safe\" width=\"500\" height=\"40\">\n</figure>\n<hr>\n<a id=\"other-bindings\"></a>\n<h2 id=\"attribute-class-and-style-bindings\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"cdkioe1e5iviiy0ltbah7sawc\"><i class=\"material-icons\">link</i>Attribute、类和样式绑定</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cdabivuscsf9ogjv9on77qiyi\">模板语法为不太适合属性绑定的场景提供了专门的单向绑定。</p>\n<h3 id=\"attribute-binding\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5muob4wh4fsl6ato4xv3jxnzs\"><i class=\"material-icons\">link</i>attribute 绑定</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0tm5qup1gg8d8c6q5p9zxmk0\">你可以使用\n<strong>属性绑定</strong>直接设置属性的值。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3bqbyukq6jcgs40e2pqnra0u\">这是绑定设置目标属性规则的唯一例外。这是唯一创建并设置属性的绑定。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78s5u4x8qfexlb9ii0k3nxh5y\">本指南反复强调，使用属性绑定设置元素属性始终优于使用字符串设置属性。为什么 Angular 提供属性绑定？</p>\n<p><strong data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"enfqp7yx5v2owek0hz40px2ud\">当没有元素属性可以绑定时，你必须使用属性绑定。</strong></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brfmv68hyy76q309u2qq2brr7\">考虑一下\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA\">ARIA</a>、\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG\">SVG</a> 和表格的 \n<code>span</code> 属性。它们是纯粹的属性。它们不对应于元素属性，也不设置元素属性。没有属性目标可以绑定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wioboj4epcplawu52lfw1erg\">当你编写类似以下代码时，这一点就会变得非常明显。</p>\n<code-example language=\"html\">\n  &lt;tr&gt;&lt;td colspan=\"{{1 + 1}}\"&gt;Three-Four&lt;/td&gt;&lt;/tr&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3xh7w7qjylqd96wev2n6m28ak\">你会得到以下错误：</p>\n<code-example format=\"nocode\">\n  Template parse errors:\n  Can't bind to 'colspan' since it isn't <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> known native property\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qtjd4hep6kptn8i6jj4vynku\">正如消息所说，\n<code>&lt;td&gt;</code> 元素没有 \n<code>colspan</code> 属性。它有 \"colspan\" \n<em>属性</em>，但插值和属性绑定只能设置\n<em>属性</em>，不能设置属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7muzcc72aytnrbh0102n2tgsw\">你需要属性绑定来创建并绑定到此类属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66qj19u7aq3a1k6lngd9k8n6j\">属性绑定语法类似于属性绑定。不是在方括号中使用元素属性，而是以\n<strong><code>attr</code></strong>前缀开头，后面跟着一个点 (\n<code>.</code>) 和属性的名称。然后，使用求解为字符串的表达式设置属性值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bljgmll25hsxdc0tw5nue7ukj\">将 \n<code>[attr.colspan]</code> 绑定到计算值：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"attrib-binding-colspan\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;table border=1&gt;\n  &lt;!--  expression calculates colspan=2 --&gt;\n  &lt;tr&gt;&lt;td [attr.colspan]=\"1 + 1\"&gt;One-Two&lt;/td&gt;&lt;/tr&gt;\n\n  &lt;!-- ERROR: There is no `colspan` property to set!\n    &lt;tr&gt;&lt;td colspan=\"{{1 + 1}}\"&gt;Three-Four&lt;/td&gt;&lt;/tr&gt;\n  --&gt;\n\n  &lt;tr&gt;&lt;td&gt;Five&lt;/td&gt;&lt;td&gt;Six&lt;/td&gt;&lt;/tr&gt;\n&lt;/table&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ep3cmwlo8ggsmtqz55wwb3xn\">以下是表格的渲染方式：</p>\n<table border=\"1px\">\n  <tbody><tr><td colspan=\"2\">One-Two</td></tr>\n  <tr><td>Five</td><td>Six</td></tr>\n </tbody></table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"akc3bccrrkoym37v5beszarig\">属性绑定的主要用例之一是设置 ARIA 属性，例如以下示例：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"attrib-binding-aria\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- create and set an aria attribute for assistive technology --&gt;\n&lt;button [attr.aria-label]=\"actionName\"&gt;{{actionName}} with Aria&lt;/button&gt;\n\n</code-example>\n<hr>\n<h3 id=\"class-binding\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"co3tnomuxbx68o7cr1ike1axd\"><i class=\"material-icons\">link</i>类绑定</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24lz3s9iisu5rouepdme5y5ic\">你可以使用\n<strong>类绑定</strong>向元素的 \n<code>class</code> 属性添加和删除 CSS 类名。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6emuqhryc6rj8qduby9sy948o\">类绑定语法类似于属性绑定。不是在方括号中使用元素属性，而是以 \n<code>class</code> 前缀开头，可选地跟着一个点 (\n<code>.</code>) 和 CSS 类的名称：\n<code>[class.class-name]</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6db23hiuetkg61n5563dzptcx\">以下示例展示了如何使用类绑定添加和删除应用程序的 \"special\" 类。以下是设置属性而不进行绑定的方法：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- standard class attribute setting  --&gt;\n&lt;div class=\"bad curly special\"&gt;Bad curly special&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6wum9st7es4kb6lstexpbpps3\">你可以用绑定到所需类名字符串来替换它；这是一种全有或全无的替换绑定。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- reset/override all class names with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> binding  --&gt;\n&lt;div class=\"bad curly special\"\n     [class]=\"badCurly\"&gt;Bad curly&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1j7tkav420684ivpjkcnht2ha\">最后，你可以绑定到特定的类名。当模板表达式求解为真值时，Angular 会添加该类。当表达式为假值时，它会删除该类。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-3\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- toggle the \"special\" class on/off with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> property --&gt;\n&lt;div [class.special]=\"isSpecial\"&gt;The class binding is special&lt;/div&gt;\n\n&lt;!-- binding to `class.special` trumps the class attribute --&gt;\n&lt;div class=\"special\"\n     [class.special]=\"!isSpecial\"&gt;This one is not so special&lt;/div&gt;\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1w09hpadnpkwqdqdstzo5a3p5\">虽然这是一种切换单个类名的不错方法，但当同时管理多个类名时，通常更喜欢使用\n<a href=\"guide/template-syntax#ngClass\">NgClass 指令</a>。</p>\n</div>\n<hr>\n<h3 id=\"style-binding\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvmucwe9ksaxgil7fr2swrug7\"><i class=\"material-icons\">link</i>样式绑定</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dwz9nfotnennmd5gg02m12a4n\">你可以使用\n<strong>样式绑定</strong>设置内联样式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7olyh4snsaoo2cneym4a8v0v4\">样式绑定语法类似于属性绑定。不是在方括号中使用元素属性，而是以 \n<code><a href=\"api/animations/style\" class=\"code-anchor\">style</a></code> 前缀开头，后面跟着一个点 (\n<code>.</code>) 和 CSS 样式属性的名称：\n<code>[style.style-property]</code>。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"style-binding-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button [style.color]=\"isSpecial ? 'red': 'green'\"&gt;Red&lt;/button&gt;\n&lt;button [style.background-color]=\"canSave ? 'cyan': 'grey'\" &gt;Save&lt;/button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ebj52xuj8ab6upt7i1p3hlnvv\">一些样式绑定样式具有单位扩展。以下示例根据条件设置字体大小，单位为“em”和“%”。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"style-binding-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button [style.font-size.em]=\"isSpecial ? 3 : 1\" &gt;Big&lt;/button&gt;\n&lt;button [style.font-size.%]=\"!isSpecial ? 150 : 50\" &gt;Small&lt;/button&gt;\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"u0pppcspnk32p76cvfr73j0u\">虽然这是一种设置单个样式的不错方法，但当同时设置多个内联样式时，通常更喜欢使用\n<a href=\"guide/template-syntax#ngStyle\">NgStyle 指令</a>。</p>\n</div>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"820whylxpi3xsahli2ws72jkm\">请注意，\n<em>样式属性</em>名称可以用\n<a href=\"guide/glossary#dash-case\">短横线分隔</a>（如上所示）或\n<a href=\"guide/glossary#camelcase\">驼峰式命名法</a>（例如 \n<code>fontSize</code>）来编写。</p>\n</div>\n<hr>\n<a id=\"event-binding\"></a>\n<h2 id=\"event-binding---event-\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vvabs2fswrafqzoc1dfg7hav\"><i class=\"material-icons\">link</i>事件绑定（\n<span class=\"syntax\">(event)</span>）</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ke2nxmm4up2ac4uy2ck7s622\">你遇到的绑定指令到目前为止都是单向流动数据：\n<strong>从组件到元素</strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqbykcv5wqta02ujfg1d0r7aa\">用户不会只是盯着屏幕看。他们会在输入框中输入文本。他们会从列表中选择项目。他们会点击按钮。此类用户操作可能会导致数据以相反的方向流动：\n<strong>从元素到组件</strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"27d8yp1ldz00dz3ro72ibh1ps\">了解用户操作的唯一方法是监听某些事件，例如按键、鼠标移动、点击和触摸。你可以通过 Angular 事件绑定来声明你对用户操作的兴趣。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bquqe47f2caqyvkholjkqwj4t\">事件绑定语法由等号左侧的\n<strong>目标事件</strong>名称（括号内）和等号右侧的带引号的\n<a href=\"guide/template-syntax#template-statements\">模板语句</a>组成。以下事件绑定监听按钮的点击事件，并在每次点击发生时调用组件的 \n<code>onSave()</code> 方法：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button (click)=\"onSave()\"&gt;Save&lt;/button&gt;\n\n</code-example>\n<h3 id=\"target-event\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1br47g9xr7124gzhd7pn04ca4\"><i class=\"material-icons\">link</i>目标事件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8pp4ldttjkn5k2j8f8tr9a1yt\"><strong>括号内的名称</strong>（例如 \n<code>(click)</code>）标识目标事件。在以下示例中，目标是按钮的点击事件。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button (click)=\"onSave()\"&gt;Save&lt;/button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5zswhkgz1epipt6gddaupo48r\">有些人更喜欢 \n<code>on-</code> 前缀的替代方案，称为\n<strong>规范形式</strong>：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button on-click=\"onSave()\"&gt;On Save&lt;/button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"xfvnyt0sw9w3xkvfouou7sn6\">元素事件可能是更常见的目标，但 Angular 首先会查看名称是否与已知指令的事件属性匹配，就像以下示例一样：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-3\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- `myClick` is an event on the custom `ClickDirective` --&gt;\n&lt;div (myClick)=\"clickMessage=$event\" clickable&gt;click with myClick&lt;/div&gt;\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dkvjqs1q877m78ls9qlllhdjt\"><code>myClick</code> 指令在\n<a href=\"guide/template-syntax#aliasing-io\">别名输入/输出属性</a>部分有更详细的描述。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cm6bc2m462pwdwioh2khr3c51\">如果名称与元素事件或已知指令的输出属性不匹配，Angular 会报告“未知指令”错误。</p>\n<h3 id=\"event-and-event-handling-statements\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"42k5uznnqhtn31grit1furqx6\"><i class=\"material-icons\">link</i><em>$event</em> 和事件处理语句</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"754zzz1wxwdxsj7biacy09w4l\">在事件绑定中，Angular 为目标事件设置事件处理程序。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rrbz1xxaj2z4v60vt1sfk1m7\">当事件被触发时，处理程序会执行模板语句。模板语句通常包含一个接收器，它会对事件做出响应，例如将 HTML 控件中的值存储到模型中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0h7mry7pndpcn3udjwz1a3xc\">绑定会通过\n<strong>名为 <code>$event</code> 的事件对象</strong>传递有关事件的信息，包括数据值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cmi6ehbdwtf7utqi9ysr8qujw\">事件对象的形状由目标事件决定。如果目标事件是原生 DOM 元素事件，则 \n<code>$event</code> 是一个\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Events\">DOM 事件对象</a>，具有 \n<code>target</code> 和 \n<code>target.value</code> 等属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eycus16ayao19kvsl9puu52n9\">考虑以下示例：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"without-NgModel\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;input [value]=\"currentHero.name\"\n       (input)=\"currentHero.name=$event.target.value\" &gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7c2agbnwfjtvg1scoh6czevrw\">此代码通过绑定到 \n<code>name</code> 属性来设置输入框的 \n<code>value</code> 属性。为了监听值的更改，代码绑定到输入框的 \n<code>input</code> 事件。当用户进行更改时，会触发 \n<code>input</code> 事件，绑定会在包含 DOM 事件对象 \n<code>$event</code> 的上下文中执行语句。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7i6threiewh8pogafw7bxtml9\">为了更新 \n<code>name</code> 属性，通过路径 \n<code>$event.target.value</code> 获取更改后的文本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"sfbe2b2v6901p857gnim6yun\">如果事件属于指令（回想一下，组件是指令），则 \n<code>$event</code> 的形状由指令决定。</p>\n<a id=\"eventemitter\"></a>\n<a id=\"custom-event\"></a>\n<h3 id=\"custom-events-with-eventemitter\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3rytxclme5xefjgl7fnqzjqq6\"><i class=\"material-icons\">link</i>使用 \n<span class=\"syntax\">EventEmitter</span> 的自定义事件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ghx5c1k43lee47kvpxixc7fd\">指令通常使用 Angular \n<a href=\"api/core/EventEmitter\">EventEmitter</a> 触发自定义事件。指令会创建一个 \n<code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 并将其公开为属性。指令调用 \n<code>EventEmitter.emit(payload)</code> 来触发事件，并传入消息负载，该负载可以是任何内容。父指令通过绑定到此属性并通过 \n<code>$event</code> 对象访问负载来监听事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3qzdysa0ae9gsqreciey5j8zk\">考虑一个 \n<code>HeroDetailComponent</code>，它呈现英雄信息并响应用户操作。虽然 \n<code>HeroDetailComponent</code> 有一个删除按钮，但它不知道如何删除英雄本身。它能做的最好的事情就是触发一个事件，报告用户的删除请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"db0w6dnrco3rh3wsc94o7nrpp\">以下是 \n<code>HeroDetailComponent</code> 中的相关摘录：</p>\n<code-example path=\"template-syntax/src/app/hero-detail.component.ts\" linenums=\"false\" title=\"src/app/hero-detail.component.ts (template)\" region=\"template-1\">\ntemplate: `\n&lt;div&gt;\n  &lt;img src=\"{{heroImageUrl}}\"&gt;\n  &lt;span [style.text-decoration]=\"lineThrough\"&gt;\n    {{prefix}} {{hero?.name}}\n  &lt;/span&gt;\n  &lt;button (click)=\"delete()\"&gt;Delete&lt;/button&gt;\n&lt;/div&gt;`\n\n</code-example>\n<code-example path=\"template-syntax/src/app/hero-detail.component.ts\" linenums=\"false\" title=\"src/app/hero-detail.component.ts (deleteRequest)\" region=\"deleteRequest\">\n// This component makes <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> request but it can't actually delete <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> hero.\ndeleteRequest = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n\ndelete() {\n  this.deleteRequest.emit(this.hero);\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azecyi3578bekjbmff6fg0ws0\">组件定义了一个 \n<code>deleteRequest</code> 属性，它返回一个 \n<code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code>。当用户点击\n<em>删除</em>时，组件会调用 \n<code>delete()</code> 方法，告诉 \n<code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 发射一个 \n<code>Hero</code> 对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7i137fo2sfowfwem869ovbnyk\">现在想象一个托管父组件，它绑定到 \n<code>HeroDetailComponent</code> 的 \n<code>deleteRequest</code> 事件。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (event-binding-to-component)\" region=\"event-binding-to-component\">\n&lt;app-hero-detail (deleteRequest)=\"deleteHero($event)\" [hero]=\"currentHero\"&gt;&lt;/app-hero-detail&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4df3g2zbg9g6x4uqa8wayyvzb\">当 \n<code>deleteRequest</code> 事件触发时，Angular 会调用父组件的 \n<code>deleteHero</code> 方法，并将\n<em>要删除的英雄</em>（由 \n<code>HeroDetail</code> 发射）传递给 \n<code>$event</code> 变量。</p>\n<h3 id=\"template-statements-have-side-effects\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6wxdmlvvs9974mqt38o566wvx\"><i class=\"material-icons\">link</i>模板语句有副作用</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6stfr1jm54kv2ge0eu0jb8eld\"><code>deleteHero</code> 方法有一个副作用：它会删除一个英雄。模板语句的副作用不仅是可以接受的，而且是预期的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kbhtyf0k2401e8jawaq9egsy\">删除英雄会更新模型，这可能会触发其他更改，包括查询和保存到远程服务器。这些更改会通过系统传播，最终显示在此视图和其他视图中。</p>\n<hr>\n<a id=\"two-way\"></a>\n<h2 id=\"two-way-binding---\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bv8ja5qglere9imou5836y8gf\"><i class=\"material-icons\">link</i>双向绑定（\n<span class=\"syntax\">[(...)]</span>）</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6o281nw63jtxnxh2jss30a8x\">你通常希望既显示数据属性，又在用户进行更改时更新该属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8h9ig09ya64dc7zi6t4y4v8ry\">在元素方面，这需要结合设置特定元素属性和监听元素更改事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4con56oul7cmhejhhgiev4ucn\">Angular 为此目的提供了一种特殊的\n<em>双向数据绑定</em>语法，即\n<strong><code>[(x)]</code></strong>。\n<code>[(x)]</code> 语法将\n<em>属性绑定</em>的方括号 \n<code>[x]</code> 与\n<em>事件绑定</em>的圆括号 \n<code>(x)</code> 结合在一起。</p>\n<div class=\"callout is-important\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8x3lnlunyc2rnyrkbn258eah8\">[( )] = 盒子里的香蕉</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cyutgmqd0lc6qmx2rczs5tlpk\">想象一个\n<em>盒子里的香蕉</em>，记住圆括号在方括号\n<em>里面</em>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d55ckwz8vd56qijry63f9ofbq\">当元素有一个名为 \n<code>x</code> 的可设置属性和一个名为 \n<code>xChange</code> 的对应事件时，\n<code>[(x)]</code> 语法很容易演示。以下是一个符合此模式的 \n<code>SizerComponent</code>。它有一个 \n<code>size</code> 值属性和一个配套的 \n<code>sizeChange</code> 事件：</p>\n<code-example path=\"template-syntax/src/app/sizer.component.ts\" title=\"src/app/sizer.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-sizer',\n  template: `\n  &lt;div&gt;\n    &lt;button (click)=\"dec()\" title=\"smaller\"&gt;-&lt;/button&gt;\n    &lt;button (click)=\"inc()\" title=\"bigger\"&gt;+&lt;/button&gt;\n    &lt;label [style.font-size.px]=\"size\"&gt;FontSize: {{size}}px&lt;/label&gt;\n  &lt;/div&gt;`\n})\nexport class SizerComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()  size: number | string;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() sizeChange = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;number&gt;();\n\n  dec() { this.resize(-1); }\n  inc() { this.resize(+1); }\n\n  resize(delta: number) {\n    this.size = Math.min(40, Math.max(8, +this.size + delta));\n    this.sizeChange.emit(this.size);\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30gzvcp34apwrkbsmbxrhw7vw\">初始 \n<code>size</code> 是来自属性绑定的输入值。点击按钮会在最小/最大值约束内增加或减少 \n<code>size</code>，然后使用调整后的 \n<code>size</code> 触发（\n<em>发射</em>）\n<code>sizeChange</code> 事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56boznd5phnqjtuofzo77e471\">以下是一个 \n<code>AppComponent.fontSizePx</code> 与 \n<code>SizerComponent</code> 双向绑定的示例：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (two-way-1)\" region=\"two-way-1\">\n&lt;app-sizer [(size)]=\"fontSizePx\"&gt;&lt;/app-sizer&gt;\n&lt;div [style.font-size.px]=\"fontSizePx\"&gt;Resizable Text&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d7hqlgf1emcsww0noy5904z54\"><code>AppComponent.fontSizePx</code> 建立了初始 \n<code>SizerComponent.size</code> 值。点击按钮通过双向绑定更新 \n<code>AppComponent.fontSizePx</code>。修改后的 \n<code>AppComponent.fontSizePx</code> 值会流向\n<em>样式</em>绑定，使显示的文本变大或变小。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e1mg741nma03zcirrm5vo8qsx\">双向绑定语法实际上只是\n<em>属性</em>绑定和\n<em>事件</em>绑定的语法糖。Angular 会将 \n<code>SizerComponent</code> 绑定\n<em>反糖化</em>为以下内容：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (two-way-2)\" region=\"two-way-2\">\n&lt;app-sizer [size]=\"fontSizePx\" (sizeChange)=\"fontSizePx=$event\"&gt;&lt;/app-sizer&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eh0yc46k98s42zdasm7zumxzm\"><code>$event</code> 变量包含 \n<code>SizerComponent.sizeChange</code> 事件的负载。当用户点击按钮时，Angular 会将 \n<code>$event</code> 值赋值给 \n<code>AppComponent.fontSizePx</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dxcu5hrilfuac0zglbewf0wd3\">显然，与单独的属性和事件绑定相比，双向绑定语法非常方便。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"v8ivc46nw0qytw6m4aseo04k\">使用双向绑定与 HTML 表单元素（如 \n<code>&lt;input&gt;</code> 和 \n<code>&lt;select&gt;</code>）一起使用会很方便。但是，没有原生 HTML 元素遵循 \n<code>x</code> 值和 \n<code>xChange</code> 事件模式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aobhydjcqv59dbzgkm732jsbx\">幸运的是，Angular \n<a href=\"guide/template-syntax#ngModel\"><em>NgModel</em></a> 指令是一个桥梁，它使表单元素能够进行双向绑定。</p>\n<hr>\n<a id=\"directives\"></a>\n<h2 id=\"built-in-directives\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"caiz9ki6ffyzkmf5op1f69ql7\"><i class=\"material-icons\">link</i>内置指令</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2aw4dr3kw4gjp85unpyalm4u1\">早期版本的 Angular 包含超过 70 个内置指令。社区贡献了许多其他指令，并且为内部应用程序创建了无数私有指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3j336c18d2whh5bxiqeqi4tyz\">在 Angular 中，你不需要那么多指令。你通常可以使用更强大、更具表现力的 Angular 绑定系统来实现相同的结果。为什么要创建一个指令来处理点击事件，而你可以编写一个像这样的简单绑定呢？</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"event-binding-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;button (click)=\"onSave()\"&gt;Save&lt;/button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3bjpyr93g4euzm7z1pwkp77fr\">你仍然可以从简化复杂任务的指令中获益。Angular 仍然附带内置指令；只是没有那么多。你也会编写自己的指令，只是没有那么多。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9gi78t2srlkb30lqnxepaisg1\">本节回顾了一些最常用的内置指令，这些指令被归类为\n<a href=\"guide/template-syntax#attribute-directives\"><em>属性</em>指令</a>或\n<a href=\"guide/template-syntax#structural-directives\"><em>结构</em>指令</a>。</p>\n<hr>\n<a id=\"attribute-directives\"></a>\n<h2 id=\"built-in-attribute-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2pcb3ezdvnhucykpyhdhogkjp\"><i class=\"material-icons\">link</i>内置\n<em>属性</em>指令</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9r9mb8952e17mbu5q3d7j3l6k\">属性指令监听并修改其他 HTML 元素、属性、属性和组件的行为。它们通常应用于元素，就像它们是 HTML 属性一样，因此得名。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"90efaepbum4h4h16hnrgqars\">在\n<a href=\"guide/attribute-directives\"><em>属性指令</em></a>指南中介绍了许多细节。许多 NgModules（如\n<a href=\"guide/router\" title=\"Routing and Navigation\"><code>RouterModule</code></a>和\n<a href=\"guide/forms\" title=\"Forms\"><code>FormsModule</code></a>）定义了自己的属性指令。本节是对最常用的属性指令的介绍：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drhkxstr4y4hlk79v6z0uanmj\"><a href=\"guide/template-syntax#ngClass\"><code>NgClass</code></a> - 添加和删除一组 CSS 类</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5zy1psubfsyzy3eu6us7wzgi3\"><a href=\"guide/template-syntax#ngStyle\"><code>NgStyle</code></a> - 添加和删除一组 HTML 样式</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uj3tlg7ikqymni6fsa5qlr28\"><a href=\"guide/template-syntax#ngModel\"><code>NgModel</code></a> - 与 HTML 表单元素进行双向数据绑定</li>\n</ul>\n<hr>\n<a id=\"ngClass\"></a>\n<h3 id=\"ngclass\">NgClass</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ea4qpmq0hglhn02psq16go7u5\">你通常通过动态添加和删除 CSS 类来控制元素的外观。你可以绑定到 \n<code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code> 来同时添加或删除多个类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4nz54o1tu3mufjfhj1vru4c9f\"><a href=\"guide/template-syntax#class-binding\">类绑定</a> 是添加或删除\n<em>单个</em>类的有效方法。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"class-binding-3a\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- toggle the \"special\" class on/off with <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> property --&gt;\n&lt;div [class.special]=\"isSpecial\"&gt;The class binding is special&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4cea9ybabev42qezg5kk5bksi\">为了同时添加或删除\n<em>多个</em> CSS 类，\n<code><a href=\"api/common/NgClass\" class=\"code-anchor\">NgClass</a></code> 指令可能是更好的选择。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ce6gg7ofq9ywz4h66b94b2s0b\">尝试将 \n<code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code> 绑定到一个键值控制对象。对象的每个键都是一个 CSS 类名；它的值为 \n<code>true</code> 表示应添加该类，\n<code>false</code> 表示应删除该类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8djnh4bog9efiavxucg2jb11n\">考虑一个 \n<code>setCurrentClasses</code> 组件方法，它使用一个对象设置组件属性 \n<code>currentClasses</code>，该对象根据三个其他组件属性的 \n<code>true</code>/\n<code>false</code> 状态添加或删除三个类：</p>\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"setClasses\" title=\"src/app/app.component.ts\" linenums=\"false\">\ncurrentClasses: {};\nsetCurrentClasses() {\n  // CSS classes: added/removed per current <a href=\"api/animations/state\" class=\"code-anchor\">state</a> of component properties\n  this.currentClasses =  {\n    'saveable': this.canSave,\n    'modified': !this.isUnchanged,\n    'special':  this.isSpecial\n  };\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4h7n071n1hre735hk9xl15yrx\">将 \n<code><a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a></code> 属性绑定添加到 \n<code>currentClasses</code> 会相应地设置元素的类：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgClass-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"currentClasses\"&gt;This div is initially saveable, unchanged, and special&lt;/div&gt;\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"btoxiqsal711xz9167u73q3f2\">由你决定何时调用 \n<code>setCurrentClasses()</code>，包括初始调用和依赖属性发生更改时。</p>\n</div>\n<hr>\n<a id=\"ngStyle\"></a>\n<h3 id=\"ngstyle\">NgStyle</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5t1cbikpukk4p9pisie4lkfsc\">你可以根据组件的状态动态设置内联样式。 使用 \n<code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> 可以同时设置多个内联样式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9d73p8smol08tepbq1bdn4py\">一个 \n<a href=\"guide/template-syntax#style-binding\">样式绑定</a> 是设置\n<em>单个</em>样式值的一种简单方法。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgStyle-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div [style.font-size]=\"isSpecial ? 'x-large' : 'smaller'\" &gt;\n  This div is x-large or smaller.\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55zdmjfpd0un5swsx5w0kfiuq\">要同时设置\n<em>多个</em>内联样式，\n<code><a href=\"api/common/NgStyle\" class=\"code-anchor\">NgStyle</a></code> 指令可能是更好的选择。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85oz18s2rsedmn14kiwn8nu7c\">尝试将 \n<code><a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a></code> 绑定到一个键值控制对象。 对象的每个键都是一个样式名称；它的值是适合该样式的任何内容。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eemid6upggzodvenn7o9kheiu\">考虑一个 \n<code>setCurrentStyles</code> 组件方法，它使用一个对象设置组件属性 \n<code>currentStyles</code>，该对象根据三个其他组件属性的状态定义三个样式：</p>\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"setStyles\" title=\"src/app/app.component.ts\" linenums=\"false\">\ncurrentStyles: {};\nsetCurrentStyles() {\n  // CSS styles: set per current <a href=\"api/animations/state\" class=\"code-anchor\">state</a> of component properties\n  this.currentStyles = {\n    'font-style':  this.canSave      ? 'italic' : 'normal',\n    'font-weight': !this.isUnchanged ? 'bold'   : 'normal',\n    'font-size':   this.isSpecial    ? '24px'   : '12px'\n  };\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f0tvy4somax2j65f1p8l5afwc\">将 \n<code><a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a></code> 属性绑定添加到 \n<code>currentStyles</code> 会相应地设置元素的样式：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgStyle-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div [<a href=\"api/common/NgStyle\" class=\"code-anchor\">ngStyle</a>]=\"currentStyles\"&gt;\n  This div is initially italic, normal weight, and extra large (24px).\n&lt;/div&gt;\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7qykudy3rg2hnk4ikp56jjnme\">由你决定何时调用 \n<code>setCurrentStyles()</code>，包括初始调用和依赖属性发生变化时。</p>\n</div>\n<hr>\n<a id=\"ngModel\"></a>\n<h3 id=\"ngmodel---two-way-binding-to-form-elements-with-ngmodel\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7aoblba8ufahjevwexx91nqwj\"><i class=\"material-icons\">link</i>NgModel - 使用 \n<span class=\"syntax\">[(ngModel)]</span> 对表单元素进行双向绑定</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d9deu0p7rgxbvxlfa2txdnju1\">在开发数据录入表单时，你通常会同时显示数据属性，并在用户进行更改时更新该属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9e4z60b2dznsml1o11vwrvk1e\">使用 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 指令进行双向数据绑定可以轻松实现这一点。以下是一个示例：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (NgModel-1)\" region=\"NgModel-1\">\n&lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"currentHero.name\"&gt;\n\n</code-example>\n<h4 id=\"formsmodule-is-required-to-use-ngmodel\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nvqdjma9wj4688cqaxqmd9qy\"><i class=\"material-icons\">link</i><em>FormsModule</em> 是使用 \n<em>ngModel</em> 所必需的</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"83r8ec5ysbxy5516qo4yrh0m9\">在双向数据绑定中使用 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 指令之前， 你必须导入 \n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 并将其添加到 NgModule 的 \n<code>imports</code> 列表中。 在 \n<a href=\"guide/forms#ngModel\">表单</a> 指南中了解有关 \n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 和 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 的更多信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"79tytg93qlpwh2cxfp695knxx\">以下是如何导入 \n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 以使 \n<code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 可用。</p>\n<code-example path=\"template-syntax/src/app/app.module.1.ts\" linenums=\"false\" title=\"src/app/app.module.ts (FormsModule import)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }  from '@angular/platform-browser';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms'; // &lt;--- JavaScript import from Angular\n\n/* Other imports */\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>  // &lt;--- import into the <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>\n  ],\n  /* Other module metadata */\n})\nexport class AppModule { }\n\n\n</code-example>\n<h4 id=\"inside-ngmodel\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fmklnrn0nlpz8lxpfw84eqfv\"><i class=\"material-icons\">link</i>在 \n<span class=\"syntax\">[(ngModel)]</span> 内部</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"896t951vf7sjzyck1h9nuy9s9\">回顾 \n<code>name</code> 绑定，请注意 你可以通过分别绑定到 \n<code>&lt;input&gt;</code> 元素的 \n<code>value</code> 属性和 \n<code>input</code> 事件来实现相同的结果。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"without-NgModel\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;input [value]=\"currentHero.name\"\n       (input)=\"currentHero.name=$event.target.value\" &gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15fjz0f63r92g2dittdmtalf4\">这很麻烦。谁记得要设置哪个元素属性以及哪个元素事件会发出用户更改？ 如何从输入框中提取当前显示的文本，以便你可以更新数据属性？ 谁愿意每次都查找这些信息？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1yscocnxl9l9njn1ew2uuw2sc\"><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 指令将这些繁琐的细节隐藏在其自己的 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 输入和 \n<code>ngModelChange</code> 输出属性后面。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgModel-3\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;input\n  [<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>]=\"currentHero.name\"\n  (ngModelChange)=\"currentHero.name=$event\"&gt;\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dqi96vkl4omv8liti6f1k79pg\"><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 数据属性设置元素的 value 属性，而 \n<code>ngModelChange</code> 事件属性 监听元素值的更改。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xj6n48gkpzo2tboiuzvapjum\">这些细节特定于每种元素类型，因此 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 指令仅适用于由 \n<a href=\"api/forms/ControlValueAccessor\">ControlValueAccessor</a> 支持的元素，该元素将元素适配到此协议。 \n<code>&lt;input&gt;</code> 框就是这些元素之一。 Angular 为所有基本 HTML 表单元素提供\n<em>值访问器</em>，并且 \n<a href=\"guide/forms\"><em>表单</em></a> 指南展示了如何绑定到它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"acpeazxcx7nv777ojl0j5rlts\">你不能将 \n<code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 应用于非表单原生元素或第三方自定义组件， 除非你编写一个合适的\n<em>值访问器</em>， 这是一种超出了本指南范围的技术。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"exwv16m51dm8c20mb7ig6azrk\">你不需要为编写的 Angular 组件编写\n<em>值访问器</em>，因为你可以 命名值和事件属性 以适合 Angular 的基本 \n<a href=\"guide/template-syntax#two-way\">双向绑定语法</a> 并完全跳过 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>。 \n<a href=\"guide/template-syntax#two-way\">上面显示的 <code>sizer</code></a> 就是这种技术的示例。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4mqcoawn1kffdenrji01nyds1\">单独的 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 绑定比绑定到元素的原生属性有所改进。你可以做得更好。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"agvcx8an8bnsw2kkky5p5sjsr\">你不应该需要两次提及数据属性。Angular 应该能够捕获 组件的数据属性并使用单个声明进行设置，它可以使用 \n<code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 语法来实现：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgModel-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"currentHero.name\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6esper9d6nsb15bvt00kx3oxn\"><code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 是你所需要的全部吗？是否有理由回退到其扩展形式？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5qikn0p9gfla683ft7bgq3w4j\"><code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 语法只能\n<em>设置</em>数据绑定属性。 如果你需要做更多的事情或做一些不同的事情，你可以编写扩展形式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9i4l4ied26lek2zfk5lecbjuu\">以下虚构的示例将输入值强制转换为大写：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgModel-4\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;input\n  [<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>]=\"currentHero.name\"\n  (ngModelChange)=\"setUppercaseName($event)\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"24amq336ygoafo63d0qw0a87f\">这里是所有这些变体的动画，包括这个大写转换的版本：</p>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/ng-model-anim.gif\" alt=\"NgModel variations\" width=\"548\" height=\"208\">\n</figure>\n<hr>\n<a id=\"structural-directives\"></a>\n<h2 id=\"built-in-structural-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qw5jm9fniu9n990pp5vz5e6o\"><i class=\"material-icons\">link</i>内置\n<em>结构型</em>指令</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"12i1vzk9weu8aano77d9g5yie\">结构型指令负责 HTML 布局。 它们塑造或重塑 DOM 的\n<em>结构</em>，通常通过添加、删除和操作 它们所附着的宿主元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"73v1ctvov3l5cttpt6y1dwe5n\">结构型指令的深入细节在 \n<a href=\"guide/structural-directives\"><em>结构型指令</em></a> 指南中介绍， 在那里你将学习：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63lvpt69wq0ij5z0jquhajltw\">为什么你 \n<a href=\"guide/structural-directives#asterisk\" title=\"The * in *ngIf\"><em>在 *ngIf 前面加上星号</em> (*)</a>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qulgus1gxtfakcv9o3ryvpca\">使用 \n<a href=\"guide/structural-directives#ngcontainer\" title=\"<ng-container>\"><code>&lt;ng-container&gt;</code></a> 在没有适合指令的宿主元素时对元素进行分组。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bawnp5v51aljfgmj7h7pahj8a\">如何编写自己的结构型指令。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wg99gry8exa049xd1f5ffbr7\">你只能对一个元素应用 \n<a href=\"guide/structural-directives#one-per-element\" title=\"one per host element\">一个结构型指令</a>。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ptfvtltxlfh6wrmtji6g5s62\"><em>本</em>节介绍常见的结构型指令：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48lxq5zsel3751d7vqf3d4g5j\"><a href=\"guide/template-syntax#ngIf\"><code>NgIf</code></a> - 有条件地将元素添加到 DOM 或从 DOM 中删除元素</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"16h88ixtu3j3mer067y7a50cf\"><a href=\"guide/template-syntax#ngSwitch\"><code>NgSwitch</code></a> - 一组指令，用于在备用视图之间切换</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fw7tk75rhf3c4idsfyt3jdrf\"><a href=\"guide/template-syntax#ngFor\">NgForOf</a> - 为列表中的每个条目重复模板</li>\n</ul>\n<hr>\n<a id=\"ngIf\"></a>\n<h3 id=\"ngif\">NgIf</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dv1zt05pcmlc8a0alguuv0334\">你可以通过将 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 指令应用于 该元素（称为\n<em>宿主元素</em>）来将元素添加到 DOM 或从 DOM 中删除元素。 将指令绑定到条件表达式，例如本示例中的 \n<code>isActive</code>。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgIf-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;app-hero-detail *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"isActive\"&gt;&lt;/app-hero-detail&gt;\n\n</code-example>\n<div class=\"alert is-critical\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e2wn1p1svf4aprl4xwmvalsnu\">不要忘记 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 前面的星号 (\n<code>*</code>)。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76wurfiw00ihzvqtutf9qkcca\">当 \n<code>isActive</code> 表达式返回一个真值时，\n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 会将 \n<code>HeroDetailComponent</code> 添加到 DOM。 当表达式为假值时，\n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 会从 DOM 中删除 \n<code>HeroDetailComponent</code>， 销毁该组件及其所有子组件。</p>\n<h4 id=\"showhide-is-not-the-same-thing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"atf6zxllm3leqrzbt0nptgdpd\"><i class=\"material-icons\">link</i>显示/隐藏与删除不同</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4avrc534t9vrh7bwpxsq6ebjg\">你可以使用 \n<a href=\"guide/template-syntax#class-binding\">类</a> 或 \n<a href=\"guide/template-syntax#style-binding\">样式</a> 绑定来控制元素的可见性：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgIf-3\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- isSpecial is true --&gt;\n&lt;div [class.hidden]=\"!isSpecial\"&gt;Show with class&lt;/div&gt;\n&lt;div [class.hidden]=\"isSpecial\"&gt;Hide with class&lt;/div&gt;\n\n&lt;!-- HeroDetail is in the DOM but hidden --&gt;\n&lt;app-hero-detail [class.hidden]=\"isSpecial\"&gt;&lt;/app-hero-detail&gt;\n\n&lt;div [style.display]=\"isSpecial ? 'block' : 'none'\"&gt;Show with <a href=\"api/animations/style\" class=\"code-anchor\">style</a>&lt;/div&gt;\n&lt;div [style.display]=\"isSpecial ? 'none'  : 'block'\"&gt;Hide with <a href=\"api/animations/style\" class=\"code-anchor\">style</a>&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yp1yui8d5e9bs3baqbjjriaa\">隐藏元素与使用 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 删除元素完全不同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"as9c17ihipzokpvkyvos5ctrv\">当你隐藏元素时，该元素及其所有后代都保留在 DOM 中。 这些元素的所有组件都保留在内存中， Angular 可能会继续检查更改。 你可能会占用大量的计算资源并降低性能， 而用户却看不到这些内容。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"16fqp3sqodhygj26lusikl0z8\">当 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 为 \n<code>false</code> 时，Angular 会从 DOM 中删除该元素及其后代。 它会销毁它们的组件，可能会释放大量资源， 从而带来更具响应性的用户体验。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aa2b8du8hc2k0z4wikfsokg29\">显示/隐藏技术适用于具有少量子元素的少量元素。 在隐藏大型组件树时要谨慎；\n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 可能是更安全的选择。</p>\n<h4 id=\"guard-against-null\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3mt0d8azq48hupwolehba98mv\"><i class=\"material-icons\">link</i>防止出现空值</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44v27ks7vtzpt8uen95j5t7pp\"><code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 指令通常用于防止出现空值。 显示/隐藏作为保护措施毫无用处。 如果嵌套表达式尝试访问 \n<code>null</code> 的属性，Angular 会抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dof5w2mdplygc13u8zi9gq954\">在这里，我们看到 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 保护了两个 \n<code>&lt;div&gt;</code>。 只有在存在 \n<code>currentHero</code> 时才会显示 \n<code>currentHero</code> 名称。 \n<code>nullHero</code> 永远不会显示。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgIf-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"currentHero\"&gt;Hello, {{currentHero.name}}&lt;/div&gt;\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"nullHero\"&gt;Hello, {{nullHero.name}}&lt;/div&gt;\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2gx3iszasiiypiskzpwvhvkvx\">另请参阅下面描述的 \n<a href=\"guide/template-syntax#safe-navigation-operator\" title=\"Safe navigation operator (?.)\"><em>安全导航运算符</em></a>。</p>\n</div>\n<hr>\n<a id=\"ngFor\"></a>\n<h3 id=\"ngforof\">NgForOf</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtgnjf98hpp3vnda1khx3dau4\"><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 是一个\n<em>重复器</em>指令——一种呈现条目列表的方式。 你定义一个 HTML 代码块，用于定义如何显示单个条目。 你告诉 Angular 使用该代码块作为模板来渲染列表中的每个条目。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2d2z7lrezspva5rwhjiu9dxw3\">以下是一个将 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 应用于简单 \n<code>&lt;div&gt;</code> 的示例：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"er2kokhehwd16cvebn1d2386f\">你也可以将 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 应用于组件元素，如本示例所示：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;app-hero-detail *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" [hero]=\"hero\"&gt;&lt;/app-hero-detail&gt;\n\n</code-example>\n<div class=\"alert is-critical\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fnxhp1oj1zgq6r9mvsjpo6rl\">不要忘记 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 前面的星号 (\n<code>*</code>)。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax53oatsgqwlh4x3bwwdrl7r8\">分配给 \n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 的文本是指导重复器过程的指令。</p>\n<a id=\"microsyntax\"></a>\n<h4 id=\"ngfor-microsyntax\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ckcitqze6xqmzxgl7unn4aep\"><i class=\"material-icons\">link</i>*ngFor 微语法</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e8qkdkvl5xsgoeg1w3opo7kwy\">分配给 \n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 的字符串不是 \n<a href=\"guide/template-syntax#template-expressions\">模板表达式</a>。 它是一种\n<em>微语法</em>——Angular 解释的专用小语言。 字符串 \n<code>\"let hero of heroes\"</code> 的含义是：</p>\n<blockquote>\n<p><em data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1t711e9tpolsqdszcmsfwunxn\">获取 \n<code>heroes</code> 数组中的每个英雄，将其存储在局部 \n<code>hero</code> 循环变量中，并将其提供给每次迭代的模板化 HTML。</em></p>\n</blockquote>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcgkkpinj8v9wn9jlubgpuatt\">Angular 将此指令转换为宿主元素周围的 \n<code>&lt;ng-template&gt;</code>， 然后重复使用此模板为列表中的每个 \n<code>hero</code> 创建一组新的元素和绑定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6tszibd2d1j6lnjbsnjdxswlh\">在 \n<a href=\"guide/structural-directives#microsyntax\"><em>结构型指令</em></a> 指南中了解有关\n<em>微语法</em>的更多信息。</p>\n<a id=\"template-input-variable\"></a>\n<a id=\"template-input-variables\"></a>\n<h3 id=\"template-input-variables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9q05nzw9wg2ra9aubnr05myte\"><i class=\"material-icons\">link</i>模板输入变量</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"py0wk7pjsxjsuw2jzdme3eet\"><code>hero</code> 之前的 \n<code>let</code> 关键字创建了一个名为 \n<code>hero</code> 的\n<em>模板输入变量</em>。 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 指令遍历父组件 \n<code>heroes</code> 属性返回的 \n<code>heroes</code> 数组， 并在每次迭代期间将 \n<code>hero</code> 设置为数组中的当前条目。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70aza8l03th8diejw7snshy9l\">你可以在 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 宿主元素（及其后代）中引用 \n<code>hero</code> 输入变量，以访问英雄的属性。 这里首先在插值中引用它，然后在绑定中将其传递给 \n<code>&lt;hero-detail&gt;</code> 组件的 \n<code>hero</code> 属性。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-1-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;\n&lt;app-hero-detail *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" [hero]=\"hero\"&gt;&lt;/app-hero-detail&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4i2j6ykxmhcudbou2z3pv3vuj\">在 \n<a href=\"guide/structural-directives#template-input-variable\"><em>结构型指令</em></a> 指南中了解有关\n<em>模板输入变量</em>的更多信息。</p>\n<h4 id=\"ngfor-with-index\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dgj3vgulncwugp4pkxvvid7wf\"><i class=\"material-icons\">link</i>*ngFor 带有\n<em>索引</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"elgbvye4ceihh27ix0lrrzzjo\"><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 指令上下文的 \n<code>index</code> 属性返回每次迭代中条目的零基索引。 你可以在模板输入变量中捕获 \n<code>index</code>，并在模板中使用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"daanho71q089pgd25eqybjg3t\">下一个示例在名为 \n<code>i</code> 的变量中捕获 \n<code>index</code>，并将其与英雄姓名一起显示，如下所示。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgFor-3\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; let i=index\"&gt;{{i + 1}} - {{hero.name}}&lt;/div&gt;\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvyifxd5vn8p2cfp8tpgv5weq\"><code>NgFor</code> 由 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 指令实现。在 \n<a href=\"api/common/NgForOf\">NgForOf API 参考</a> 中阅读有关其他 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 上下文值（如 \n<code>last</code>、\n<code>even</code> 和 \n<code>odd</code>）的更多信息。</p>\n</div>\n<a id=\"trackBy\"></a>\n<h4 id=\"ngfor-with-trackby\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4opszdt2z0peo5bmt056swq8z\"><i class=\"material-icons\">link</i>*ngFor 带有\n<em>trackBy</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a7cjqsfs6kb5361dwgd98lyoa\"><code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> 指令的性能可能很差，尤其是在大型列表中。 对一个条目的微小更改、删除一个条目或添加一个条目都可能触发一系列 DOM 操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2db1njuat69dq7895cfzhcrrg\">例如，重新查询服务器可能会使用所有新的英雄对象重置列表。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"53tengsh4hpwqmpir0p2dpg4d\">大多数（如果不是全部）都是以前显示的英雄。 \n<em>你</em>知道这一点，因为每个英雄的 \n<code>id</code> 都没有改变。 但 Angular 只看到一个新的对象引用列表。 它别无选择，只能拆除旧的 DOM 元素并插入所有新的 DOM 元素。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"649g9e1mxq6x22dvqfxjha6g2\">Angular 可以使用 \n<code>trackBy</code> 避免这种混乱。 向组件添加一个方法，该方法返回 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">NgForOf</a></code> \n<em>应该</em>跟踪的值。 在本例中，该值为英雄的 \n<code>id</code>。</p>\n<code-example path=\"template-syntax/src/app/app.component.ts\" region=\"trackByHeroes\" title=\"src/app/app.component.ts\" linenums=\"false\">\ntrackByHeroes(index: number, hero: Hero): number { return hero.id; }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b5nrqr3mivi9kwsupiihrp1gv\">在微语法表达式中，将 \n<code>trackBy</code> 设置为此方法。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"trackBy\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes; trackBy: trackByHeroes\"&gt;\n  ({{hero.id}}) {{hero.name}}\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ei0g7cr9vogvlld7zc2nsc2fh\">以下是对\n<em>trackBy</em> 效果的说明。 “重置英雄”会创建具有相同 \n<code>hero.id</code> 的新英雄。 “更改 id”会创建具有新 \n<code>hero.id</code> 的新英雄。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"950whuq4v2w1b9927j1p2ivsn\">如果没有 <code>trackBy</code>，这些按钮都会触发完全的 DOM 元素替换。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2le3ooll2wr7ch81v2i8mtc5t\">有了 <code>trackBy</code>，则只有修改了 <code>id</code> 的按钮才会触发元素替换。</li>\n</ul>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/ng-for-track-by-anim.gif\" alt=\"trackBy\" width=\"626\" height=\"578\">\n</figure>\n<hr>\n<a id=\"ngSwitch\"></a>\n<h3 id=\"the-ngswitch-directives\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ak3uwg5nd6k9ls9czcu3kb3n\"><i class=\"material-icons\">link</i><em>NgSwitch</em> 指令</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eidsxzj37kf9whf0jqp9qido8\"><em>NgSwitch</em> 类似于 JavaScript \n<code>switch</code> 语句。 它可以根据\n<em>开关条件</em>从多个可能的元素中显示\n<em>一个</em>元素。 Angular 只将\n<em>选定</em>的元素放入 DOM 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3v8ixigdi0l2zf0q3ver9cnwf\"><em>NgSwitch</em> 实际上是一组三个协作指令： \n<code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code>、\n<code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code> 和 \n<code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code>，如本示例所示。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgSwitch\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div [<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]=\"currentHero.emotion\"&gt;\n  &lt;app-happy-hero    *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'happy'\"    [hero]=\"currentHero\"&gt;&lt;/app-happy-hero&gt;\n  &lt;app-sad-hero      *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'sad'\"      [hero]=\"currentHero\"&gt;&lt;/app-sad-hero&gt;\n  &lt;app-confused-hero *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\" [hero]=\"currentHero\"&gt;&lt;/app-confused-hero&gt;\n  &lt;app-unknown-hero  *<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a>           [hero]=\"currentHero\"&gt;&lt;/app-unknown-hero&gt;\n&lt;/div&gt;\n\n</code-example>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/switch-anim.gif\" alt=\"trackBy\" width=\"444\" height=\"100\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ijhz4k8ej75rw0ntwvql3yfx\"><code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 是控制器指令。将其绑定到返回\n<em>开关值</em>的表达式。 本示例中的 \n<code>emotion</code> 值是一个字符串，但开关值可以是任何类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ew1ncq6qg3y7jgx031s0dwnv\"><strong>绑定到 <code>[<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a>]</code></strong>。如果你尝试设置 \n<code>*<a href=\"api/common/NgSwitch\" class=\"code-anchor\">ngSwitch</a></code>，你会收到错误，因为 \n<code><a href=\"api/common/NgSwitch\" class=\"code-anchor\">NgSwitch</a></code> 是一个\n<em>属性</em>指令，而不是一个\n<em>结构型</em>指令。 它会改变其配套指令的行为。 它不会直接触碰 DOM。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"czzoomqqty3kulgojy9xzb1sb\"><strong>绑定到 <code>*<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a></code> 和 <code>*<a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">ngSwitchDefault</a></code></strong>。 \n<code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code> 和 \n<code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> 指令是\n<em>结构型</em>指令， 因为它们会向 DOM 中添加或删除元素。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejr529amdl3dmhdxghn5d6fnp\">当其绑定值等于开关值时，\n<code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code> 会将其元素添加到 DOM 中。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b33oajx7t69lha2or2so27dip\">当没有选定的 \n<code><a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">NgSwitchCase</a></code> 时，\n<code><a href=\"api/common/NgSwitchDefault\" class=\"code-anchor\">NgSwitchDefault</a></code> 会将其元素添加到 DOM 中。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aufph1i4rpo76bxh2thgb9a47\">开关指令对于添加和删除\n<em>组件元素</em>特别有用。 此示例在 \n<code>hero-switch.components.ts</code> 文件中定义的四个“情绪英雄”组件之间切换。 每个组件都有一个 \n<code>hero</code> \n<a href=\"guide/template-syntax#inputs-outputs\" title=\"Input property\">输入属性</a>， 该属性绑定到父组件的 \n<code>currentHero</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"451yfvxurn97mn9bx07ggp9u1\">开关指令也适用于原生元素和 Web 组件。 例如，你可以用以下内容替换 \n<code>&lt;confused-hero&gt;</code> 开关情况。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"NgSwitch-div\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div *<a href=\"api/common/NgSwitchCase\" class=\"code-anchor\">ngSwitchCase</a>=\"'confused'\"&gt;Are you as confused as {{currentHero.name}}?&lt;/div&gt;\n\n</code-example>\n<hr>\n<a id=\"template-reference-variable\"></a>\n<a id=\"ref-vars\"></a>\n<a id=\"ref-var\"></a>\n<h2 id=\"template-reference-variables--var-\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38krv4sy5xnv4uncyujo9g7xf\"><i class=\"material-icons\">link</i>模板引用变量（\n<span class=\"syntax\">#var</span>）</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"esuhjaj9hmsihfz7qn1ysfm8q\"><strong>模板引用变量</strong>通常是对模板中 DOM 元素的引用。 它也可以是对 Angular 组件或指令或 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Web_Components\" title=\"MDN: Web Components\">Web 组件</a> 的引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4k688ie9yi1jw1exv9hdyvh59\">使用井号 (#) 声明引用变量。 \n<code>#phone</code> 在 \n<code>&lt;input&gt;</code> 元素上声明了一个 \n<code>phone</code> 变量。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"ref-var\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;input #phone placeholder=\"phone number\"&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8f0yracboyc1vyc50q9w9j2t1\">你可以在模板的\n<em>任何地方</em>引用模板引用变量。 在该 \n<code>&lt;input&gt;</code> 上声明的 \n<code>phone</code> 变量在模板另一侧的 \n<code>&lt;button&gt;</code> 中被使用</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"ref-phone\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;input #phone placeholder=\"phone number\"&gt;\n\n&lt;!-- lots of other elements --&gt;\n\n&lt;!-- phone refers to the input element; pass its `value` to an event handler --&gt;\n&lt;button (click)=\"callPhone(phone.value)\"&gt;Call&lt;/button&gt;\n\n</code-example>\n<h3 class=\"no-toc\" id=\"how-a-reference-variable-gets-its-value\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bqded88y5fa5deop29qrhtcfr\"><i class=\"material-icons\">link</i>引用变量如何获取其值</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5mndtsuvo29t8s7yz8oe1ud3j\">在大多数情况下，Angular 将引用变量的值设置为其声明所在的元素。 在前面的示例中，\n<code>phone</code> 指的是\n<em>电话号码</em> \n<code>&lt;input&gt;</code> 框。 电话按钮的点击处理程序将\n<em>输入</em>值传递给组件的 \n<code>callPhone</code> 方法。 但指令可以更改此行为，并将值设置为其他内容，例如自身。 \n<code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> 指令就是这样做的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"189hg73sxz460ene3n1vo9eo9\">以下是 \n<a href=\"guide/forms\">表单</a> 指南中表单示例的\n<em>简化</em>版本。</p>\n<code-example path=\"template-syntax/src/app/hero-form.component.html\" title=\"src/app/hero-form.component.html\" linenums=\"false\">\n&lt;form (ngSubmit)=\"onSubmit(heroForm)\" #heroForm=\"<a href=\"api/forms/NgForm\" class=\"code-anchor\">ngForm</a>\"&gt;\n  &lt;div class=\"form-group\"&gt;\n    &lt;label for=\"name\"&gt;Name\n      &lt;input class=\"form-control\" name=\"name\" required [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\"&gt;\n    &lt;/label&gt;\n  &lt;/div&gt;\n  &lt;button type=\"submit\" [disabled]=\"!heroForm.form.valid\"&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n&lt;div [hidden]=\"!heroForm.form.valid\"&gt;\n  {{submitMessage}}\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9c8ldyin839x0kabuomv5vp4u\">模板引用变量 \n<code>heroForm</code> 在此示例中出现了三次，被大量 HTML 代码隔开。 \n<code>heroForm</code> 的值是什么？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"auh00b7j2bjm1vz6k40epsf5l\">如果 Angular 在你导入 \n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 时没有接管它， 它将是 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement\">HTMLFormElement</a>。 \n<code>heroForm</code> 实际上是对 Angular \n<a href=\"api/forms/NgForm\" title=\"API: NgForm\">NgForm</a> 指令的引用，它能够跟踪表单中每个控件的值和有效性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31n927up4bdcneoum223iq6zf\">原生 \n<code>&lt;form&gt;</code> 元素没有 \n<code>form</code> 属性。 但 \n<code><a href=\"api/forms/NgForm\" class=\"code-anchor\">NgForm</a></code> 指令有，这解释了为什么你可以禁用提交按钮， 如果 \n<code>heroForm.form.valid</code> 无效，并将整个表单控件树传递给父组件的 \n<code>onSubmit</code> 方法。</p>\n<h3 class=\"no-toc\" id=\"template-reference-variable-warning-notes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55dpq9mpvm9zln0vswkld4wr1\"><i class=\"material-icons\">link</i>模板引用变量警告说明</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bn3z4isv8umb42mns47m31wi0\">模板\n<em>引用</em>变量 (\n<code>#phone</code>) 与模板\n<em>输入</em>变量 (\n<code>let phone</code>) 不同， 例如你可能在 \n<a href=\"guide/template-syntax#template-input-variable\"><code>*ngFor</code></a> 中看到的那样。 在 \n<a href=\"guide/structural-directives#template-input-variable\"><em>结构型指令</em></a> 指南中了解它们之间的区别。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kc5oz6a2yp1f7cwb652yvuqv\">引用变量的作用域是\n<em>整个模板</em>。 不要在同一个模板中多次定义相同的变量名。 运行时值将不可预测。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tib7uj2buxgwmat8abra5ibe\">你可以使用 \n<code>ref-</code> 前缀作为 \n<code>#</code> 的替代品。 此示例将 \n<code>fax</code> 变量声明为 \n<code>ref-fax</code> 而不是 \n<code>#fax</code>。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"ref-fax\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;input ref-fax placeholder=\"fax number\"&gt;\n&lt;button (click)=\"callFax(fax.value)\"&gt;Fax&lt;/button&gt;\n\n</code-example>\n<hr>\n<a id=\"inputs-outputs\"></a>\n<h2 id=\"input-and-output-properties\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1l6teks35dsyfyxmrnyz7od3t\"><i class=\"material-icons\">link</i>输入和输出属性</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cazfhco8p5qlfev3o5s8leg66\"><em>输入</em>属性是一个\n<em>可设置</em>的属性，用 \n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code> 装饰器进行注解。 当它与 \n<a href=\"guide/template-syntax#property-binding\">属性绑定</a> 进行数据绑定时，值会\n<em>流入</em>该属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aa01ougd6o0jtpqima6czx80z\"><em>输出</em>属性是一个\n<em>可观察</em>的属性，用 \n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code> 装饰器进行注解。 该属性几乎总是返回一个 Angular \n<a href=\"api/core/EventEmitter\"><code>EventEmitter</code></a>。 值会通过 \n<a href=\"guide/template-syntax#event-binding\">事件绑定</a> 绑定，以事件的形式\n<em>流出</em>组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1roczg0zc12x7auvzxa1pyf5y\">你只能通过另一个组件或指令的\n<em>输入</em>和\n<em>输出</em>属性与其进行绑定。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5x6bfxg90yd2je1m6t8ef64az\">记住，所有\n<strong>组件</strong>都是\n<strong>指令</strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtk39tj6upl4xddsguaks8wcv\">为了简洁起见，以下讨论将引用\n<em>组件</em>， 因为此主题主要与组件作者相关。</p>\n</div>\n<h3 class=\"no-toc\" id=\"discussion\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"e51zlya75cbuqy3o40kio43hf\"><i class=\"material-icons\">link</i>讨论</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7mz0810eyaa37e1t2pof9usqf\">你通常将模板绑定到其\n<em>自身组件类</em>。 在这样的绑定表达式中，组件的属性或方法位于（\n<code>=</code>）的\n<em>右侧</em>。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"io-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;img [src]=\"iconUrl\"/&gt;\n&lt;button (click)=\"onSave()\"&gt;Save&lt;/button&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"346w4xq394o89te8js0018lf2\"><code>iconUrl</code> 和 \n<code>onSave</code> 是 \n<code>AppComponent</code> 类的成员。 它们\n<em>没有</em>用 \n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 或 \n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 进行装饰。 Angular 不会报错。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1zggicwrwk9goc5ai9fds64xx\"><strong>你始终可以将模板绑定到组件自身模板中的公共属性。</strong> 它不必是\n<em>输入</em>或\n<em>输出</em>属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37nnisieuiaw1f435ofta9nqg\">组件的类和模板紧密耦合。 它们都是同一个事物的组成部分。 它们共同\n<em>构成了</em>组件。 组件类与其模板之间的交换是内部实现细节。</p>\n<h3 id=\"binding-to-a-different-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"751096ux6h07sj2wsq6onwnv3\"><i class=\"material-icons\">link</i>绑定到不同的组件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5jx8ujr6nbh1qy2qvrmhnekqi\">你也可以绑定到\n<em>不同</em>组件的属性。 在这样的绑定中，\n<em>另一个</em>组件的属性位于（\n<code>=</code>）的\n<em>左侧</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tcedy98rozpvvzrvbj6irwxb\">在以下示例中，\n<code>AppComponent</code> 模板将 \n<code>AppComponent</code> 类成员绑定到 \n<code>HeroDetailComponent</code> 的属性，其选择器为 \n<code>'app-hero-detail'</code>。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"io-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;app-hero-detail [hero]=\"currentHero\" (deleteRequest)=\"deleteHero($event)\"&gt;\n&lt;/app-hero-detail&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7vkadtyhliof91itrvu09whdp\">Angular 编译器\n<em>可能会</em>拒绝这些绑定，并出现类似以下的错误：</p>\n<code-example language=\"sh\" class=\"code-shell\">\nUncaught Error: Template parse errors:\nCan't bind to 'hero' since it isn't <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> known property of 'app-hero-detail'\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"clbl9ym97e192oue3pfj91w45\">你知道 \n<code>HeroDetailComponent</code> 具有 \n<code>hero</code> 和 \n<code>deleteRequest</code> 属性。 但 Angular 编译器拒绝识别它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"z4nmxvv0gn3fos7yd4sz9umo\"><strong>Angular 编译器不会绑定到不同组件的属性， 除非它们是输入或输出属性。</strong></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7lv4yjna3xzfbyrqozrh0hxlh\">这条规则有充分的理由。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"af02kx2f8cskxcguro84dwe17\">组件绑定到其\n<em>自身</em>属性是可以的。 组件作者完全控制这些绑定。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62s2khy9qh7kayv4e7zjssg0h\">但其他组件不应该拥有这种不受限制的访问权限。 如果你允许任何组件绑定到任何属性，那么你将很难维护你的组件。 外部组件应该只能绑定到组件的公共绑定 API。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1n9bszinkxydu0h1xlxgcokt4\">Angular 要求你明确地定义该 API。 由\n<em>你</em>决定哪些属性可供外部组件进行绑定。</p>\n<h4 id=\"typescript-public-doesnt-matter\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5qo4lexkpics31qol0pgjk8fu\"><i class=\"material-icons\">link</i>TypeScript \n<em>public</em> 无关紧要</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aurx6ptn72t4b838td1x13hsq\">你不能使用 TypeScript \n<em>public</em> 和 \n<em>private</em> 访问修饰符来 塑造组件的公共绑定 API。</p>\n<div class=\"alert is-important\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drvd4e7tp1z7yxye9tki60gqf\">所有数据绑定属性必须是 TypeScript \n<em>public</em> 属性。 Angular 永远不会绑定到 TypeScript \n<em>private</em> 属性。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76r8locis04kjfhtpy6x5kuov\">Angular 需要其他方法来识别\n<em>外部</em>组件允许绑定的属性。 这种\n<em>其他方法</em>是 \n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 和 \n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 装饰器。</p>\n<h3 id=\"declaring-input-and-output-properties\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32ymf6vcocavosm8e4f69w4md\"><i class=\"material-icons\">link</i>声明输入和输出属性</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ah6san0o9l2dgwnelueuuylb\">在本指南的示例中，绑定到 \n<code>HeroDetailComponent</code> 不会失败， 因为数据绑定属性用 \n<code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> 和 \n<code>@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>()</code> 装饰器进行注解。</p>\n<code-example path=\"template-syntax/src/app/hero-detail.component.ts\" region=\"input-output-1\" title=\"src/app/hero-detail.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()  hero: Hero;\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleteRequest = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;Hero&gt;();\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjgaqr702hn1svp6y1soe52gh\">或者，你可以在指令元数据的 \n<code>inputs</code> 和 \n<code>outputs</code> 数组中识别成员，如以下示例所示：</p>\n<code-example path=\"template-syntax/src/app/hero-detail.component.ts\" region=\"input-output-2\" title=\"src/app/hero-detail.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  inputs: ['hero'],\n  outputs: ['deleteRequest'],\n})\n\n</code-example>\n</div>\n<h3 id=\"input-or-output\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"36jp32n1szz3abmau5y8fh19c\"><i class=\"material-icons\">link</i>输入还是输出？</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2ubn3twsx8bt1ud8fhy2cfky7\"><em>输入</em>属性通常接收数据值。 \n<em>输出</em>属性公开事件生成器，例如 \n<code><a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a></code> 对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bdwtdemmitlq1rjehbyope4ed\"><em>输入</em>和\n<em>输出</em>这两个术语反映了目标指令的视角。</p>\n<figure>\n  <img src=\"generated/images/guide/template-syntax/input-output.png\" alt=\"Inputs and outputs\" width=\"546\" height=\"50\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hpuspu3kd0yrlbdqc5v2jgq6\">从 \n<code>HeroDetailComponent</code> 的角度来看，\n<code>HeroDetailComponent.hero</code> 是一个\n<strong>输入</strong>属性， 因为数据从模板绑定表达式\n<em>流入</em>该属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4gi192o826xg3vtzsmrkzh4wb\">从 \n<code>HeroDetailComponent</code> 的角度来看，\n<code>HeroDetailComponent.deleteRequest</code> 是一个\n<strong>输出</strong>属性， 因为事件从该属性\n<em>流出</em>，并指向模板绑定语句中的处理程序。</p>\n<h3 id=\"aliasing-io\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43fftvxl2uhed68f14udhnhio\"><i class=\"material-icons\">link</i>为输入/输出属性设置别名</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ljdht70mhlx311mbycvnjlnt\">有时，输入/输出属性的公共名称应该与内部名称不同。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6g0j7zm6yg0noibbmvevmo0gc\">这在 \n<a href=\"guide/attribute-directives\">属性指令</a> 中很常见。 指令使用者希望绑定到指令的名称。 例如，当你将带有 \n<code>myClick</code> 选择器的指令应用于 \n<code>&lt;div&gt;</code> 标签时， 你希望绑定到一个也称为 \n<code>myClick</code> 的事件属性。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"myClick\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div (myClick)=\"clickMessage=$event\" clickable&gt;click with myClick&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"73a180tupi2so1144nh9hor57\">但是，指令名称通常不是指令类中属性名称的最佳选择。 指令名称很少描述属性的功能。 \n<code>myClick</code> 指令名称不是用于发出点击消息的属性的理想名称。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7db4fhf6tsxgqxsjt5y5jj77b\">幸运的是，你可以为属性设置一个符合传统期望的公共名称， 同时在内部使用不同的名称。 在上面的示例中，你实际上是\n<em>通过</em> \n<code>myClick</code> \n<em>别名</em>绑定到 指令自身的 \n<code>clicks</code> 属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"91ibm4lidzgxfuanio1x8h0da\">你可以通过将别名传递给输入/输出装饰器来指定属性名称的别名，如下所示：</p>\n<code-example path=\"template-syntax/src/app/click.directive.ts\" region=\"output-myClick\" title=\"src/app/click.directive.ts\" linenums=\"false\">\n@<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>('myClick') clicks = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;string&gt;(); //  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>(alias) propertyName = ...\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"oqhvpf2efqf2aj29m560m0dp\">你也可以在 \n<code>inputs</code> 和 \n<code>outputs</code> 数组中设置属性名称的别名。 你可以编写一个冒号分隔的（\n<code>:</code>）字符串， 其中指令属性名称位于\n<em>左侧</em>，公共别名位于\n<em>右侧</em>：</p>\n<code-example path=\"template-syntax/src/app/click.directive.ts\" region=\"output-myClick2\" title=\"src/app/click.directive.ts\" linenums=\"false\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  outputs: ['clicks:myClick']  // propertyName:alias\n})\n\n</code-example>\n</div>\n<hr>\n<a id=\"expression-operators\"></a>\n<h2 id=\"template-expression-operators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bbi882vckerp151ik158mk9k4\"><i class=\"material-icons\">link</i>模板表达式运算符</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bruyuuywwsrr5ezu9yu9nrlp9\">模板表达式语言使用 JavaScript 语法的子集，并补充了一些针对特定场景的特殊运算符。 接下来的部分将介绍其中两个运算符：\n<em>管道</em>和\n<em>安全导航运算符</em>。</p>\n<a id=\"pipe\"></a>\n<h3 id=\"the-pipe-operator---\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fa2iivp1qxsbhvk4k9nl30vu\"><i class=\"material-icons\">link</i>管道运算符（\n<span class=\"syntax\">|</span>）</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5od6bkld8b81trfi9h9l0tptl\">表达式的结果可能需要进行一些转换，才能在绑定中使用。 例如，你可能需要将数字显示为货币，将文本强制转换为大写，或者过滤和排序列表。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2frui3saofabpunyssnl4ayjn\">Angular \n<a href=\"guide/pipes\">管道</a> 是执行此类小型转换的理想选择。 管道是简单的函数，它们接受一个输入值并返回一个转换后的值。 它们易于在模板表达式中使用，使用\n<strong>管道运算符（<code>|</code>）</strong>：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"pipes-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;div&gt;<a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> through uppercase pipe: {{title | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}}&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"btlmmf304oq46nqyhkrluop6u\">管道运算符将左侧表达式的结果传递给右侧的管道函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dv3yelmblbrfum88pnksm37nc\">你可以通过多个管道将表达式链接起来：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"pipes-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a> chaining: convert title to uppercase, then to lowercase --&gt;\n&lt;div&gt;\n  <a href=\"api/platform-browser/Title\" class=\"code-anchor\">Title</a> through <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> pipe chain:\n  {{title | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a> | <a href=\"api/common/LowerCasePipe\" class=\"code-anchor\">lowercase</a>}}\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxdul5edblve1xis3lukhuhgm\">你也可以\n<a href=\"guide/pipes#parameterizing-a-pipe\">向管道应用参数</a>：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"pipes-3\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- pipe with configuration argument =&gt; \"February 25, 1970\" --&gt;\n&lt;div&gt;Birthdate: {{currentHero?.birthdate | date:'longDate'}}&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do5zw08m4hdf7bbq35fbjpzio\"><code><a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> 管道对于调试绑定特别有用：</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" linenums=\"false\" title=\"src/app/app.component.html (pipes-json)\" region=\"pipes-json\">\n&lt;div&gt;{{currentHero | <a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>}}&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arwoawneud8fxdi8ibc86v4ms\">生成的输出看起来像这样</p>\n<code-example language=\"json\">\n  { \"id\": 0, \"name\": \"Hercules\", \"emotion\": \"happy\",\n    \"birthdate\": \"1970-02-25T08:00:00.000Z\",\n    \"url\": \"http://www.imdb.com/title/tt0065832/\",\n    \"rate\": 325 }\n</code-example>\n<hr>\n<a id=\"safe-navigation-operator\"></a>\n<h3 id=\"the-safe-navigation-operator----and-null-property-paths\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1otrev56fj238yg4w0cfmzi7m\"><i class=\"material-icons\">link</i>安全导航运算符（\n<span class=\"syntax\">?.</span>）和空属性路径</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f3ihv2xmedxr79i442nwz31yn\">Angular 的\n<strong>安全导航运算符（<code>?.</code>）</strong>是一种流畅且便捷的方式，用于在属性路径中防止出现 null 和 undefined 值。 这里它可以防止在 \n<code>currentHero</code> 为 null 时视图渲染失败。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-2\" title=\"src/app/app.component.html\" linenums=\"false\">\nThe current hero's name is {{currentHero?.name}}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dhv3ztzeu73708blnctwlim0y\">当以下数据绑定的 \n<code>title</code> 属性为 null 时会发生什么？</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-1\" title=\"src/app/app.component.html\" linenums=\"false\">\nThe title is {{title}}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ws7de8nukvgoj8r5qib7d75v\">视图仍然会渲染，但显示的值为空；你只会看到 \"The title is\"，后面什么都没有。 这是合理的做法。至少应用不会崩溃。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2duh891cp0jdsbh8cx0hymh4u\">假设模板表达式包含属性路径，就像下面这个例子，它显示了 null 英雄的 \n<code>name</code>。</p>\n<code-example language=\"html\">\n  The null hero's name is {{nullHero.name}}\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"oo68r0qh8tkzckd4cobs2chq\">JavaScript 会抛出 null 引用错误，Angular 也会：</p>\n<code-example format=\"nocode\">\n  TypeError: Cannot read property 'name' of null in [null].\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1uk3vu9x4dsn4um5ufd6pbck8\">更糟糕的是，\n<em>整个视图都会消失</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ne77avhspxzqzgvttsk8qj8u\">如果 \n<code>hero</code> 属性永远不会为 null，那么这将是合理的做法。 如果它永远不能为 null，但它却为 null， 那么这是一个应该被捕获并修复的编程错误。 抛出异常是正确的做法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2gizgza9d2ncoozmthd78ika5\">另一方面，属性路径中的 null 值有时可能是可以接受的， 尤其是在数据现在为 null，但最终会到达的时候。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ch58gni4cb293dgb4mmawvafe\">在等待数据时，视图应该在没有报错的情况下渲染， 并且 null 属性路径应该像 \n<code>title</code> 属性一样显示为空。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71cnipkzsdazlr7bufn4lrl9p\">不幸的是，当 \n<code>currentHero</code> 为 null 时，应用会崩溃。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2nk4tsyzcngzy9h1q45pxxj7z\">你可以使用 \n<a href=\"guide/template-syntax#ngIf\">*ngIf</a> 来解决这个问题。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-4\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!--No hero, div not displayed, no error --&gt;\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"nullHero\"&gt;The null hero's name is {{nullHero.name}}&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13jkv5b7wgj14pu5785oe7po4\">你可以尝试使用 \n<code>&amp;&amp;</code> 来连接属性路径的各个部分，因为你知道当遇到第一个 null 时表达式就会退出。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-5\" title=\"src/app/app.component.html\" linenums=\"false\">\nThe null hero's name is {{nullHero &amp;&amp; nullHero.name}}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jq49ql7gmwlvowtgbejo2xwa\">这些方法都有优点，但可能很麻烦，尤其是当属性路径很长时。 想象一下，在一个很长的属性路径（例如 \n<code>a.b.c.d</code>）中，某个地方要防止出现 null。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6kvjr9mp25txggrzk0otptpzw\">Angular 安全导航运算符（\n<code>?.</code>）是一种更流畅、更便捷的方式，用于在属性路径中防止出现 null。 当表达式遇到第一个 null 值时，它就会退出。 显示为空，但应用会继续运行，不会出现错误。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"safe-6\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- No hero, no problem! --&gt;\nThe null hero's name is {{nullHero?.name}}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9ogeo2yoi9mk4fnnupqn6e0zn\">它与长属性路径（例如 \n<code><a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>?.b?.c?.d</code>）完美配合。</p>\n<hr>\n<a id=\"non-null-assertion-operator\"></a>\n<h3 id=\"the-non-null-assertion-operator---\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66t9u56r5x3t9ywjs1iq0c76o\"><i class=\"material-icons\">link</i>非空断言运算符（\n<span class=\"syntax\">!</span>）</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"51l5pxera4pgxmushvdt2s0jv\">从 Typescript 2.0 开始，你可以使用 \n<code>--strictNullChecks</code> 标志来强制执行 \n<a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\" title=\"Strict null checking in TypeScript\">严格的 null 检查</a>。然后，TypeScript 会确保没有变量是\n<em>无意</em>为 null 或 undefined 的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"s8gk9m76bxbdwavi2uhdj0ge\">在这种模式下，类型化的变量默认情况下不允许 null 和 undefined。如果你将一个变量未赋值，或者尝试将 null 或 undefined 赋值给一个类型不允许 null 和 undefined 的变量，类型检查器就会抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8qcz8q7sphfc9ttxz6yk0fw06\">如果类型检查器无法确定变量在运行时是否为 null 或 undefined，它也会抛出错误。 你可能知道这种情况不会发生，但类型检查器不知道。 你可以通过应用后缀 \n<a href=\"http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator\" title=\"Non-null assertion operator\"><em>非空断言运算符 (!)</em></a> 来告诉类型检查器这种情况不会发生。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2c5g3cbaxgjpufmtd5u5w014x\"><em>Angular</em> 的\n<strong>非空断言运算符（<code>!</code>）</strong>在 Angular 模板中起着相同的作用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2xvy63bfd9v3tbhbpdtean0w\">例如，在你使用 \n<a href=\"guide/template-syntax#ngIf\">*ngIf</a> 检查 \n<code>hero</code> 是否已定义之后，你可以断言 \n<code>hero</code> 属性也已定义。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"non-null-assertion-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!--No hero, no text --&gt;\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\"&gt;\n  The hero's name is {{hero!.name}}\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"93d8jv6cwa94ghtjdyjabc9nl\">当 Angular 编译器将你的模板转换为 TypeScript 代码时， 它会阻止 TypeScript 报告 \n<code>hero.name</code> 可能为 null 或 undefined。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dd2bfbsx2re7rlzh17wzplkk1\">与 \n<a href=\"guide/template-syntax#safe-navigation-operator\" title=\"Safe navigation operator (?.)\"><em>安全导航运算符</em></a> 不同， \n<strong>非空断言运算符</strong>不会防止出现 null 或 undefined。 相反，它告诉 TypeScript 类型检查器暂停对特定属性表达式的严格 null 检查。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gw67h5t4t3gk3q1bb4v8t19m\">当你开启严格的 null 检查时，你需要使用这个模板运算符。否则它是可选的。</p>\n<p><a href=\"guide/template-syntax#top-of-page\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cro8qucns6eby9gkzti41ytlp\">返回顶部</a></p>\n<hr>\n<a id=\"any-type-cast-function\"></a>\n<h2 id=\"the-any-type-cast-function-any-expression-\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7v39rcz8jigd8aj97gfi410kk\"><i class=\"material-icons\">link</i><code>$any</code> 类型转换函数（\n<code>$any( &lt;expression&gt; )</code>）</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4x3cyihqklo3zdrixpzelsr03\">有时绑定表达式会被报告为类型错误，并且无法或难以 完全指定类型。为了消除错误，你可以使用 \n<code>$any</code> 类型转换函数将 表达式转换为 \n<a href=\"http://www.typescriptlang.org/docs/handbook/basic-types.html#any\"><code>any</code> 类型</a>。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"any-type-cast-function-1\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- Accessing an undeclared member --&gt;\n&lt;div&gt;\n  The hero's marker is {{$any(hero).marker}}\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cik9lebp2vqkrr1qb2d5dfba1\">在这个例子中，当 Angular 编译器将你的模板转换为 TypeScript 代码时， 它会阻止 TypeScript 报告 \n<code>marker</code> 不是 \n<code>Hero</code> 接口的成员。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cw42t1nv68toieqewdxkbm7gr\"><code>$any</code> 类型转换函数可以与 \n<code>this</code> 结合使用，以允许访问组件的未声明成员。</p>\n<code-example path=\"template-syntax/src/app/app.component.html\" region=\"any-type-cast-function-2\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;!-- Accessing an undeclared member --&gt;\n&lt;div&gt;\n  Undeclared members is {{$any(this).member}}\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7rgcnl0bok2f7f3k6ri0cmte\"><code>$any</code> 类型转换函数可以在绑定表达式中任何方法调用有效的地方使用。</p>\n<h2 id=\"summary\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2fflknbbur8ttwdtn3o9w4vat\"><i class=\"material-icons\">link</i>总结</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"l45m1q5mvn6qplb6nwh1vs6s\">你已经完成了对模板语法的调查。 现在是时候将这些知识应用到自己的组件和指令上了。</p>\n\n</div>\n<!-- links to this doc:\n - guide/ajs-quick-reference\n - guide/aot-compiler\n - guide/architecture-components\n - guide/attribute-directives\n - guide/change-log\n - guide/component-interaction\n - guide/displaying-data\n - guide/forms\n - guide/glossary\n - guide/pipes\n - guide/router\n - guide/structural-directives\n - guide/styleguide\n - guide/upgrade\n - guide/user-input\n - tutorial/toh-pt2\n - tutorial/toh-pt3\n - tutorial/toh-pt4\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/animations/state\n - api/animations/style\n - api/common/JsonPipe\n - api/common/LowerCasePipe\n - api/common/NgClass\n - api/common/NgForOf\n - api/common/NgIf\n - api/common/NgStyle\n - api/common/NgSwitch\n - api/common/NgSwitchCase\n - api/common/NgSwitchDefault\n - api/common/UpperCasePipe\n - api/core/Component\n - api/core/ContentChild\n - api/core/Directive\n - api/core/EventEmitter\n - api/core/Input\n - api/core/NgModule\n - api/core/Output\n - api/core/Pipe\n - api/core/ViewChild\n - api/forms/ControlValueAccessor\n - api/forms/FormsModule\n - api/forms/NgForm\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/platform-browser/Title\n - api/router/RouterLinkWithHref\n - guide/attribute-directives\n - guide/forms\n - guide/forms#ngModel\n - guide/glossary#camelcase\n - guide/glossary#dash-case\n - guide/pipes\n - guide/pipes#parameterizing-a-pipe\n - guide/router\n - guide/security\n - guide/security#sanitization-and-security-contexts\n - guide/structural-directives\n - guide/structural-directives#asterisk\n - guide/structural-directives#microsyntax\n - guide/structural-directives#ngcontainer\n - guide/structural-directives#one-per-element\n - guide/structural-directives#template-input-variable\n - guide/template-syntax#a-new-mental-model\n - guide/template-syntax#aliasing-io\n - guide/template-syntax#attribute-binding\n - guide/template-syntax#attribute-class-and-style-bindings\n - guide/template-syntax#attribute-directives\n - guide/template-syntax#avoid-side-effects\n - guide/template-syntax#binding-syntax-an-overview\n - guide/template-syntax#binding-target\n - guide/template-syntax#binding-targets\n - guide/template-syntax#binding-to-a-different-component\n - guide/template-syntax#built-in-attribute-directives\n - guide/template-syntax#built-in-directives\n - guide/template-syntax#built-in-structural-directives\n - guide/template-syntax#class-binding\n - guide/template-syntax#content-security\n - guide/template-syntax#custom-events-with-eventemitter\n - guide/template-syntax#declaring-input-and-output-properties\n - guide/template-syntax#discussion\n - guide/template-syntax#event-and-event-handling-statements\n - guide/template-syntax#event-binding\n - guide/template-syntax#event-binding---event-\n - guide/template-syntax#expression-context\n - guide/template-syntax#expression-guidelines\n - guide/template-syntax#expression-operators\n - guide/template-syntax#formsmodule-is-required-to-use-ngmodel\n - guide/template-syntax#guard-against-null\n - guide/template-syntax#how-a-reference-variable-gets-its-value\n - guide/template-syntax#html-attribute-vs-dom-property\n - guide/template-syntax#html-in-templates\n - guide/template-syntax#idempotence\n - guide/template-syntax#input-and-output-properties\n - guide/template-syntax#input-or-output\n - guide/template-syntax#inputs-outputs\n - guide/template-syntax#inside-ngmodel\n - guide/template-syntax#interpolation----\n - guide/template-syntax#ngClass\n - guide/template-syntax#ngFor\n - guide/template-syntax#ngIf\n - guide/template-syntax#ngModel\n - guide/template-syntax#ngStyle\n - guide/template-syntax#ngSwitch\n - guide/template-syntax#ngclass\n - guide/template-syntax#ngfor-microsyntax\n - guide/template-syntax#ngfor-with-index\n - guide/template-syntax#ngfor-with-trackby\n - guide/template-syntax#ngforof\n - guide/template-syntax#ngif\n - guide/template-syntax#ngmodel---two-way-binding-to-form-elements-with-ngmodel\n - guide/template-syntax#ngstyle\n - guide/template-syntax#no-visible-side-effects\n - guide/template-syntax#one-time-string-initialization\n - guide/template-syntax#one-way-in\n - guide/template-syntax#property-binding\n - guide/template-syntax#property-binding--property-\n - guide/template-syntax#property-binding-or-interpolation\n - guide/template-syntax#quick-execution\n - guide/template-syntax#ref-vars\n - guide/template-syntax#remember-the-brackets\n - guide/template-syntax#return-the-proper-type\n - guide/template-syntax#safe-navigation-operator\n - guide/template-syntax#showhide-is-not-the-same-thing\n - guide/template-syntax#simplicity\n - guide/template-syntax#statement-context\n - guide/template-syntax#statement-guidelines\n - guide/template-syntax#structural-directives\n - guide/template-syntax#style-binding\n - guide/template-syntax#summary\n - guide/template-syntax#target-event\n - guide/template-syntax#template-expression-operators\n - guide/template-syntax#template-expressions\n - guide/template-syntax#template-input-variable\n - guide/template-syntax#template-input-variables\n - guide/template-syntax#template-reference-variable-warning-notes\n - guide/template-syntax#template-reference-variables--var-\n - guide/template-syntax#template-statements\n - guide/template-syntax#template-statements-have-side-effects\n - guide/template-syntax#template-syntax\n - guide/template-syntax#the-any-type-cast-function-any-expression-\n - guide/template-syntax#the-ngswitch-directives\n - guide/template-syntax#the-non-null-assertion-operator---\n - guide/template-syntax#the-pipe-operator---\n - guide/template-syntax#the-safe-navigation-operator----and-null-property-paths\n - guide/template-syntax#top-of-page\n - guide/template-syntax#two-way\n - guide/template-syntax#two-way-binding---\n - guide/template-syntax#typescript-public-doesnt-matter\n - http://www.typescriptlang.org/docs/handbook/basic-types.html#any\n - http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html\n - http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator\n - https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement\n - https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA\n - https://developer.mozilla.org/en-US/docs/Web/Events\n - https://developer.mozilla.org/en-US/docs/Web/SVG\n - https://developer.mozilla.org/en-US/docs/Web/Web_Components\n - https://en.wikipedia.org/wiki/Idempotence\n-->"
}