{
  "id" : "guide/dependency-injection-in-action",
  "title" : "依赖注入",
  "contents" : "<div class=\"content\">\n<h1 id=\"dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"o5rlb7acys3t8dxjenlygz93\"><i class=\"material-icons\">link</i>依赖注入</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"w4eeb3p455qwap0m74aa94m4\">依赖注入是一种用于管理代码依赖关系的强大模式。 本指南探讨了 Angular 中依赖注入 (DI) 的许多特性。 \n<a id=\"toc\"></a></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bgyvifbrsnjplm1gxucfjih9k\">请参阅本指南中代码的 \n<live-example name=\"dependency-injection-in-action\"></live-example> 。</p>\n<a id=\"app-wide-dependencies\"></a>\n<h2 id=\"application-wide-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75w0o581rthcx3w0zaccf6pb\"><i class=\"material-icons\">link</i>应用程序范围的依赖关系</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97sxvltxekttaqqgf5c8kv7bq\">在根应用程序组件 \n<code>AppComponent</code> 中注册用于整个应用程序的依赖关系的提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cn4b3w16vebmeji5lfwr6r741\">以下示例展示了在 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 元数据 \n<code>providers</code> 数组中导入和注册 \n<code>LoggerService</code>、\n<code>UserContext</code> 和 \n<code>UserService</code>。</p>\n<code-example path=\"dependency-injection-in-action/src/app/app.component.ts\" region=\"import-services\" title=\"src/app/app.component.ts (excerpt)\" linenums=\"false\">\nimport { LoggerService }      from './logger.service';\nimport { UserContextService } from './user-context.service';\nimport { UserService }        from './user.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  providers: [ LoggerService, UserContextService, UserService ]\n})\nexport class AppComponent {\n/* . . . */\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89xutd9sth001u2n6tprm795g\">所有这些服务都实现为类。 服务类可以充当它们自己的提供者，这就是为什么将它们列在 \n<code>providers</code> 数组中 就是你需要的全部注册。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cum8dmrx2oxkbq9ulril1mv3p\"><em>提供者</em>是可以创建或提供服务的任何东西。 Angular 通过使用 \n<code>new</code> 从类提供者创建服务实例。 在 \n<a href=\"guide/dependency-injection#register-providers-ngmodule\">依赖注入</a> 指南中阅读有关提供者的更多信息。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"iw6dik3ak37ih3brj7p70kf9\">现在你已经注册了这些服务， Angular 可以将它们注入到应用程序中\n<em>任何</em>组件或服务的构造函数中，\n<em>无论在哪里</em>。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"ctor\" title=\"src/app/hero-bios.component.ts (component constructor injection)\" linenums=\"false\">\nconstructor(logger: LoggerService) {\n  logger.logInfo('Creating HeroBiosComponent');\n}\n\n</code-example>\n<code-example path=\"dependency-injection-in-action/src/app/user-context.service.ts\" region=\"ctor\" title=\"src/app/user-context.service.ts (service constructor injection)\" linenums=\"false\">\nconstructor(private userService: UserService, private loggerService: LoggerService) {\n}\n\n</code-example>\n<a id=\"external-module-configuration\"></a>\n<h2 id=\"external-module-configuration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4nkafi1e0hn8kcyrzcgxdvke3\"><i class=\"material-icons\">link</i>外部模块配置</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4378uxoy5rjjuat9si7jravq6\">通常，在 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 而不是在根应用程序组件中注册提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6x62t72ydh7tyxj5uo3reci7\">当你期望服务在任何地方都可注入时， 或者你正在配置另一个应用程序全局服务\n<em>在应用程序启动之前</em>，请执行此操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xj1j9csquwoxawzq2yn3rqo0\">以下是一个第二种情况的示例，其中组件路由器配置包含一个非默认 \n<a href=\"guide/router#location-strategy\">位置策略</a>，方法是在 \n<code>AppModule</code> 的 \n<code>providers</code> 列表中列出其提供者。</p>\n<code-example path=\"dependency-injection-in-action/src/app/app.module.ts\" region=\"providers\" title=\"src/app/app.module.ts (providers)\" linenums=\"false\">\nproviders: [\n  { provide: <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a>, useClass: <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a> }\n]\n\n</code-example>\n<a id=\"injectable\"></a>\n<a id=\"nested-dependencies\"></a>\n<h2 id=\"injectable-and-nested-service-dependencies\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5dokkpgc2766lvttbzv8osrny\"><i class=\"material-icons\">link</i><em>@Injectable()</em> 和嵌套服务依赖关系</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4zec7p01s26dw6gcidepm7t09\">注入服务的使用者不知道如何创建该服务。 它不应该关心。 这是依赖注入的工作，它负责创建和缓存该服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8s4aglncetyci8y0wjzv0m0mu\">有时，服务依赖于其他服务，而这些服务可能又依赖于其他服务。 以正确的顺序解析这些嵌套依赖关系也是框架的工作。 在每一步中，依赖关系的使用者只需在其 构造函数中声明其需要什么，框架就会接管。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"88w7o8apzrqvrsr2f3m8od1eq\">以下示例展示了在 \n<code>AppComponent</code> 中注入 \n<code>LoggerService</code> 和 \n<code>UserContext</code>。</p>\n<code-example path=\"dependency-injection-in-action/src/app/app.component.ts\" region=\"ctor\" title=\"src/app/app.component.ts\" linenums=\"false\">\nconstructor(logger: LoggerService, public userContext: UserContextService) {\n  userContext.loadUser(this.userId);\n  logger.logInfo('AppComponent initialized');\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e3j4iie1js8rnpbyb47ahmg1b\"><code>UserContext</code> 反过来也依赖于 \n<code>LoggerService</code> 和 一个 \n<code>UserService</code>，它收集有关特定用户的的信息。</p>\n<code-example path=\"dependency-injection-in-action/src/app/user-context.service.ts\" region=\"injectables\" title=\"user-context.service.ts (injection)\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class UserContextService {\n  constructor(private userService: UserService, private loggerService: LoggerService) {\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"s94vc2hat4b8w7pjfxxs7hl1\">当 Angular 创建 \n<code>AppComponent</code> 时，依赖注入框架会创建一个 \n<code>LoggerService</code> 实例，并 开始创建 \n<code>UserContextService</code>。 \n<code>UserContextService</code> 需要 \n<code>LoggerService</code>（框架已经拥有），以及 \n<code>UserService</code>（它还没有创建）。 \n<code>UserService</code> 没有依赖关系，因此依赖注入框架可以只 使用 \n<code>new</code> 来实例化一个。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1s65a9rbs4u5vqu7b3q75l1t0\">依赖注入的妙处在于 \n<code>AppComponent</code> 不关心所有这些。 你只需在构造函数中声明需要什么（\n<code>LoggerService</code> 和 \n<code>UserContextService</code>）， 框架就会完成剩下的工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9kx90r3bmgbo94mbf00t561kp\">一旦所有依赖关系到位，\n<code>AppComponent</code> 就会显示用户信息：</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/logged-in-user.png\" alt=\"Logged In User\" width=\"145\" height=\"99\">\n</figure>\n<a id=\"injectable-1\"></a>\n<h3 id=\"injectable\"><em>@Injectable()</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7d3tphtq1y4ognt1e4bwh7quj\">请注意 \n<code>UserContextService</code> 类上的 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器。</p>\n<code-example path=\"dependency-injection-in-action/src/app/user-context.service.ts\" region=\"injectable\" title=\"user-context.service.ts (@Injectable)\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class UserContextService {\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zkvgkbbmr76bc8nxw06xq4jt\">该装饰器使 Angular 能够识别其两个依赖关系 \n<code>LoggerService</code> 和 \n<code>UserService</code> 的类型。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80lkeqkcorhjsi5hblh4u77ki\">从技术上讲，\n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 装饰器仅适用于具有\n<em>自身依赖关系</em>的服务类。 \n<code>LoggerService</code> 不依赖于任何东西。如果你省略 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>，日志记录器将正常工作，生成的代码也会略小一些。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1q1viexn4mxqu3klat1nuxfp3\">但是，一旦你为它提供了一个依赖关系，该服务就会中断，你必须返回 并添加 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 来修复它。为了保持一致性并避免将来出现问题，请从一开始就添加 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>。</p>\n<div class=\"alert is-helpful\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"18c1hhc8rn4ecjrheojk1brrf\">虽然本网站建议将 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code> 应用于所有服务类，但不要受其约束。 一些开发人员更喜欢只在需要的地方添加它，这也是一种合理的策略。</p>\n</div>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eqx9hd4hybm358ewsizhdxc05\"><code>AppComponent</code> 类也有两个依赖关系，但没有 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>。 它不需要 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()</code>，因为该组件类具有 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 装饰器。 在带有 TypeScript 的 Angular 中，一个\n<em>单个</em>装饰器——\n<em>任何</em>装饰器——足以识别依赖关系类型。</p>\n</div>\n<a id=\"service-scope\"></a>\n<h2 id=\"limit-service-scope-to-a-component-subtree\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dbtxe8nk6zit0p93mnyh772ws\"><i class=\"material-icons\">link</i>将服务范围限制为组件子树</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5s61z94koej2e1nifouyn8nib\">所有注入的服务依赖关系都是单例，这意味着， 对于给定的依赖注入器，服务只有一个实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8xcweu6w5kpq73j3ooj7hx82o\">但是，Angular 应用程序具有多个依赖注入器，它们以树状层次结构排列，与组件树平行。 因此，可以在任何组件级别以及多次提供和创建特定服务，如果在多个组件中提供。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94kp5rhzu5c7hplvxva0q7h8r\">默认情况下，在一个组件中提供的服务依赖关系对所有子组件可见， Angular 将同一个服务实例注入到所有请求该服务的子组件中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"esvew3vgjscpjk1kwuxb6tfg2\">因此，在根 \n<code>AppComponent</code> 中提供的依赖关系可以注入到应用程序中\n<em>任何</em>组件的\n<em>任何地方</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brh3136szc9hcetihjsazyq36\">这并不总是可取的。 有时你希望将服务可用性限制在应用程序的特定区域。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"32cavy4fla0dpb1la8a0vw9h4\">你可以通过在\n<em>该分支的子根组件中</em>提供该服务，将注入服务的范围限制为应用程序层次结构的\n<em>分支</em>。 此示例展示了将服务提供给子根组件与 在根 \n<code>AppComponent</code> 中提供服务有多么相似。语法相同。 这里，\n<code>HeroService</code> 对 \n<code>HeroesBaseComponent</code> 可用，因为它位于 \n<code>providers</code> 数组中：</p>\n<code-example path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"injection\" title=\"src/app/sorted-heroes.component.ts (HeroesBaseComponent excerpt)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-unsorted-heroes',\n  template: `&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;`,\n  providers: [HeroService]\n})\nexport class HeroesBaseComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private heroService: HeroService) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"95qsnrbwo9wlp4iid7x9hi9na\">当 Angular 创建 \n<code>HeroesBaseComponent</code> 时，它还会创建一个新的 \n<code>HeroService</code> 实例， 该实例仅对该组件及其子组件（如果有）可见。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csw2hfath3djd40huctcl0tpn\">你也可以将 \n<code>HeroService</code> 提供给应用程序中其他地方的\n<em>不同</em>组件。 这将导致一个\n<em>不同</em>的服务实例，存在于一个\n<em>不同</em>的注入器中。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7e1u6g2g5txhby85skmzb1jf2\">此类范围内的 \n<code>HeroService</code> 单例的示例出现在随附的示例代码中， 包括 \n<code>HeroBiosComponent</code>、\n<code>HeroOfTheMonthComponent</code> 和 \n<code>HeroesBaseComponent</code>。 这些组件中的每一个都有自己的 \n<code>HeroService</code> 实例，管理着自己独立的英雄集合。</p>\n</div>\n<div class=\"alert is-helpful\">\n<h3 id=\"take-a-break\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5lqlmv2259gr5spr4e8vka6le\"><i class=\"material-icons\">link</i>休息一下！</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"rxjdxwcldtqxcy0qzpisq36x\">这些依赖注入知识可能就是许多 Angular 开发人员构建应用所需的一切。并不总是需要更复杂的东西。</p>\n</div>\n<a id=\"multiple-service-instances\"></a>\n<h2 id=\"multiple-service-instances-sandboxing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5qv1ogkr4lur5dx4q6zaala9b\"><i class=\"material-icons\">link</i>多个服务实例（沙箱）</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"di5x4751bc6cumkijeiexv88m\">有时你希望在\n<em>组件层次结构的同一级别</em>拥有多个服务实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wo3iclaudu53fcsf5grdm8rx\">一个很好的例子是，一个服务为其伴侣组件实例保存状态。 你需要为每个组件提供一个单独的服务实例。 每个服务都有自己的工作状态，与其他组件的服务和状态隔离。 这被称为\n<em>沙箱</em>，因为每个服务和组件实例都有自己的沙箱可以玩。</p>\n<a id=\"hero-bios-component\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rnm2wsu4a0kuvgsokwhpbwx8\">想象一个 \n<code>HeroBiosComponent</code>，它展示了三个 \n<code>HeroBioComponent</code> 实例。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"simple\" title=\"ap/hero-bios.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bios',\n  template: `\n    &lt;app-hero-bio [heroId]=\"1\"&gt;&lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"2\"&gt;&lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"3\"&gt;&lt;/app-hero-bio&gt;`,\n  providers: [HeroService]\n})\nexport class HeroBiosComponent {\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8xoig29fuo46nc5109fhx74g3\">每个 \n<code>HeroBioComponent</code> 可以编辑单个英雄的传记。 一个 \n<code>HeroBioComponent</code> 依赖于一个 \n<code>HeroCacheService</code> 来获取、缓存和对该英雄执行其他持久化操作。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-cache.service.ts\" region=\"service\" title=\"src/app/hero-cache.service.ts\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroCacheService {\n  hero: Hero;\n  constructor(private heroService: HeroService) {}\n\n  fetchCachedHero(id: number) {\n    if (!this.hero) {\n      this.hero = this.heroService.getHeroById(id);\n    }\n    return this.hero;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ea3eacfezgzq2mk6edilmsjyb\">显然，三个 \n<code>HeroBioComponent</code> 实例不能共享同一个 \n<code>HeroCacheService</code>。 它们会相互竞争以确定要缓存哪个英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8m9kzjvrmnlmswc68e118klpd\">每个 \n<code>HeroBioComponent</code> 通过在其元数据 \n<code>providers</code> 数组中列出 \n<code>HeroCacheService</code> 来获取\n<em>自己的</em> \n<code>HeroCacheService</code> 实例。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"component\" title=\"src/app/hero-bio.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bio',\n  template: `\n    &lt;h4&gt;{{hero.name}}&lt;/h4&gt;\n    &lt;ng-content&gt;&lt;/ng-content&gt;\n    &lt;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\"&gt;&lt;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>&gt;`,\n  providers: [HeroCacheService]\n})\n\nexport class HeroBioComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>  {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() heroId: number;\n\n  constructor(private heroCache: HeroCacheService) { }\n\n  ngOnInit() { this.heroCache.fetchCachedHero(this.heroId); }\n\n  get hero() { return this.heroCache.hero; }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"70x5byuvm1z3u2wtddhxaqqdm\">父 \n<code>HeroBiosComponent</code> 将一个值绑定到 \n<code>heroId</code>。 \n<code>ngOnInit</code> 将该 \n<code>id</code> 传递给服务，服务获取并缓存英雄。 \n<code>hero</code> 属性的 getter 从服务中获取缓存的英雄。 模板显示此数据绑定的属性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b7fxlqlf2us7gfsdsm5tfe79b\">在 \n<live-example name=\"dependency-injection-in-action\">\n 动态示例代码\n</live-example> 中找到此示例，并确认三个 \n<code>HeroBioComponent</code> 实例拥有自己的缓存英雄数据。</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bios.png\" alt=\"Bios\" width=\"199\" height=\"317\">\n</figure>\n<a id=\"optional\"></a>\n<a id=\"qualify-dependency-lookup\"></a>\n<h2 id=\"qualify-dependency-lookup-with-optional-and-host\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9aouv10f95m85lrxw533fisgq\"><i class=\"material-icons\">link</i>使用\n<em>@Optional()</em> 和 \n<code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 限定依赖项查找</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5wic29ufxt3c2yjbyamkzt25\">如你所知，依赖项可以在组件层次结构中的任何级别注册。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3zbf6b8uar02nay3va3p6mv8\">当组件请求依赖项时，Angular 从该组件的注入器开始，并向上遍历注入器树，直到找到第一个合适的提供者。如果在遍历过程中找不到依赖项，Angular 会抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1w7a3wa6ect8d9sdhl1m8d82\">你\n<em>希望</em>大多数情况下出现这种行为。 但有时你需要限制搜索和/或适应缺少的依赖项。 你可以使用 \n<code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 和 \n<code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 限定装饰器来修改 Angular 的搜索行为， 可以单独使用，也可以一起使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cjus17uzma1bpzr6nlvdv44yg\"><code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> 装饰器告诉 Angular 在找不到依赖项时继续。 Angular 将注入参数设置为 \n<code>null</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zwbvbxt6w930g7drmcajcxrk\"><code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code> 装饰器在\n<em>宿主组件</em>处停止向上搜索。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0orjf8xs86syhuyleaqu8vd4\">宿主组件通常是请求依赖项的组件。 但当此组件被投影到\n<em>父</em>组件中时，该父组件将成为宿主。 下一个示例涵盖了第二种情况。</p>\n<a id=\"demonstration\"></a>\n<h3 id=\"demonstration\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5b7w3ol4py5va9kaqcg4bws5q\"><i class=\"material-icons\">link</i>演示</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ira4l2u62duuy4ophlyiezbt\"><code>HeroBiosAndContactsComponent</code> 是你之前查看过的 \n<code>HeroBiosComponent</code> 的一个修订版，\n<a href=\"guide/dependency-injection-in-action#hero-bios-component\">参见此处</a>。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"hero-bios-and-contacts\" title=\"src/app/hero-bios.component.ts (HeroBiosAndContactsComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-bios-and-contacts',\n  template: `\n    &lt;app-hero-bio [heroId]=\"1\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"2\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n    &lt;app-hero-bio [heroId]=\"3\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;`,\n  providers: [HeroService]\n})\nexport class HeroBiosAndContactsComponent {\n  constructor(logger: LoggerService) {\n    logger.logInfo('Creating HeroBiosAndContactsComponent');\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9z1lei5qeso1bcrmfg36ppq84\">注意看模板：</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"template\" title=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" linenums=\"false\">\ntemplate: `\n  &lt;app-hero-bio [heroId]=\"1\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n  &lt;app-hero-bio [heroId]=\"2\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;\n  &lt;app-hero-bio [heroId]=\"3\"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;`,\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ixdv9fpltlzckruhq2zxuiqz\">现在，在 \n<code>&lt;hero-bio&gt;</code> 标签之间有一个新的 \n<code>&lt;hero-contact&gt;</code> 元素。 Angular 将相应的 \n<code>HeroContactComponent</code> \n<em>投影</em>或\n<em>转入</em> \n<code>HeroBioComponent</code> 视图中， 将其放置在 \n<code>HeroBioComponent</code> 模板的 \n<code>&lt;ng-content&gt;</code> 插槽中：</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bio.component.ts\" region=\"template\" title=\"src/app/hero-bio.component.ts (template)\" linenums=\"false\">\ntemplate: `\n  &lt;h4&gt;{{hero.name}}&lt;/h4&gt;\n  &lt;ng-content&gt;&lt;/ng-content&gt;\n  &lt;<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a> cols=\"25\" [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.description\"&gt;&lt;/<a href=\"api/forms/DefaultValueAccessor\" class=\"code-anchor\">textarea</a>&gt;`,\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"az43fgzqrpnonogvn6oatwkmt\">它看起来像这样，来自 \n<code>HeroContactComponent</code> 的英雄电话号码被投影到英雄描述之上：</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bio-and-content.png\" alt=\"bio and contact\" width=\"199\" height=\"92\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eup6b3ouzfs86v1th7bumyehg\">这是 \n<code>HeroContactComponent</code>，它演示了限定装饰器：</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"component\" title=\"src/app/hero-contact.component.ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-contact',\n  template: `\n  &lt;div&gt;Phone #: {{phoneNumber}}\n  &lt;span *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hasLogger\"&gt;!!!&lt;/span&gt;&lt;/div&gt;`\n})\nexport class HeroContactComponent {\n\n  hasLogger = false;\n\n  constructor(\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // limit to the host component's instance of the HeroCacheService\n      private heroCache: HeroCacheService,\n\n      @<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // limit search for logger; hides the application-wide logger\n      @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // ok if the logger doesn't exist\n      private loggerService: LoggerService\n  ) {\n    if (loggerService) {\n      this.hasLogger = true;\n      loggerService.logInfo('HeroContactComponent can log!');\n    }\n  }\n\n  get phoneNumber() { return this.heroCache.hero.phone; }\n\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq9m2jyzn3ftmiiebc4zteifz\">注意看构造函数参数：</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-contact.component.ts\" region=\"ctor-params\" title=\"src/app/hero-contact.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>() // limit to the host component's instance of the HeroCacheService\nprivate heroCache: HeroCacheService,\n\n@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()     // limit search for logger; hides the application-wide logger\n@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() // ok if the logger doesn't exist\nprivate loggerService: LoggerService\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7wfkauoc1n6s4cm21pxgbd145\">装饰 \n<code>heroCache</code> 属性的 \n<code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 函数确保 你从父 \n<code>HeroBioComponent</code> 获取缓存服务的引用。 如果父组件缺少该服务，即使组件树中更高层的组件恰好拥有该服务，Angular 也会抛出错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ceolz0xpt8q9oc4p3wsnxhzh\">第二个 \n<code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 函数装饰 \n<code>loggerService</code> 属性。 应用中唯一的 \n<code>LoggerService</code> 实例是在 \n<code>AppComponent</code> 级别提供的。 宿主 \n<code>HeroBioComponent</code> 没有自己的 \n<code>LoggerService</code> 提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80yqncbs8xu277m2x0lzivl0z\">如果你没有用 \n<code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code> 函数装饰该属性，Angular 就会抛出错误。 由于 \n<code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>()</code>，Angular 将 \n<code>loggerService</code> 设置为 null，组件的其余部分会进行调整。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"542nzzlldllpm5olh8fjphvbs\">这是 \n<code>HeroBiosAndContactsComponent</code> 的实际运行情况。</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bios-and-contacts.png\" alt=\"Bios with contact into\" width=\"206\" height=\"393\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mb5d8nhm15jln52rln4f2239\">如果你注释掉 \n<code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 装饰器，Angular 现在会向上遍历注入器祖先树， 直到在 \n<code>AppComponent</code> 级别找到记录器。记录器逻辑开始执行，英雄显示会更新， 并带有“！！！”，表示找到了记录器。</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-bio-contact-no-host.png\" alt=\"Without @Host\" width=\"199\" height=\"93\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8kz52c6mf2adu4sriqvaubswa\">另一方面，如果你恢复 \n<code>@<a href=\"api/core/Host\" class=\"code-anchor\">Host</a>()</code> 装饰器并注释掉 \n<code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>， 应用程序由于缺少宿主组件级别的必要记录器而失败。 \n<br> \n<code>EXCEPTION: No provider for LoggerService! (HeroContactComponent -&gt; LoggerService)</code> \n<a id=\"component-element\"></a></p>\n<h2 id=\"inject-the-components-dom-element\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"3t3t1k1nae7wrfi1vhavne2s7\"><i class=\"material-icons\">link</i>注入组件的 DOM 元素</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5953upi4o2nipnbfmf4t5s2pu\">有时你可能需要访问组件的相应 DOM 元素。 尽管开发人员努力避免这种情况，但许多视觉效果和第三方工具（如 jQuery） 需要 DOM 访问。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cd11tssrj32ud5r2nk5x0w4nd\">为了说明这一点，这里有一个来自 \n<a href=\"guide/attribute-directives\">属性型指令</a> 页面的 \n<code>HighlightDirective</code> 的简化版本。</p>\n<code-example path=\"dependency-injection-in-action/src/app/highlight.directive.ts\" title=\"src/app/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appHighlight]'\n})\nexport class HighlightDirective {\n\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appHighlight') highlightColor: string;\n\n  private el: HTMLElement;\n\n  constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    this.el = el.nativeElement;\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseenter') onMouseEnter() {\n    this.highlight(this.highlightColor || 'cyan');\n  }\n\n  @<a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a>('mouseleave') onMouseLeave() {\n    this.highlight(null);\n  }\n\n  private highlight(color: string) {\n    this.el.style.backgroundColor = color;\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2ojps75gmxa9ymw3cvviml0m\">当用户将鼠标悬停在应用了该指令的 DOM 元素上时，该指令会将背景设置为突出显示颜色。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9h6ihzy897paivy5tl0yctfn1\">Angular 将构造函数的 \n<code>el</code> 参数设置为注入的 \n<code><a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a></code>，它是 该 DOM 元素的包装器。 它的 \n<code>nativeElement</code> 属性公开了 DOM 元素，以便指令对其进行操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6l5fiq9ruujmsq6a19bnmx4sl\">示例代码将指令的 \n<code>myHighlight</code> 属性应用于两个 \n<code>&lt;div&gt;</code> 标签， 第一个没有值（产生默认颜色），第二个有分配的颜色值。</p>\n<code-example path=\"dependency-injection-in-action/src/app/app.component.html\" region=\"highlight\" title=\"src/app/app.component.html (highlight)\" linenums=\"false\">\n&lt;div id=\"highlight\"  class=\"di-component\"  appHighlight&gt;\n  &lt;h3&gt;Hero Bios and Contacts&lt;/h3&gt;\n  &lt;div appHighlight=\"yellow\"&gt;\n    &lt;app-hero-bios-and-contacts&gt;&lt;/app-hero-bios-and-contacts&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66qwt2c9w8lr9r8ecd72r6lcd\">下图显示了将鼠标悬停在 \n<code>&lt;hero-bios-and-contacts&gt;</code> 标签上的效果。</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/highlight.png\" alt=\"Highlighted bios\" width=\"318\" height=\"196\">\n</figure>\n<a id=\"providers\"></a>\n<h2 id=\"define-dependencies-with-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7653b6a3ee6r0z5h543xdb0v4\"><i class=\"material-icons\">link</i>使用提供者定义依赖项</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5geveayobbyyhxnqvhoflpsog\">本节演示如何编写提供者来传递依赖服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97a0dl6q95ve0rns2zn4x4p1h\">通过提供一个\n<strong><em>令牌</em></strong>从依赖注入器获取服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bw3dh2kmylfietweumfw49ig3\">你通常让 Angular 处理此事务，方法是指定构造函数参数及其类型。 参数类型充当注入器查找\n<em>令牌</em>。 Angular 将此令牌传递给注入器，并将结果分配给参数。 这是一个典型的示例：</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"ctor\" title=\"src/app/hero-bios.component.ts (component constructor injection)\" linenums=\"false\">\nconstructor(logger: LoggerService) {\n  logger.logInfo('Creating HeroBiosComponent');\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1vkz3kyp693b0wsjooxsm7kg8\">Angular 向注入器请求与 \n<code>LoggerService</code> 关联的服务， 并将返回的值分配给 \n<code>logger</code> 参数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85kmt0v8peka53gvd9n1zgm6t\">注入器从哪里获取该值？ 它可能已经在其内部容器中拥有该值。 如果没有，它可能能够在\n<strong><em>提供者</em></strong>的帮助下创建一个。 \n<em>提供者</em>是传递与\n<em>令牌</em>关联的服务的配方。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4yc71mhntvg5n43k8a47s7jr5\">如果注入器没有为请求的\n<em>令牌</em>提供提供者，它会将请求委托给其父注入器， 在那里该过程会重复，直到没有更多注入器。 如果搜索无果，注入器会抛出错误，除非请求是\n<a href=\"guide/dependency-injection-in-action#optional\">可选的</a>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5hjp16zb9bxungp0zeypfvxs9\">一个新的注入器没有提供者。 Angular 使用它关心的某些提供者来初始化它创建的注入器。 你必须手动注册\n<em>自己的</em>应用程序提供者， 通常在 \n<code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 或 \n<code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code> 元数据的 \n<code>providers</code> 数组中：</p>\n<code-example path=\"dependency-injection-in-action/src/app/app.component.ts\" region=\"providers\" title=\"src/app/app.component.ts (providers)\">\nproviders: [ LoggerService, UserContextService, UserService ]\n\n</code-example>\n<a id=\"defining-providers\"></a>\n<h3 id=\"defining-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"76ybfnaadge56y6ve0dh12x3z\"><i class=\"material-icons\">link</i>定义提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3afkkxixi6kagcq6eqyukzhqj\">简单类提供者是迄今为止最典型的。 你在 \n<code>providers</code> 数组中提及该类，就完成了。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-bios.component.ts\" region=\"class-provider\" title=\"src/app/hero-bios.component.ts (class provider)\" linenums=\"false\">\nproviders: [HeroService]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cgbaw286raiv9ghcv16t0nvay\">之所以如此简单，是因为最常见的注入服务是类的实例。 但并非所有依赖项都可以通过创建类的新的实例来满足。 你需要其他方法来传递依赖值，这意味着你需要其他方法来指定提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnyt4gwrwev5cztwaop1avb8d\"><code>HeroOfTheMonthComponent</code> 示例演示了许多替代方案，以及为什么你需要它们。 它在视觉上很简单：一些属性和记录器产生的日志。</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/hero-of-month.png\" alt=\"Hero of the month\" width=\"300\" height=\"165\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9b8kwa9x56gd79k6g80vj9a4y\">它背后的代码让你有很多思考的地方。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"hero-of-the-month\" title=\"hero-of-the-month.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nimport { DateLoggerService } from './date-logger.service';\nimport { Hero }              from './hero';\nimport { HeroService }       from './hero.service';\nimport { LoggerService }     from './logger.service';\nimport { MinimalLogger }     from './minimal-logger.service';\nimport { RUNNERS_UP,\n         runnersUpFactory }  from './runners-up';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  providers: [\n    { provide: Hero,          useValue:    someHero },\n    { provide: TITLE,         useValue:   'Hero of the Month' },\n    { provide: HeroService,   useClass:    HeroService },\n    { provide: LoggerService, useClass:    DateLoggerService },\n    { provide: MinimalLogger, useExisting: LoggerService },\n    { provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n  ]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n\n  constructor(\n      logger: MinimalLogger,\n      public heroOfTheMonth: Hero,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(RUNNERS_UP) public runnersUp: string,\n      @<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(TITLE) public title: string)\n  {\n    this.logs = logger.logs;\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<a id=\"provide\"></a>\n<h4 id=\"the-provide-object-literal\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rp7x0wdfhfd6a5pbg1jk8vwf\"><i class=\"material-icons\">link</i><em>provide</em> 对象字面量</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hg7t5qut2ze4f8weaf7drxkt\"><code>provide</code> 对象字面量接受一个 \n<em>令牌</em> 和一个 \n<em>定义对象</em>。 \n<em>令牌</em> 通常是一个类，但 \n<a href=\"guide/dependency-injection-in-action#tokens\">它不一定是</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56wz324v5gzjmis54nhudbe4\"><em>定义</em> 对象有一个必需的属性，用于指定如何创建服务的单例实例。在本例中，该属性是。</p>\n<a id=\"usevalue\"></a>\n<h4 id=\"usevaluethe-value-provider\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2p3dx2cftd93glsdqx4qz1om5\"><i class=\"material-icons\">link</i>useValue—\n<em>值提供者</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8eqhltf0n010gdq3utb6kp3wg\">将 \n<code>useValue</code> 属性设置为一个 \n<strong><em>固定值</em></strong>，提供者可以将其作为服务实例（也称为“依赖项对象”）返回。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azunbt2xuml0styq4zc1qowd4\">使用此技术提供 \n<em>运行时配置常量</em>，例如网站基本地址和特性标志。 你可以在单元测试中使用 \n<em>值提供者</em> 来用假服务或模拟服务替换生产服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78kj8tq609amlj09erknz2gur\"><code>HeroOfTheMonthComponent</code> 示例有两个 \n<em>值提供者</em>。 第一个提供 \n<code>Hero</code> 类的实例； 第二个指定一个字面量字符串资源：</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-value\" title=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\n{ provide: Hero,          useValue:    someHero },\n{ provide: TITLE,         useValue:   'Hero of the Month' },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3g64y4ghh3cacjpoegl10e2ri\"><code>Hero</code> 提供者令牌是一个类，这是有意义的，因为该值是一个 \n<code>Hero</code>， 并且注入英雄的使用者会希望获得类型信息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ixk5vaziwr36wjeudioafwre\"><code>TITLE</code> 提供者令牌 \n<em>不是一个类</em>。 它是一种特殊的提供者查找键，称为 \n<a href=\"guide/dependency-injection-in-action#injection-token\">注入令牌</a>。 你可以对任何类型的提供者使用 \n<code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code>，但它在依赖项是简单值（如字符串、数字或函数）时特别有用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"12r6dvvj1yra7wsufhgkig7p0\"><em>值提供者</em> 的值必须 \n<em>现在</em> 定义。你不能稍后创建该值。 显然，标题字符串字面量是立即可用的。 本示例中的 \n<code>someHero</code> 变量是在文件中的前面设置的：</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"some-hero\" title=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\nconst someHero = new Hero(42, 'Magma', 'Had <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> great month!', '555-555-5555');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5u7jtqy4qvj1te8nzte1fo4rn\">其他提供者在需要注入时 \n<em>延迟</em> 创建它们的值。</p>\n<a id=\"useclass\"></a>\n<h4 id=\"useclassthe-class-provider\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a0bz2k3iyk0tcjs3ykneu726i\"><i class=\"material-icons\">link</i>useClass—\n<em>类提供者</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afyebp523pzvgy5w6enyg26mq\"><code>useClass</code> 提供者创建并返回指定类的新的实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nawdrq5ygj7zroopw96uyzcy\">使用此技术 \n<strong><em>替换</em></strong> 通用类或默认类的 \n<strong><em>备用实现</em></strong>。 备用实现可以实现不同的策略，扩展默认类， 或在测试用例中模拟真实类的行为。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ulx9hsf91y995iv19fzxubz5\">以下是 \n<code>HeroOfTheMonthComponent</code> 中的两个示例：</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-class\" title=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\n{ provide: HeroService,   useClass:    HeroService },\n{ provide: LoggerService, useClass:    DateLoggerService },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dq22kc2qhy3hhwl0t6ual5mxd\">第一个提供者是 \n<em>去糖化</em> 的扩展形式，是最典型的情况，其中要创建的类（\n<code>HeroService</code>）也是提供者的依赖注入令牌。 它以这种长形式是为了消除首选的短形式的神秘感。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9napdgwx1i04g73gph7q5kpsp\">第二个提供者用 \n<code>DateLoggerService</code> 替换 \n<code>LoggerService</code>。 \n<code>LoggerService</code> 已经在 \n<code>AppComponent</code> 级别注册。 当 \n<em>此组件</em> 请求 \n<code>LoggerService</code> 时，它会收到 \n<code>DateLoggerService</code>。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"csnzqi8ppw1c69p2aa0q0dcis\">此组件及其子组件树会收到 \n<code>DateLoggerService</code> 实例。 树外的组件将继续收到原始的 \n<code>LoggerService</code> 实例。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"42b20b8d72q16foq3th2ygld4\"><code>DateLoggerService</code> 继承自 \n<code>LoggerService</code>；它将当前日期/时间附加到每条消息：</p>\n<code-example path=\"dependency-injection-in-action/src/app/date-logger.service.ts\" region=\"date-logger-service\" title=\"src/app/date-logger.service.ts\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class DateLoggerService extends LoggerService\n{\n  logInfo(msg: any)  { super.logInfo(stamp(msg)); }\n  logDebug(msg: any) { super.logInfo(stamp(msg)); }\n  logError(msg: any) { super.logError(stamp(msg)); }\n}\n\nfunction stamp(msg: any) { return msg + ' at ' + new Date(); }\n\n</code-example>\n<a id=\"useexisting\"></a>\n<h4 id=\"useexistingthe-alias-provider\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5d3blp4mzhi3o52wh93bghg4l\"><i class=\"material-icons\">link</i><em>useExisting</em>—\n<em>别名提供者</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ayzeuyz35z0hsooyv8o1rthr1\"><code>useExisting</code> 提供者将一个令牌映射到另一个令牌。 实际上，第一个令牌是与第二个令牌关联的服务的 \n<strong><em>别名</em></strong>， 创建 \n<strong><em>两种访问同一个服务对象的方式</em></strong>。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\" title=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7lgqc9hfqlpq5ip8l9e3k4gfb\">通过别名接口缩小 API 是 \n<em>一种</em> 重要用例。 以下示例展示了为此目的进行别名。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlbxot42u8d3b7r4b9ocithbi\">假设 \n<code>LoggerService</code> 有一个很大的 API，比实际的三个方法和一个属性大得多。 你可能希望将该 API 表面缩小到实际需要的成员。 这里，\n<code>MinimalLogger</code> \n<a href=\"guide/dependency-injection-in-action#class-interface\"><em>类接口</em></a> 将 API 缩减到两个成员：</p>\n<code-example path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" title=\"src/app/minimal-logger.service.ts\" linenums=\"false\">\n// Class used as <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> \"narrowing\" interface that exposes <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> minimal logger\n// Other members of the actual implementation are invisible\nexport abstract class MinimalLogger {\n  logs: string[];\n  logInfo: (msg: string) =&gt; void;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d81gkx33g6o08zb968ofu5wbn\">现在，在 \n<code>HeroOfTheMonthComponent</code> 的简化版本中使用它。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.1.ts\" title=\"src/app/hero-of-the-month.component.ts (minimal version)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-of-the-month',\n  templateUrl: './hero-of-the-month.component.html',\n  // TODO: move this aliasing, `useExisting` provider to the AppModule\n  providers: [{ provide: MinimalLogger, useExisting: LoggerService }]\n})\nexport class HeroOfTheMonthComponent {\n  logs: string[] = [];\n  constructor(logger: MinimalLogger) {\n    logger.logInfo('starting up');\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8istes8kwczkqzwumdc3mw75i\"><code>HeroOfTheMonthComponent</code> 构造函数的 \n<code>logger</code> 参数类型为 \n<code>MinimalLogger</code>，因此在支持 TypeScript 的编辑器中，只有 \n<code>logs</code> 和 \n<code>logInfo</code> 成员可见：</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/minimal-logger-intellisense.png\" alt=\"MinimalLogger restricted API\" width=\"532\" height=\"60\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7pncwubvfulpl5if91gyyx1jy\">在幕后，Angular 实际上将 \n<code>logger</code> 参数设置为在 \n<code>LoggingService</code> 令牌下注册的完整服务，该服务恰好是上面 \n<a href=\"guide/dependency-injection-in-action#useclass\">提供的</a> \n<code>DateLoggerService</code>。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djzzmbkcbd3m5igzbz6ca3csf\">以下图像显示了日志记录日期，证实了这一点：</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/date-logger-entry.png\" alt=\"DateLoggerService entry\" width=\"300\" height=\"32\">\n</figure>\n</div>\n<a id=\"usefactory\"></a>\n<h4 id=\"usefactorythe-factory-provider\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6esn3tyrl6xbe2oe6cwp7ifb0\"><i class=\"material-icons\">link</i><em>useFactory</em>—\n<em>工厂提供者</em></h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3knei9k2aeqrzv7pvmbdcsgez\"><code>useFactory</code> 提供者通过调用工厂函数来创建依赖项对象，如本示例所示。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-factory\" title=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rwz444yx85e2ji16t6wpm12j\">使用此技术 \n<strong><em>创建依赖项对象</em></strong>， 使用工厂函数，其输入是 \n<strong><em>注入的服务和本地状态的组合</em></strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4po7oznjygcf3yurnou62dmf1\"><em>依赖项对象</em> 不必是类实例。它可以是任何东西。 在本示例中，\n<em>依赖项对象</em> 是“本月英雄”比赛亚军的姓名字符串。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2krnvdd8izmquaa1zbdpyu85d\">本地状态是数字 \n<code>2</code>，即此组件应显示的亚军数量。 它立即使用 \n<code>2</code> 执行 \n<code>runnersUpFactory</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3f8due7baqueoa7tl7go2svkj\"><code>runnersUpFactory</code> 本身不是提供者工厂函数。 真正的提供者工厂函数是 \n<code>runnersUpFactory</code> 返回的函数。</p>\n<code-example path=\"dependency-injection-in-action/src/app/runners-up.ts\" region=\"factory-synopsis\" title=\"runners-up.ts (excerpt)\" linenums=\"false\">\nexport function runnersUpFactory(take: number) {\n  return (winner: Hero, heroService: HeroService): string =&gt; {\n    /* ... */\n  };\n};\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5thyygjjozg4mfjn5qwcv1sxu\">该返回的函数以获胜的 \n<code>Hero</code> 和 \n<code>HeroService</code> 作为参数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ds72vpqpv9lz9k0mrr5cewkua\">Angular 从 \n<code>deps</code> 数组中的两个 \n<em>令牌</em> 标识的注入值中提供这些参数。 两个 \n<code>deps</code> 值是注入器用来提供这些工厂函数依赖项的 \n<em>令牌</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bt6ocr59kc436vlt5crqudgoe\">在完成一些未公开的工作后，该函数返回姓名字符串，Angular 将其注入到 \n<code>HeroOfTheMonthComponent</code> 的 \n<code>runnersUp</code> 参数中。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1hv4u2hrlshvuou3m8sljmt0p\">该函数从 \n<code>HeroService</code> 中检索候选英雄， 选取 \n<code>2</code> 个作为亚军，并返回它们的连接后的姓名。 查看 \n<live-example name=\"dependency-injection-in-action\"></live-example> 以获取完整的源代码。</p>\n</div>\n<a id=\"tokens\"></a>\n<h2 id=\"provider-token-alternatives-the-class-interface-and-injectiontoken\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8lsfs261mu88n2pi4yjmw7d71\"><i class=\"material-icons\">link</i>提供者令牌替代方案：\n<em>类接口</em> 和 \n<em>注入令牌</em></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4374gkihgjgmw32nlgqe0gte7\">当提供者 \n<em>令牌</em> 是一个类时，Angular 依赖注入最容易， 该类也是返回的依赖项对象的类型，或者你通常称为 \n<em>服务</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5jxg0r11hosl7bhq88awg1vru\">但令牌不必是类，即使它是类， 它也不必与返回的对象类型相同。 这是下一节的主题。 \n<a id=\"class-interface\"></a></p>\n<h3 id=\"class-interface\">class-interface</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dzjp8a7vsqdjtqicjrrn41ilz\">前面的 \n<em>本月英雄</em> 示例使用 \n<code>MinimalLogger</code> 类 作为 \n<code>LoggerService</code> 提供者的令牌。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"use-existing\" title=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\">\n{ provide: MinimalLogger, useExisting: LoggerService },\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9jq4th1eerbflw8q7g6esfx9r\"><code>MinimalLogger</code> 是一个抽象类。</p>\n<code-example path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" title=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" linenums=\"false\">\n// Class used as <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> \"narrowing\" interface that exposes <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> minimal logger\n// Other members of the actual implementation are invisible\nexport abstract class MinimalLogger {\n  logs: string[];\n  logInfo: (msg: string) =&gt; void;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djjvkeo800gfh8paifrpxe53j\">你通常从抽象类继承。 但此应用程序中的 \n<em>任何类</em> 都没有从 \n<code>MinimalLogger</code> 继承。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"baah5wmp1yhxyy39nwdx9gy2u\"><code>LoggerService</code> 和 \n<code>DateLoggerService</code> \n<em>可以</em> 从 \n<code>MinimalLogger</code> 继承。 它们可以 \n<em>实现</em> 它，而不是像接口那样。 但它们都没有这样做。 \n<code>MinimalLogger</code> 仅用作依赖注入令牌。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2dmfz70qtha43ny618sea6cdb\">当你以这种方式使用类时，它被称为 \n<strong><em>类接口</em></strong>。 \n<em>类接口</em> 的主要好处是你可以获得接口的强类型， 并且你可以 \n<strong><em>像使用普通类一样将其用作提供者令牌</em></strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmylz02y13cgnzljbnngq518p\"><strong><em>类接口</em></strong> 应该 \n<em>只</em> 定义其使用者可以调用的成员。 这种缩小接口有助于将具体类与其使用者解耦。</p>\n<div class=\"l-sub-section\">\n<h4 id=\"why-minimallogger-is-a-class-and-not-a-typescript-interface\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7qy8jkfy9akfv076qaot6zjpa\"><i class=\"material-icons\">link</i>为什么 \n<em>MinimalLogger</em> 是一个类而不是 TypeScript 接口</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44wuymmt5q79xlg9e6kcdnlej\">你不能将接口用作提供者令牌，因为 接口不是 JavaScript 对象。 它们只存在于 TypeScript 设计空间中。 在代码被转译为 JavaScript 后，它们就会消失。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6wclv4v0ot2i7tit5nxavkl0\">提供者令牌必须是某种真实的 JavaScript 对象： 例如函数、对象、字符串或类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5exaeuva44kf00sq33ial5ops\">将类用作接口，可以在真实的 JavaScript 对象中获得接口的特性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"12k6d2u5sqqcszpm5idoaifk0\">当然，真实的 JavaScript 对象会占用内存。为了最大程度地减少内存消耗，该类应该\n<em>没有实现</em>。 \n<code>MinimalLogger</code> 会被转译成以下未优化的、未压缩的 JavaScript 构造函数代码：</p>\n<code-example path=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" region=\"minimal-logger-transpiled\" title=\"dependency-injection-in-action/src/app/minimal-logger.service.ts\" linenums=\"false\">\nvar MinimalLogger = (function () {\n  function MinimalLogger() {}\n  return MinimalLogger;\n}());\nexports(\"MinimalLogger\", MinimalLogger);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8n9hdhoo8u3y8g29hhtd6jaf1\">注意，它没有一个成员。无论你在类中添加多少成员，它都不会增长，\n<em>只要这些成员被类型化但没有实现</em>。再次查看 TypeScript \n<code>MinimalLogger</code> 类，确认它没有实现。</p>\n</div>\n<a id=\"injection-token\"></a>\n<h3 id=\"injectiontoken\"><em>InjectionToken</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qdaefg27hp8fektuak3qd3pu\">依赖对象可以是简单的值，如日期、数字和字符串，也可以是无形状的对象，如数组和函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"80oorfdp9wrfm3rmpona1wvyw\">此类对象没有应用接口，因此不能很好地用类表示。 它们最好用一个既唯一又象征性的令牌来表示， 一个具有友好名称的 JavaScript 对象，但不会与 另一个碰巧具有相同名称的令牌冲突。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4c2nzczn6ixoro1zlm9qnsr73\"><code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> 具有这些特性。 你在\n<em>每月英雄</em>示例中遇到了两次， 在\n<em>标题</em>值提供者和\n<em>亚军</em>工厂提供者中。</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"provide-injection-token\" title=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\n{ provide: TITLE,         useValue:   'Hero of the Month' },\n{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cijdcocenascas60kh8bvxi2n\">你像这样创建了 \n<code>TITLE</code> 令牌：</p>\n<code-example path=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" region=\"injection-token\" title=\"dependency-injection-in-action/src/app/hero-of-the-month.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a> } from '@angular/core';\n\nexport const TITLE = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>&lt;string&gt;('title');\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"an1s4sf7rz1ltvwc16bae0iz2\">类型参数虽然是可选的，但它会向开发人员和工具传达依赖项的类型。 令牌描述是另一个开发人员辅助工具。</p>\n<a id=\"di-inheritance\"></a>\n<h2 id=\"inject-into-a-derived-class\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"821i2phse3qbg520ivkvmills\"><i class=\"material-icons\">link</i>注入到派生类中</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1vujy4athg4sfh3fhtggbasv4\">编写从另一个组件继承的组件时要小心。 如果基组件有注入的依赖项， 你必须在派生类中重新提供和重新注入它们， 然后通过构造函数将它们传递给基类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bbzltz0q76z2g63yw2n8wrq87\">在这个人为的示例中，\n<code>SortedHeroesComponent</code> 继承自 \n<code>HeroesBaseComponent</code> 以显示一个\n<em>排序</em>的英雄列表。</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/sorted-heroes.png\" alt=\"Sorted Heroes\" width=\"135\" height=\"107\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f53sdu10zeja4o2ed9ln23g9m\"><code>HeroesBaseComponent</code> 可以独立存在。 它需要自己的 \n<code>HeroService</code> 实例来获取英雄， 并按从数据库接收到的顺序显示它们。</p>\n<code-example path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"heroes-base\" title=\"src/app/sorted-heroes.component.ts (HeroesBaseComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-unsorted-heroes',\n  template: `&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;`,\n  providers: [HeroService]\n})\nexport class HeroesBaseComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private heroService: HeroService) { }\n\n  heroes: Array&lt;Hero&gt;;\n\n  ngOnInit() {\n    this.heroes = this.heroService.getAllHeroes();\n    this.afterGetHeroes();\n  }\n\n  // Post-process heroes in derived class override.\n  protected afterGetHeroes() {}\n\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c0ufu7ag3hpcg9ish1q1xsxfx\"><strong><em>保持构造函数简单。</em></strong> 它们应该只做初始化变量的工作。 这条规则使组件在测试中安全地构造，而不必担心它会做一些戏剧性的操作，比如与服务器通信。 这就是为什么你从 \n<code>ngOnInit</code> 而不是构造函数中调用 \n<code>HeroService</code> 的原因。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eyzd4su5av4rx01zbnvx1n6nh\">用户希望按字母顺序查看英雄。 与其修改原始组件，不如对其进行子类化，并创建一个 \n<code>SortedHeroesComponent</code>，在呈现英雄之前对它们进行排序。 \n<code>SortedHeroesComponent</code> 允许基类获取英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6wpkwpmfz2trbagvr9t5ijazl\">不幸的是，Angular 无法将 \n<code>HeroService</code> 直接注入到基类中。 你必须再次为\n<em>此</em>组件提供 \n<code>HeroService</code>， 然后在构造函数中将其传递给基类。</p>\n<code-example path=\"dependency-injection-in-action/src/app/sorted-heroes.component.ts\" region=\"sorted-heroes\" title=\"src/app/sorted-heroes.component.ts (SortedHeroesComponent)\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-sorted-heroes',\n  template: `&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;{{hero.name}}&lt;/div&gt;`,\n  providers: [HeroService]\n})\nexport class SortedHeroesComponent extends HeroesBaseComponent {\n  constructor(heroService: HeroService) {\n    super(heroService);\n  }\n\n  protected afterGetHeroes() {\n    this.heroes = this.heroes.sort((h1, h2) =&gt; {\n      return h1.name &lt; h2.name ? -1 :\n            (h1.name &gt; h2.name ? 1 : 0);\n    });\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d982qsj7dilu5kl9410ogvwm\">现在注意 \n<code>afterGetHeroes()</code> 方法。 你的第一直觉可能是创建 \n<code>SortedHeroesComponent</code> 中的 \n<code>ngOnInit</code> 方法，并在那里进行排序。 但 Angular 在调用基类的 \n<code>ngOnInit</code> \n<em>之前</em>调用\n<em>派生</em>类的 \n<code>ngOnInit</code>， 因此你将在\n<em>英雄数组到达之前</em>对它们进行排序。这会导致一个严重的错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aj9n8jtipkij4iha98ykumyu8\">重写基类的 \n<code>afterGetHeroes()</code> 方法可以解决这个问题。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"668knfuob4alegihqtv1mso91\">这些复杂情况表明\n<em>应该避免组件继承</em>。</p>\n<a id=\"find-parent\"></a>\n<h2 id=\"find-a-parent-component-by-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3kecinuystrtp04szsrl8cv2\"><i class=\"material-icons\">link</i>通过注入查找父组件</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"859b5zzpwfqefqgpg45i2bcgc\">应用程序组件通常需要共享信息。 数据绑定和服务共享等耦合度更低的技术 更可取。但有时一个组件 直接引用另一个组件是有意义的， 也许是为了访问该组件的值或调用该组件的方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhj6qkcgz0u37yuvq8armjv1m\">在 Angular 中获取组件引用有点棘手。 虽然 Angular 应用程序是组件树， 但没有用于检查和遍历该树的公共 API。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eo4jcxijeg0pkavus3be23w7a\">有一个用于获取子引用 API。 查看 \n<a href=\"api/core/Query\" class=\"code-anchor\">Query</a>、\n<code><a href=\"api/core/QueryList\" class=\"code-anchor\">QueryList</a></code>、\n<code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code> 和 \n<code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code> 在 \n<a href=\"api/\">API 参考</a> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41ooeve5zqe7kkcdng78t70zq\">没有用于获取父引用的公共 API。 但由于每个组件实例都添加到注入器的容器中， 你可以使用 Angular 依赖注入来访问父组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2plcuym2twbtzul6m1ksrob9\">本节介绍了一些执行此操作的技术。</p>\n<a id=\"known-parent\"></a>\n<h3 id=\"find-a-parent-component-of-known-type\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d5yyf2i0t3rskncynrh1svqiy\"><i class=\"material-icons\">link</i>查找已知类型的父组件</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6g26rfzw670t5wj6cxdvykm3b\">你使用标准类注入来获取已知类型的父组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tg8h1ol3mz5qzuon06fx2pfh\">在以下示例中，父 \n<code>AlexComponent</code> 有几个子组件，包括 \n<code>CathyComponent</code>：</p>\n<a id=\"alex\"></a>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-1\" title=\"parent-finder.component.ts (AlexComponent v.1)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'alex',\n  template: `\n    &lt;div class=\"<a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a>\"&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;cathy&gt;&lt;/cathy&gt;\n      &lt;craig&gt;&lt;/craig&gt;\n      &lt;carol&gt;&lt;/carol&gt;\n    &lt;/div&gt;`,\n})\nexport class AlexComponent extends Base\n{\n  name= 'Alex';\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"atzf9daebiyw8s4kdjeype0wt\"><em>Cathy</em> 报告她是否可以访问\n<em>Alex</em>， 方法是在她的构造函数中注入一个 \n<code>AlexComponent</code>：</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"cathy\" title=\"parent-finder.component.ts (CathyComponent)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'cathy',\n  template: `\n  &lt;div class=\"c\"&gt;\n    &lt;h3&gt;Cathy&lt;/h3&gt;\n    {{alex ? 'Found' : 'Did not find'}} Alex via the component class.&lt;br&gt;\n  &lt;/div&gt;`\n})\nexport class CathyComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex: AlexComponent ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"lvnaxbuguck3qwaxvb7rrhtf\">注意，即使 \n<a href=\"guide/dependency-injection-in-action#optional\">@Optional</a> 限定符 在那里是为了安全起见， \n<live-example name=\"dependency-injection-in-action\"></live-example> 确认 \n<code>alex</code> 参数已设置。</p>\n<a id=\"base-parent\"></a>\n<h3 id=\"cannot-find-a-parent-by-its-base-class\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cpkrhjin1g6caxl926suabhh9\"><i class=\"material-icons\">link</i>无法通过基类查找父类</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dpwdw04kyp8gw9mm60yc4yenu\">如果你\n<em>不知道</em>具体的父组件类怎么办？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6fxnviyj4f8qgrr9ntagmn4h2\">可重用组件可能是多个组件的子组件。 想象一个用于渲染金融工具的突发新闻的组件。 出于业务原因，此新闻组件会频繁地直接调用 其父工具，因为不断变化的市场数据流。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7cuz0tvowromj4qrpls2nmvym\">该应用程序可能定义了十几个金融工具组件。 如果你幸运的话，它们都实现了相同的基类， 你的 \n<code>NewsComponent</code> 了解该基类的 API。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ygop61vlz96cs45a8r9422p4\">查找实现接口的组件会更好。 这是不可能的，因为 TypeScript 接口会消失 从转译后的 JavaScript 中，它不支持接口。 没有可以查找的工件。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8yvttbkspugial7j6w9i8i9i\">这并不一定是一个好的设计。 此示例正在检查\n<em>组件是否可以 通过父类的基类注入其父类</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cwvfcchhpt2uw4llhkqnttudp\">示例中的 \n<code>CraigComponent</code> 探讨了这个问题。 \n<a href=\"guide/dependency-injection-in-action#alex\">回顾</a>， 你会看到 \n<code>Alex</code> 组件\n<em>扩展</em>（\n<em>继承</em>）自名为 \n<code>Base</code> 的类。</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\" title=\"parent-finder.component.ts (Alex class signature)\" linenums=\"false\">\nexport class AlexComponent extends Base\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"99fy1twh7zlscr4y7kh5v6njo\"><code>CraigComponent</code> 尝试将 \n<code>Base</code> 注入到其 \n<code>alex</code> 构造函数参数中，并报告是否成功。</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"craig\" title=\"parent-finder.component.ts (CraigComponent)\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'craig',\n  template: `\n  &lt;div class=\"c\"&gt;\n    &lt;h3&gt;Craig&lt;/h3&gt;\n    {{alex ? 'Found' : 'Did not find'}} Alex via the base class.\n  &lt;/div&gt;`\n})\nexport class CraigComponent {\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public alex: Base ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6xj6siwlsltlkb80lcfss3r1s\">不幸的是，这不起作用。 \n<live-example name=\"dependency-injection-in-action\"></live-example> 确认 \n<code>alex</code> 参数为 null。 \n<em>你无法通过基类注入父类。</em></p>\n<a id=\"class-interface-parent\"></a>\n<h3 id=\"find-a-parent-by-its-class-interface\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bwbfagxhfp87blxmfp5kbqt1i\"><i class=\"material-icons\">link</i>通过类接口查找父类</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1zysx7zci69urfh1hko2rd3rt\">你可以通过 \n<a href=\"guide/dependency-injection-in-action#class-interface\">类接口</a> 查找父组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2a5xq48nupp09eqw5p6aitozo\">父组件必须通过提供一个\n<em>别名</em>来配合，该别名以\n<em>类接口</em>令牌的名称来表示自身。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6nmtjzsrn8nljf27gc9i7a5pq\">回想一下，Angular 总是将组件实例添加到它自己的注入器中； 这就是为什么你之前可以将\n<em>Alex</em> 注入到\n<em>Cathy</em> 中 \n<a href=\"guide/dependency-injection-in-action#known-parent\">的原因</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"blvy8cszt837fpd8m3shssr8e\">编写一个 \n<a href=\"guide/dependency-injection-in-action#useexisting\"><em>别名提供者</em></a>——一个带有 \n<code>useExisting</code> 定义的 \n<code>provide</code> 对象字面量——它创建了一种\n<em>替代</em>方法来注入相同的组件实例，并将该提供者添加到 \n<code>AlexComponent</code> 的 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 元数据的 \n<code>providers</code> 数组中：</p>\n<a id=\"alex-providers\"></a>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" title=\"parent-finder.component.ts (AlexComponent providers)\" linenums=\"false\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; AlexComponent) }],\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3mop0az67zl0naa55utguary2\"><a href=\"guide/dependency-injection-in-action#parent-token\">Parent</a> 是提供者的\n<em>类接口</em>令牌。 \n<a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> 打破了你刚刚创建的循环引用，因为 \n<code>AlexComponent</code> 引用了自身。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2786cxb1zbpjwtyh7lkchdwit\"><em>Carol</em> 是\n<em>Alex</em> 的三个子组件中的第三个，它将父组件注入到其 \n<code>parent</code> 参数中， 与你之前所做的一样：</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-class\" title=\"parent-finder.component.ts (CarolComponent class)\" linenums=\"false\">\nexport class CarolComponent {\n  name= 'Carol';\n  constructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent: Parent ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avstfvhy67x5opu3xglh90hm1\">以下是\n<em>Alex</em> 及其家人在行动中的样子：</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/alex.png\" alt=\"Alex in action\" width=\"302\" height=\"374\">\n</figure>\n<a id=\"parent-tree\"></a>\n<h3 id=\"find-the-parent-in-a-tree-of-parents-with-skipself\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7mu3abbjjwchtomncq361861m\"><i class=\"material-icons\">link</i>使用\n<em>@SkipSelf()</em> 在父级树中查找父级</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"37aajvfmbe7mtn2l2pk42p525\">想象一个组件层次结构的分支：\n<em>Alice</em> -&gt; \n<em>Barry</em> -&gt; \n<em>Carol</em>。 \n<em>Alice</em> 和 \n<em>Barry</em> 都实现了 \n<code>Parent</code> \n<em>类接口</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9kmsms079jl19sdfdi36yivq0\"><em>Barry</em> 是问题所在。他需要访问他的父级 \n<em>Alice</em>，并且也要成为 \n<em>Carol</em> 的父级。 这意味着他必须同时\n<em>注入</em> \n<code>Parent</code> \n<em>类接口</em>来获取 \n<em>Alice</em>，并且 \n<em>提供</em>一个 \n<code>Parent</code> 来满足 \n<em>Carol</em> 的需求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c74p0yd3hg3teku0ebcv27v7e\">这是 \n<em>Barry</em>：</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry\" title=\"parent-finder.component.ts (BarryComponent)\" linenums=\"false\">\nconst templateB = `\n  &lt;div class=\"b\"&gt;\n    &lt;div&gt;\n      &lt;h3&gt;{{name}}&lt;/h3&gt;\n      &lt;p&gt;My parent is {{parent?.name}}&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;carol&gt;&lt;/carol&gt;\n    &lt;chris&gt;&lt;/chris&gt;\n  &lt;/div&gt;`;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector:   'barry',\n  template:   templateB,\n  providers:  [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; BarryComponent) }]\n})\nexport class BarryComponent implements Parent {\n  name = 'Barry';\n  constructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent: Parent ) { }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wh79c6d382fbmt52ron8jmuf\"><em>Barry</em> 的 \n<code>providers</code> 数组看起来和 \n<a href=\"guide/dependency-injection-in-action#alex-providers\"><em>Alex</em> 的</a> 一样。 如果你要继续像这样编写 \n<a href=\"guide/dependency-injection-in-action#useexisting\"><em>别名提供者</em></a>，你应该创建一个 \n<a href=\"guide/dependency-injection-in-action#provideparent\">辅助函数</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2mjw2lfxotkktwsegcz3b1fh9\">现在，关注 \n<em>Barry</em> 的构造函数：</p>\n<code-tabs>\n\n  <code-pane title=\"Barry's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"barry-ctor\">\nconstructor( @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent: Parent ) { }\n\n</code-pane>\n\n  <code-pane title=\"Carol's constructor\" path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"carol-ctor\">\nconstructor( @<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() public parent: Parent ) { }\n\n</code-pane>\n\n</code-tabs>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0o4i19rvw71i659nebf9s67p\">它与 \n<em>Carol</em> 的构造函数相同，除了多了一个 \n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8lbebf7adf4opx02oywz2lhrj\"><code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 至关重要，原因有二：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"501tejx67suwje6g14z5bgl23\">它告诉注入器从 \n<em>自身</em> 上方的一个组件开始搜索 \n<code>Parent</code> 依赖项， 这正是父级的意思。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eifrek8n9464v2p9s22q0m4gd\">如果你省略了 \n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> 装饰器，Angular 会抛出一个循环依赖错误。</p>\n<p><code>Cannot instantiate cyclic dependency! (BethComponent -&gt; Parent -&gt; BethComponent)</code></p>\n</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xf3awd0ny5gg4ntogdx4e4pr\">以下是 \n<em>Alice</em>、\n<em>Barry</em> 及其家人在行动：</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection-in-action/alice.png\" alt=\"Alice in action\" width=\"298\" height=\"631\">\n</figure>\n<a id=\"parent-token\"></a>\n<h3 id=\"the-parent-class-interface\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"16orrq843nkal2zy6bueru269\"><i class=\"material-icons\">link</i><em>Parent</em> 类接口</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6h2a3r63ueosdotmhxw6uhwp\">你 \n<a href=\"guide/dependency-injection-in-action#class-interface\">之前学过</a>，\n<em>类接口</em> 是一个抽象类，用作接口而不是基类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eyli1hkfedotbhdvugmwewqrs\">此示例定义了一个 \n<code>Parent</code> \n<em>类接口</em>。</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"parent\" title=\"parent-finder.component.ts (Parent class-interface)\" linenums=\"false\">\nexport abstract class Parent { name: string; }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"77pg4redvxcs7q95l8c5tw1gw\"><code>Parent</code> \n<em>类接口</em> 定义了一个 \n<code>name</code> 属性，带有类型声明，但\n<em>没有实现</em>。 \n<code>name</code> 属性是子组件可以调用的父组件的唯一成员。 这样狭窄的接口有助于将子组件类与其父组件解耦。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xb7lqagvbw1gvk34820liiy8\">可以充当父级的组件\n<em>应该</em>实现\n<em>类接口</em>，就像 \n<code>AliceComponent</code> 一样：</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-class-signature\" title=\"parent-finder.component.ts (AliceComponent class signature)\" linenums=\"false\">\nexport class AliceComponent implements Parent\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6z9f3dul2dux5i1y8w4438214\">这样做可以使代码更清晰。但这在技术上并非必要。 虽然 \n<code>AlexComponent</code> 有一个 \n<code>name</code> 属性，这是其 \n<code>Base</code> 类所要求的， 但其类签名没有提到 \n<code>Parent</code>：</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-class-signature\" title=\"parent-finder.component.ts (AlexComponent class signature)\" linenums=\"false\">\nexport class AlexComponent extends Base\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9qssbpep3j9ivgb0blevy9jvp\"><code>AlexComponent</code> \n<em>应该</em>实现 \n<code>Parent</code>，作为一种良好的风格。 在本示例中，它没有这样做，\n<em>只是</em>为了演示代码可以在没有接口的情况下编译和运行。</p>\n</div>\n<a id=\"provideparent\"></a>\n<h3 id=\"a-provideparent-helper-function\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezp9tpuovgbc6jp6wa3ctum2u\"><i class=\"material-icons\">link</i>一个 \n<em>provideParent()</em> 辅助函数</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5kq6ddki4fkit185ibbvu8950\">编写相同父级\n<em>别名提供者</em>的变体很快就会变得很烦人， 尤其是这个带有 \n<a href=\"guide/dependency-injection-in-action#forwardref\"><em>forwardRef</em></a> 的可怕的冗长语句：</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" title=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" linenums=\"false\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; AlexComponent) }],\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dq03uv0tgqp7flb8f3zwke89u\">你可以将该逻辑提取到一个像这样的辅助函数中：</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"provide-the-parent\" title=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" linenums=\"false\">\n// Helper method to provide the current component instance in the name of <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> `parentType`.\nconst provideParent =\n  (component: any) =&gt; {\n    return { provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; component) };\n  };\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9fhyn5engbjdsv4c9s5t58u6m\">现在，你可以向你的组件添加一个更简单、更有意义的父级提供者：</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alice-providers\" title=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" linenums=\"false\">\nproviders:  [ provideParent(AliceComponent) ]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aenl2e5i0gnzx7t6y30liamqi\">你可以做得更好。当前版本的辅助函数只能为 \n<code>Parent</code> \n<em>类接口</em>创建别名。 应用程序可能有多种父级类型，每种类型都有自己的\n<em>类接口</em>令牌。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zfsu9kt15j8htfdv1rwjz1k3\">这是一个修改后的版本，它默认使用 \n<code>parent</code>，但也接受一个可选的第二个参数，用于不同的父级\n<em>类接口</em>。</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"provide-parent\" title=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" linenums=\"false\">\n// Helper method to provide the current component instance in the name of <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> `parentType`.\n// The `parentType` defaults to `Parent` when omitting the second parameter.\nconst provideParent =\n  (component: any, parentType?: any) =&gt; {\n    return { provide: parentType || Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; component) };\n  };\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dkndg2fc6edjf8pzlhersmesp\">以下是如何使用它与不同的父级类型：</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"beth-providers\" title=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" linenums=\"false\">\nproviders:  [ provideParent(BethComponent, DifferentParent) ]\n\n</code-example>\n<a id=\"forwardref\"></a>\n<h2 id=\"break-circularities-with-a-forward-class-reference-forwardref\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xhso3qqa7ku4ak1nrkqqea7w\"><i class=\"material-icons\">link</i>使用前向类引用（\n<em>forwardRef</em>）打破循环依赖</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2tfha6g3lpqznfc0smwvb3kpj\">在 TypeScript 里面，类声明的顺序是很重要的。如果一个类尚未定义，就不能引用它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5z7zn1uh3kt9mjd8mys1wytuv\">这通常不是问题，尤其是如果你遵循推荐的\n<em>每个文件一个类</em>规则。 但有时循环引用是不可避免的。 当类 'A' 引用类 'B'，而 'B' 又引用 'A' 时，你就会陷入困境。 其中一个必须先定义。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2njpnjls1tcqzlars90snuzsg\">Angular 的 \n<code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>()</code> 函数创建了一个\n<em>间接</em>引用，Angular 可以稍后解析它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azqzr09edad4dfx83pb1wb0u7\"><em>Parent Finder</em> 示例充满了无法打破的循环类引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5bbux2cpp4ej2lugf4wkk0fvt\">当一个类\n<em>自身引用自身</em>时，你就会面临这种困境， 就像 \n<code>AlexComponent</code> 在其 \n<code>providers</code> 数组中一样。 \n<code>providers</code> 数组是 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 装饰器函数的一个属性，它必须 出现在类定义\n<em>之上</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71mpmsszkmtozl8fgcrfkxwir\">使用 \n<code><a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a></code> 打破循环依赖：</p>\n<code-example path=\"dependency-injection-in-action/src/app/parent-finder.component.ts\" region=\"alex-providers\" title=\"parent-finder.component.ts (AlexComponent providers)\" linenums=\"false\">\nproviders: [{ provide: Parent, useExisting: <a href=\"api/core/forwardRef\" class=\"code-anchor\">forwardRef</a>(() =&gt; AlexComponent) }],\n\n</code-example>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/\n - api/common/HashLocationStrategy\n - api/common/LocationStrategy\n - api/common/NgForOf\n - api/common/NgIf\n - api/core/Component\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/ElementRef\n - api/core/Host\n - api/core/HostListener\n - api/core/Inject\n - api/core/Injectable\n - api/core/InjectionToken\n - api/core/Input\n - api/core/NgModule\n - api/core/OnInit\n - api/core/Optional\n - api/core/Query\n - api/core/QueryList\n - api/core/SkipSelf\n - api/core/ViewChildren\n - api/core/forwardRef\n - api/forms/DefaultValueAccessor\n - api/forms/NgModel\n - api/router/RouterLinkWithHref\n - guide/attribute-directives\n - guide/dependency-injection#register-providers-ngmodule\n - guide/dependency-injection-in-action#a-provideparent-helper-function\n - guide/dependency-injection-in-action#alex\n - guide/dependency-injection-in-action#alex-providers\n - guide/dependency-injection-in-action#application-wide-dependencies\n - guide/dependency-injection-in-action#break-circularities-with-a-forward-class-reference-forwardref\n - guide/dependency-injection-in-action#cannot-find-a-parent-by-its-base-class\n - guide/dependency-injection-in-action#class-interface\n - guide/dependency-injection-in-action#define-dependencies-with-providers\n - guide/dependency-injection-in-action#defining-providers\n - guide/dependency-injection-in-action#demonstration\n - guide/dependency-injection-in-action#dependency-injection\n - guide/dependency-injection-in-action#external-module-configuration\n - guide/dependency-injection-in-action#find-a-parent-by-its-class-interface\n - guide/dependency-injection-in-action#find-a-parent-component-by-injection\n - guide/dependency-injection-in-action#find-a-parent-component-of-known-type\n - guide/dependency-injection-in-action#find-the-parent-in-a-tree-of-parents-with-skipself\n - guide/dependency-injection-in-action#forwardref\n - guide/dependency-injection-in-action#hero-bios-component\n - guide/dependency-injection-in-action#inject-into-a-derived-class\n - guide/dependency-injection-in-action#inject-the-components-dom-element\n - guide/dependency-injection-in-action#injectable\n - guide/dependency-injection-in-action#injectable-and-nested-service-dependencies\n - guide/dependency-injection-in-action#injection-token\n - guide/dependency-injection-in-action#injectiontoken\n - guide/dependency-injection-in-action#known-parent\n - guide/dependency-injection-in-action#limit-service-scope-to-a-component-subtree\n - guide/dependency-injection-in-action#multiple-service-instances-sandboxing\n - guide/dependency-injection-in-action#optional\n - guide/dependency-injection-in-action#parent-token\n - guide/dependency-injection-in-action#provideparent\n - guide/dependency-injection-in-action#provider-token-alternatives-the-class-interface-and-injectiontoken\n - guide/dependency-injection-in-action#qualify-dependency-lookup-with-optional-and-host\n - guide/dependency-injection-in-action#take-a-break\n - guide/dependency-injection-in-action#the-parent-class-interface\n - guide/dependency-injection-in-action#the-provide-object-literal\n - guide/dependency-injection-in-action#tokens\n - guide/dependency-injection-in-action#useclass\n - guide/dependency-injection-in-action#useclassthe-class-provider\n - guide/dependency-injection-in-action#useexisting\n - guide/dependency-injection-in-action#useexistingthe-alias-provider\n - guide/dependency-injection-in-action#usefactorythe-factory-provider\n - guide/dependency-injection-in-action#usevaluethe-value-provider\n - guide/dependency-injection-in-action#why-minimallogger-is-a-class-and-not-a-typescript-interface\n - guide/router#location-strategy\n-->"
}