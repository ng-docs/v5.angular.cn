{
  "id" : "guide/observables",
  "title" : "可观察者",
  "contents" : "<div class=\"content\">\n<h1 id=\"observables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evhi82d4wuv9te5j343suvl9z\"><i class=\"material-icons\">link</i>可观察者</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f4c8am2i9qs68purh4wpavp21\">可观察者提供支持，用于在应用程序中发布者和订阅者之间传递消息。可观察者在事件处理、异步编程和处理多个值方面比其他技术具有显著优势。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"590vo37ayhxq2inbz7f92fqfz\">可观察者是声明式的——也就是说，你定义一个用于发布值的函数，但它只有在消费者订阅它时才会执行。已订阅的消费者会收到通知，直到函数完成，或者直到他们取消订阅。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1io9pf3u7uks083ww5u0pop9f\">可观察者可以传递任何类型的多个值——字面量、消息或事件，具体取决于上下文。接收值的 API 与值是同步还是异步传递相同。由于设置和拆卸逻辑都由可观察者处理，因此你的应用程序代码只需要关注订阅以使用值，并在完成后取消订阅。无论是按键、HTTP 响应还是间隔计时器，监听值和停止监听的接口都是相同的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"894pxzz2z0rgurx15ixuk7vh2\">由于这些优势，可观察者在 Angular 中被广泛使用，并且也推荐用于应用程序开发。</p>\n<h2 id=\"basic-usage-and-terms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drib7yu0iwcbvhn7sansue1ou\"><i class=\"material-icons\">link</i>基本用法和术语</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d435x413l4ciamf342bx253ma\">作为发布者，你创建了一个 \n<code>Observable</code> 实例，它定义了一个 \n<em>订阅者</em> 函数。这是在消费者调用 \n<code>subscribe()</code> 方法时执行的函数。订阅者函数定义了如何获取或生成要发布的值或消息。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1lvbsjotvxl140vhjh9irnzhy\">要执行你创建的可观察者并开始接收通知，你需要调用它的 \n<code>subscribe()</code> 方法，并传递一个 \n<em>观察者</em>。这是一个 JavaScript 对象，它定义了你接收的通知的处理程序。\n<code>subscribe()</code> 调用返回一个 \n<code>Subscription</code> 对象，它有一个 \n<code>unsubscribe()</code> 方法，你可以调用它来停止接收通知。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3iqe68tpr8aih5iq0zzfxkf57\">以下示例演示了基本用法模型，展示了如何使用可观察者来提供地理位置更新。</p>\n<code-example path=\"observables/src/geolocation.ts\" title=\"Observe geolocation updates\">\n\n// Create an Observable that will start listening to geolocation updates\n// when <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> consumer subscribes.\nconst locations = new Observable((observer) =&gt; {\n  // Get the next and error callbacks. These will be passed in when\n  // the consumer subscribes.\n  const {next, error} = observer;\n  let watchId;\n\n  // Simple geolocation API check provides values to publish\n  if ('geolocation' in navigator) {\n    watchId = navigator.geolocation.watchPosition(next, error);\n  } else {\n    error('Geolocation not available');\n  }\n\n  // When the consumer unsubscribes, clean up data ready for next subscription.\n  return {unsubscribe() { navigator.geolocation.clearWatch(watchId); }};\n});\n\n// Call subscribe() to start listening for updates.\nconst locationsSubscription = locations.subscribe({\n  next(position) { console.log('Current Position: ', position); },\n  error(msg) { console.log('Error Getting <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>: ', msg); }\n});\n\n// Stop listening for location after 10 seconds\nsetTimeout(() =&gt; { locationsSubscription.unsubscribe(); }, 10000);\n\n</code-example>\n<h2 id=\"defining-observers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5cie6dmexfyn5l77wgo51psc\"><i class=\"material-icons\">link</i>定义观察者</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dskbzsew0i6m6z6ysvnsdc64l\">接收可观察者通知的处理程序实现了 \n<code>Observer</code> 接口。它是一个对象，它定义了回调方法来处理可观察者可以发送的三种类型的通知：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9dw3f9054kvreov32y22g1o93\">通知类型</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"ar5q09mdsagdppsbze96eagxl\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>next</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31vos2cym399n6mgk4ciw6jg7\">必需。每个传递值的处理程序。在执行开始后调用零次或多次。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>error</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"182aqj2jaxfh74otouc6j8mhp\">可选。错误通知的处理程序。错误会停止可观察者实例的执行。</td>\n</tr>\n<tr>\n<td align=\"left\"><code>complete</code></td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"xgvppjkvx7v9i68i9l6daa3i\">可选。执行完成通知的处理程序。在执行完成后，延迟的值可以继续传递到下一个处理程序。</td>\n</tr>\n</tbody>\n</table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7mcr13dpf4djuyulgy4d19j7e\">观察者对象可以定义这些处理程序的任何组合。如果你没有为某个通知类型提供处理程序，观察者会忽略该类型的通知。</p>\n<h2 id=\"subscribing\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"abjukavuezeeqios1shy0zdmg\"><i class=\"material-icons\">link</i>订阅</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqmk7uxl9h6jcfljpwftsiagi\">只有当有人订阅 \n<code>Observable</code> 实例时，它才会开始发布值。你可以通过调用实例的 \n<code>subscribe()</code> 方法来订阅，并将观察者对象传递给它以接收通知。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arshq4wonnd6cfiz88tlb05h2\">为了展示订阅是如何工作的，我们需要创建一个新的可观察者。有一个构造函数可以用来创建新的实例，但为了说明，我们可以使用 \n<code>Observable</code> 类上的一些静态方法来创建一些常用的类型。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ude7ypc1qdius7rpk4gneuw7\"><code>Observable.of(...items)</code>—返回一个 \n<code>Observable</code> 实例，它会同步地传递作为参数提供的值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ldb4j0omlxagiq5b7ssi5qy8\"><code>Observable.from(iterable)</code>—将它的参数转换为 \n<code>Observable</code> 实例。此方法通常用于将数组转换为可观察者。</li>\n</ul>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"at0wvdgo694y5wa1bt7zjprhy\">以下是一个创建和订阅简单可观察者的示例，其中观察者将接收到的消息记录到控制台：</p>\n<code-example path=\"observables/src/subscribing.ts\" region=\"observer\" title=\"Subscribe using observer\">\n\n// Create simple observable that emits three values\nconst myObservable = Observable.of(1, 2, 3);\n\n// Create observer object\nconst myObserver = {\n  next: x =&gt; console.log('Observer got <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> next value: ' + x),\n  error: err =&gt; console.error('Observer got an error: ' + err),\n  complete: () =&gt; console.log('Observer got <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> complete notification'),\n};\n\n// Execute with the observer object\nmyObservable.subscribe(myObserver);\n// Logs:\n// Observer got <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> next value: 1\n// Observer got <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> next value: 2\n// Observer got <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> next value: 3\n// Observer got <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> complete notification\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9973w028z7bcelhfb63od3pel\">或者，\n<code>subscribe()</code> 方法可以在一行中接受回调函数定义，用于 \n<code>next</code>、\n<code>error</code> 和 \n<code>complete</code> 处理程序。例如，以下 \n<code>subscribe()</code> 调用与指定预定义观察者的调用相同：</p>\n<code-example path=\"observables/src/subscribing.ts\" region=\"sub_fn\" title=\"Subscribe with positional arguments\">\nmyObservable.subscribe(\n  x =&gt; console.log('Observer got <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> next value: ' + x),\n  err =&gt; console.error('Observer got an error: ' + err),\n  () =&gt; console.log('Observer got <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> complete notification')\n);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"abkcuzqxcgx2dmtauf6x448gw\">在任何情况下，都需要一个 \n<code>next</code> 处理程序。\n<code>error</code> 和 \n<code>complete</code> 处理程序是可选的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"43qhgyl1d152e49hinhwvylwg\">请注意，\n<code>next()</code> 函数可以接收例如消息字符串、事件对象、数值或结构，具体取决于上下文。作为一个通用术语，我们将可观察者发布的数据称为\n<em>流</em>。任何类型的值都可以用可观察者表示，这些值作为流发布。</p>\n<h2 id=\"creating-observables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vlw1a2xvtkucxf3ztvurtcc2\"><i class=\"material-icons\">link</i>创建可观察者</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bux5jz1c8zo59m73zrvyyi0nq\">使用 \n<code>Observable</code> 构造函数来创建任何类型的可观察者流。构造函数以订阅函数作为参数，该函数在可观察者的 \n<code>subscribe()</code> 方法执行时运行。订阅函数接收一个 \n<code>Observer</code> 对象，并且可以将值发布到观察者的 \n<code>next()</code> 方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1zkd6kyxlamis964uqg8r37mi\">例如，要创建一个等效于上面 \n<code>Observable.of(1, 2, 3)</code> 的可观察者，你可以执行以下操作：</p>\n<code-example path=\"observables/src/creating.ts\" region=\"subscriber\" title=\"Create observable with constructor\">\n\n// This function runs when subscribe() is called\nfunction sequenceSubscriber(observer) {\n  // synchronously deliver 1, 2, and 3, then complete\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n  observer.complete();\n\n  // unsubscribe function doesn't need to do anything in this\n  // because values are delivered synchronously\n  return {unsubscribe() {}};\n}\n\n// Create <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> new Observable that will deliver the above <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\nconst <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> = new Observable(sequenceSubscriber);\n\n// execute the Observable and print the result of each notification\nsequence.subscribe({\n  next(num) { console.log(num); },\n  complete() { console.log('Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>'); }\n});\n\n// Logs:\n// 1\n// 2\n// 3\n// Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cbq5d59oy23hxtwl4dccpxou0\">为了进一步说明这个例子，我们可以创建一个发布事件的可观察者。在这个例子中，订阅函数是在内联定义的。</p>\n<code-example path=\"observables/src/creating.ts\" region=\"fromevent\" title=\"Create with custom fromEvent function\">\n\nfunction fromEvent(target, eventName) {\n  return new Observable((observer) =&gt; {\n    const handler = (e) =&gt; observer.next(e);\n\n    // Add the event handler to the target\n    target.addEventListener(eventName, handler);\n\n    return () =&gt; {\n      // Detach the event handler from the target\n      target.removeEventListener(eventName, handler);\n    };\n  });\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"20xkdxecfq5oret20v0bhafc4\">现在，你可以使用此函数来创建一个发布键盘按下事件的可观察者：</p>\n<code-example path=\"observables/src/creating.ts\" region=\"fromevent_use\" title=\"Use custom fromEvent function\">\n\nconst ESC_KEY = 27;\nconst nameInput = document.getElementById('name') as HTMLInputElement;\n\nconst subscription = fromEvent(nameInput, 'keydown')\n  .subscribe((e: KeyboardEvent) =&gt; {\n    if (e.keyCode === ESC_KEY) {\n      nameInput.value = '';\n    }\n  });\n\n\n</code-example>\n<h2 id=\"multicasting\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75w6lif46mxdlj13k02e4kbzg\"><i class=\"material-icons\">link</i>多播</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gtbdn30ik1fzs9sed37wk5np\">一个典型的可观察者为每个订阅的观察者创建一个新的、独立的执行。当观察者订阅时，可观察者会连接一个事件处理程序并将值传递给该观察者。当第二个观察者订阅时，可观察者会连接一个新的事件处理程序并将值传递给第二个观察者，并在一个单独的执行中进行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2fwchitkpmp0pfcyhp1c3dvfc\">有时，你希望每个订阅都获得相同的值，而不是为每个订阅者启动一个独立的执行，即使值已经开始发出。对于像文档对象上的点击事件这样的可观察者来说，情况可能就是这样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"761cua71o8iaqr3sdnf078dxc\"><em>多播</em>是指将值广播到单个执行中的多个订阅者列表的做法。使用多播可观察者，你不会在文档上注册多个监听器，而是重用第一个监听器并将值发送到每个订阅者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cll43hqa1dic93pkwe5u9tzm4\">创建可观察者时，你应该确定你希望如何使用该可观察者，以及是否希望多播它的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5evyhi8s0ttu4siwx8t05bbzk\">让我们看一个从 1 到 3 计数的例子，每个数字发出后延迟一秒。</p>\n<code-example path=\"observables/src/multicasting.ts\" region=\"delay_sequence\" title=\"Create a delayed sequence\">\n\nfunction sequenceSubscriber(observer) {\n  const seq = [1, 2, 3];\n  let timeoutId;\n\n  // Will run through an array of numbers, emitting one value\n  // per second until it gets to the end of the array.\n  function doSequence(arr, idx) {\n    timeoutId = setTimeout(() =&gt; {\n      observer.next(arr[idx]);\n      if (idx === arr.length - 1) {\n        observer.complete();\n      } else {\n        doSequence(arr, idx++);\n      }\n    }, 1000);\n  }\n\n  doSequence(seq, 0);\n\n  // Unsubscribe should clear the timeout to stop execution\n  return {unsubscribe() {\n    clearTimeout(timeoutId);\n  }};\n}\n\n// Create <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> new Observable that will deliver the above <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\nconst <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> = new Observable(sequenceSubscriber);\n\nsequence.subscribe({\n  next(num) { console.log(num); },\n  complete() { console.log('Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>'); }\n});\n\n// Logs:\n// (at 1 second): 1\n// (at 2 seconds): 2\n// (at 3 seconds): 3\n// (at 3 seconds): Finished <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c6cdb9fnz6xsmjr6a8moo74gp\">请注意，如果你订阅两次，将会有两个独立的流，每个流每秒发出一次值。它看起来像这样：</p>\n<code-example path=\"observables/src/multicasting.ts\" region=\"subscribe_twice\" title=\"Two subscriptions\">\n\n// Subscribe starts the clock, and will emit after 1 second\nsequence.subscribe({\n  next(num) { console.log('1st subscribe: ' + num); },\n  complete() { console.log('1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n});\n\n// After 1/2 second, subscribe again.\nsetTimeout(() =&gt; {\n  sequence.subscribe({\n    next(num) { console.log('2nd subscribe: ' + num); },\n    complete() { console.log('2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n  });\n}, 500);\n\n// Logs:\n// (at 1 second): 1st subscribe: 1\n// (at 1.5 seconds): 2nd subscribe: 1\n// (at 2 seconds): 1st subscribe: 2\n// (at 2.5 seconds): 2nd subscribe: 2\n// (at 3 seconds): 1st subscribe: 3\n// (at 3 seconds): 1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n// (at 3.5 seconds): 2nd subscribe: 3\n// (at 3.5 seconds): 2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9i0hhi68doa5509loul2e73vc\">将可观察者更改为多播可能看起来像这样：</p>\n<code-example path=\"observables/src/multicasting.ts\" region=\"multicast_sequence\" title=\"Create a multicast subscriber\">\n\nfunction multicastSequenceSubscriber() {\n  const seq = [1, 2, 3];\n  // Keep track of each observer (one for every active subscription)\n  const observers = [];\n  // Still <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> single timeoutId because there will only ever be one\n  // set of values being generated, multicasted to each subscriber\n  let timeoutId;\n\n  // Return the subscriber function (runs when subscribe()\n  // function is invoked)\n  return (observer) =&gt; {\n    observers.push(observer);\n    // When this is the first subscription, start the <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\n    if (observers.length === 1) {\n      timeoutId = doSequence({\n        next(val) {\n          // Iterate through observers and notify all subscriptions\n          observers.forEach(obs =&gt; obs.next(val));\n        },\n        complete() {\n          // Notify all complete callbacks\n          observers.forEach(obs =&gt; obs.complete());\n        }\n      }, seq, 0);\n    }\n\n    return {\n      unsubscribe() {\n        // Remove from the observers array so it's no longer notified\n        observers.splice(observers.indexOf(observer), 1);\n        // If there's no more listeners, do cleanup\n        if (observers.length === 0) {\n          clearTimeout(timeoutId);\n        }\n      }\n    };\n  };\n}\n\n// Run through an array of numbers, emitting one value\n// per second until it gets to the end of the array.\nfunction doSequence(observer, arr, idx) {\n  return setTimeout(() =&gt; {\n    observer.next(arr[idx]);\n    if (idx === arr.length - 1) {\n      observer.complete();\n    } else {\n      doSequence(observer, arr, idx++);\n    }\n  }, 1000);\n}\n\n// Create <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> new Observable that will deliver the above <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a>\nconst multicastSequence = new Observable(multicastSequenceSubscriber);\n\n// Subscribe starts the clock, and begins to emit after 1 second\nmulticastSequence.subscribe({\n  next(num) { console.log('1st subscribe: ' + num); },\n  complete() { console.log('1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n});\n\n// After 1 1/2 seconds, subscribe again (should \"miss\" the first value).\nsetTimeout(() =&gt; {\n  multicastSequence.subscribe({\n    next(num) { console.log('2nd subscribe: ' + num); },\n    complete() { console.log('2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished.'); }\n  });\n}, 1500);\n\n// Logs:\n// (at 1 second): 1st subscribe: 1\n// (at 2 seconds): 1st subscribe: 2\n// (at 2 seconds): 2nd subscribe: 2\n// (at 3 seconds): 1st subscribe: 3\n// (at 3 seconds): 1st <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n// (at 3 seconds): 2nd subscribe: 3\n// (at 3 seconds): 2nd <a href=\"api/animations/sequence\" class=\"code-anchor\">sequence</a> finished\n\n\n</code-example>\n<div class=\"l-sub-section\">\n   Multicasting observables take a bit more setup, but they can be useful for certain applications. Later we will look at tools that simplify the process of multicasting, allowing you to take any observable and make it multicasting.\n</div>\n<h2 id=\"error-handling\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad0cx4y7txhii62pgdd0mpma9\"><i class=\"material-icons\">link</i>错误处理</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aftcovmvfqu4p80mr80srj2x6\">因为可观察者异步地生成值，所以 try/catch 无法有效地捕获错误。相反，你可以通过在观察者上指定一个 \n<code>error</code> 回调来处理错误。生成错误也会导致可观察者清理订阅并停止生成值。可观察者可以生成值（调用 \n<code>next</code> 回调），也可以完成，调用 \n<code>complete</code> 或 \n<code>error</code> 回调。</p>\n<code-example>\nmyObservable.subscribe({\n  next(num) { console.log('Next num: ' + num)},\n  error(err) { console.log('Received an errror: ' + err)}\n});\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4m1mr9zjlb0l3lo0ma2yvhylb\">错误处理（特别是从错误中恢复）将在后面的部分中详细介绍。</p>\n\n</div>\n<!-- links to this doc:\n - guide/architecture-next-steps\n-->\n<!-- links from this doc:\n - api/animations/sequence\n - api/common/Location\n - api/router/RouterLinkWithHref\n - guide/observables#basic-usage-and-terms\n - guide/observables#creating-observables\n - guide/observables#defining-observers\n - guide/observables#error-handling\n - guide/observables#multicasting\n - guide/observables#observables\n - guide/observables#subscribing\n-->"
}