{
  "id" : "guide/practical-observable-usage",
  "title" : "可观察者的实际用法",
  "contents" : "<div class=\"content\">\n<h1 id=\"practical-observable-usage\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2silmdi5l71sawwh9etadkl2\"><i class=\"material-icons\">link</i>可观察者的实际用法</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d3npxtnjyuedhtxcjoggqdrk8\">以下是一些可观察者特别有用的领域示例。</p>\n<h2 id=\"type-ahead-suggestions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8upcc3m8iuhgxrgxylyx9wdgd\"><i class=\"material-icons\">link</i>自动完成建议</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccznygxfq890o5qkqjmjk9sbr\">可观察者可以简化自动完成建议的实现。通常，自动完成需要执行一系列单独的任务：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dv7jcl7iz25ggctn3xwurnh8\">监听来自输入的数据。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9v3b3emq27e45g2f3do20qj64\">修剪值（删除空格）并确保其长度至少为最小长度。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cz6zuwq730tag4qhjiz1awvsj\">去抖动（这样就不会为每次按键都发送 API 请求，而是等待按键停止）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2uvb4h6wmuhfzkcjp7egbiyvf\">如果值保持不变，则不要发送请求（例如，快速按下某个字符，然后按退格键）。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"vfpnix88im694scsdhyavifl\">如果正在进行的 AJAX 请求的结果将被更新的结果使无效，则取消它们。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bcr0ygm6p32qugac15k4b47kf\">用完整的 JavaScript 编写这部分代码可能相当复杂。使用可观察者，你可以使用一系列简单的 RxJS 操作符：</p>\n<code-example path=\"practical-observable-usage/src/typeahead.ts\" title=\"Typeahead\">\n\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { ajax } from 'rxjs/observable/dom/ajax';\nimport { map, filter, debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';\n\nconst searchBox = document.getElementById('search-box');\n\nconst typeahead = fromEvent(searchBox, 'input').pipe(\n  map((e: KeyboardEvent) =&gt; e.target.value),\n  filter(text =&gt; text.length &gt; 2),\n  debounceTime(10),\n  distinctUntilChanged(),\n  switchMap(() =&gt; ajax('/api/endpoint'))\n);\n\ntypeahead.subscribe(data =&gt; {\n // Handle the data from the API\n});\n\n\n</code-example>\n<h2 id=\"exponential-backoff\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wj3l6ztvx6hti78o035l3xzn\"><i class=\"material-icons\">link</i>指数退避</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8rpqzj5eg49pid9aqsbw4odvx\">指数退避是一种技术，它在 API 失败后重试，并在每次连续失败后延长重试之间的时间，并设置最大重试次数，超过该次数后，请求将被视为失败。使用 Promise 和其他跟踪 AJAX 调用的方法来实现这一点可能非常复杂。使用可观察者，这非常容易：</p>\n<code-example path=\"practical-observable-usage/src/backoff.ts\" title=\"Exponential backoff\">\n\nimport { ajax } from 'rxjs/observable/dom/ajax';\nimport { range } from 'rxjs/observable/range';\nimport { timer } from 'rxjs/observable/timer';\nimport { pipe } from 'rxjs/util/pipe';\nimport { retryWhen, zip, map, mergeMap } from 'rxjs/operators';\n\nfunction backoff(maxTries, ms) {\n return pipe(\n   retryWhen(attempts =&gt; range(1, maxTries)\n     .pipe(\n       zip(attempts, (i) =&gt; i),\n       map(i =&gt; i * i),\n       mergeMap(i =&gt;  timer(i * ms))\n     )\n   )\n );\n}\n\najax('/api/endpoint')\n  .pipe(backoff(3, 250))\n  .subscribe(data =&gt; handleData(data));\n\nfunction handleData(data) {\n  // ...\n}\n\n\n</code-example>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - guide/practical-observable-usage#exponential-backoff\n - guide/practical-observable-usage#practical-observable-usage\n - guide/practical-observable-usage#type-ahead-suggestions\n-->"
}