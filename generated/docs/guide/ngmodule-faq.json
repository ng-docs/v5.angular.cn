{
  "id" : "guide/ngmodule-faq",
  "title" : "NgModule 常见问题解答",
  "contents" : "<div class=\"content\">\n<h1 id=\"ngmodule-faqs\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"13pma4hsdclaiwq8qicesglhl\"><i class=\"material-icons\">link</i>NgModule 常见问题解答</h1>\n<h4 id=\"prerequisites\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cvushkv2hv9s5ejwrr6i4rhvb\"><i class=\"material-icons\">link</i>先决条件：</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wtw65w7vo9ysndhyuq3y2kie\">对以下概念的基本理解：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ep3irm3ivsn2o0g2mgwnl8umg\"><a href=\"guide/ngmodules\">NgModules</a>。</li>\n</ul>\n<hr>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"c3fb4uldhk51bkfbsjmx0k7i3\">NgModules 可以帮你把应用组织成一些紧密相关的代码块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bpz9taadi172xl2aexxrzkez7\">这里回答的是开发者常问起的关于 NgModule 的设计与实现问题。</p>\n<h2 id=\"what-classes-should-i-add-to-the-declarations-array\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"q3exsvks9iv8rvncl5dvzziu\"><i class=\"material-icons\">link</i>我应该将哪些类添加到 \n<code>declarations</code> 数组中？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3td0pfzaxbut55kvj171856ji\">将 \n<a href=\"guide/bootstrapping#the-declarations-array\">可声明</a> 类（组件、指令和管道）添加到 \n<code>declarations</code> 列表中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"30ki5zqz2ulo664hv21dftwh1\">在应用程序的\n<em>一个</em>模块中声明这些类。 如果这些类属于特定模块，则在该模块中声明它们。</p>\n<hr>\n<a id=\"q-declarable\"></a>\n<h2 id=\"what-is-a-declarable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bh187g8wf34zqe31qhfks166z\"><i class=\"material-icons\">link</i>什么是\n<em>可声明</em>？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsbtsnqjbsape2esks39em0ud\">可声明是你可以添加到模块的 \n<code>declarations</code> 列表中的类类型（组件、指令和管道）。 它们是你可以添加到 \n<code>declarations</code> 中的唯一类。</p>\n<hr>\n<h2 id=\"what-classes-should-i-not-add-to-declarations\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bkd6ebj6zb278gvy10l33lixo\"><i class=\"material-icons\">link</i>哪些类<em>不</em>应该加到 <code>declarations</code> 中？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59fafrfr83zk6sh1frmqytzw7\">仅将 \n<a href=\"guide/bootstrapping#the-declarations-array\">可声明</a> 类添加到 NgModule 的 \n<code>declarations</code> 列表中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"63amf8hgfrdmdrd68iidaeb73\"><em>不要</em>声明：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlcw40oeq41ssubl0uawmagkb\">已在另一个模块中声明的类，无论是应用模块、@NgModule 还是第三方模块。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a77343rm80phnkzt2omuqbc5c\">从另一个模块导入的指令数组。 例如，不要从 \n<code>@angular/forms</code> 中声明 \n<code>FORMS_DIRECTIVES</code>，因为 \n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> 已经声明了它。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"brfx5icvv7x0vcrnc84tj3894\">模块类。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"815a6dnctobiecpg9y3gn94qm\">服务类。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3a9d13tnxmuxmajxg2vbkkj6u\">非 Angular 类和对象，例如 字符串、数字、函数、实体模型、配置、业务逻辑和辅助类。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"why-list-the-same-component-in-multiple-ngmodule-properties\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e258t08fosjs2omgnlf1peiiu\"><i class=\"material-icons\">link</i>为什么在多个 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 属性中列出同一个组件？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4u06njr4inc0qm5zsrp9xvjn0\"><code>AppComponent</code> 通常同时列在 \n<code>declarations</code> 和 \n<code>bootstrap</code> 中。 你可能会看到同一个组件列在 \n<code>declarations</code>、\n<code>exports</code> 和 \n<code>entryComponents</code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"a2qtmkkv0qj39pj98de9j3fm4\">这看起来是多余的，不过这些函数具有不同的功能，从它出现在一个列表中无法推断出它也应该在另一个列表中。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2l66ya0wfi29pai0v2sjikapu\"><code>AppComponent</code> 可能被声明在此模块中，但可能不是引导组件。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"9aqaups5ut0rpbybn7cq5e45q\"><code>AppComponent</code> 可能在此模块中引导，但可能是由另一个特性模块声明的。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aikwtfcjjamle0chdsz0y5vd\">组件可以从另一个应用模块导入（因此你无法声明它），并由此模块重新导出。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3222pikrmzs2pcbzvar2ljh7\">组件可以导出以包含在外部组件的模板中，以及动态加载到弹出对话框中。</li>\n</ul>\n<hr>\n<h2 id=\"what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3744wq1oauhi35rq6rb52a0x7\"><i class=\"material-icons\">link</i>\"无法绑定到 'x'，因为它不是 'y' 的已知属性\" 是什么意思？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3wn7zdpt9foicriwdpomzla1\">此错误通常意味着你没有声明指令 \"x\" 或者没有导入 \"x\" 所属的 NgModule。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7kydcpv8fga40iivoi810i2mc\">也许你在应用程序子模块中声明了 \"x\"，但忘记导出它。 在将 \"x\" 类添加到 \n<code>exports</code> 列表之前，它对其他模块不可见。</p>\n</div>\n<hr>\n<h2 id=\"what-should-i-import\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1e16cjhli11tzjn0u1x9xyhhi\"><i class=\"material-icons\">link</i>我应该导入什么？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eq7j83durh6vopuobe8k93cs\">导入此模块的组件模板中需要引用的公共（导出）\n<a href=\"guide/bootstrapping#the-declarations-array\">可声明类</a> 的 NgModules。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"58e4cbzym6mw03026ko9hei94\">这始终意味着从 \n<code>@angular/common</code> 中导入 \n<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 以访问 Angular 指令，例如 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 和 \n<code>NgFor</code>。 你可以直接导入它，也可以从 \n<a href=\"guide/ngmodule-faq#q-reexport\">重新导出</a> 它的另一个 NgModule 中导入它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"copy5teeio8zcs9w718ghm8b4\">如果你的组件具有 \n<code>[(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]</code> 双向绑定表达式，则从 \n<code>@angular/forms</code> 中导入 \n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ceebb96jrxxkiasa7cnbrr1mm\">当此模块的组件包含它们的组件、指令和管道时，导入\n<em>共享</em>和\n<em>特性</em>模块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3r1iq0y2ssl1s5i0kjnzyualv\">仅在根 \n<code>AppModule</code> 中导入 \n<a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">BrowserModule</a>。</p>\n<hr>\n<a id=\"q-browser-vs-common-module\"></a>\n<h2 id=\"should-i-import-browsermodule-or-commonmodule\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9u837wz2r2h61p7540rbtm3rn\"><i class=\"material-icons\">link</i>我应该导入 \n<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 还是 \n<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c304qgsobsod1009y70z5c3k8\">几乎所有浏览器应用程序的根应用程序模块 \n<code>AppModule</code> 都应该从 \n<code>@angular/platform-browser</code> 中导入 \n<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2d6mmx1u351eyl1p13kflvr1e\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 提供了启动和运行浏览器应用所必需的服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4z83uhfz9cokfyf1hqolnahlp\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 还从 \n<code>@angular/common</code> 中重新导出了 \n<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>， 这意味着 \n<code>AppModule</code> 模块中的组件也可以访问每个应用都需要的一些 Angular 指令，例如 \n<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> 和 \n<code>NgFor</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4r562dr9wspeai5n6m5wcwje\">不要在任何其他模块中导入 \n<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>。 \n<em>特性模块</em> 和 \n<em>惰性加载模块</em> 应该改为导入 \n<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>。 它们需要这些通用指令，但不需要重新安装应用范围内的提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cqh2r3z2xqvyaohvimryk96yc\">导入 \n<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> 也使特性模块能够在\n<em>任何</em>目标平台上使用，而不仅仅是浏览器。</p>\n<hr>\n<a id=\"q-reimport\"></a>\n<h2 id=\"what-if-i-import-the-same-module-twice\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gbzvrwrfearxbjg9hhfpmh4z\"><i class=\"material-icons\">link</i>如果我两次导入同一个模块会怎样？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3v0n2ndzgcp02oa6iwqcxlsv\">这没问题。当三个模块都导入模块 'A' 时， Angular 会在第一次遇到它时评估一次模块 'A'，并且不会再评估它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1m5ria53ouubkxhh0qeebwtpz\">这在 'A' 在导入的 NgModule 层次结构中出现的任何级别都是正确的。 当模块 'B' 导入模块 'A'，模块 'C' 导入 'B'，模块 'D' 导入 \n<code>[C, B, A]</code> 时， 那么 'D' 会触发 'C' 的评估，'C' 会触发 'B' 的评估，'B' 会评估 'A'。 当 Angular 遇到 'D' 中的 'B' 和 'A' 时，它们已经被缓存并准备好了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5mm3pwwsfrj6t98qtwalq4f2l\">Angular 不允许模块之间出现循环依赖，所以不要让模块'A'导入模块'B'，而模块'B'又导入模块'A'。</p>\n<hr>\n<a id=\"q-reexport\"></a>\n<h2 id=\"what-should-i-export\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jys2rejbf25ncvnrwfes33uc\"><i class=\"material-icons\">link</i>我应该导出什么？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"efhm25n8ad8wvklcxtkevazjw\">导出\n<em>其他</em> NgModule 中的组件能够在其模板中引用的 \n<a href=\"guide/bootstrapping#the-declarations-array\">可声明</a> 类。这些是你的\n<em>公共</em>类。 如果你没有导出可声明类，它将保持\n<em>私有</em>，仅对在此 NgModule 中声明的其他组件可见。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85j4y7n2cdxr6yvjzrymlu6zm\">你可以导出任何可声明类——组件、指令和管道——无论它是在此 NgModule 中声明还是在导入的 NgModule 中声明。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5a07qj4wphz57vdfnva2otxs9\">你可以重新导出整个导入的 NgModule，这实际上会重新导出它们所有导出的类。 NgModule 甚至可以导出它没有导入的模块。</p>\n<hr>\n<h2 id=\"what-should-i-not-export\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7sxaz5f9dtv35g7up445xlkli\"><i class=\"material-icons\">link</i>我<em>不应该</em>导出什么？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5fe4zsjquz632od2zibqr0e3t\">不要导出以下内容：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8c9xy28n81an9d1vb6xcqnbas\">仅在此 NgModule 中声明的组件中需要的私有组件、指令和管道。 如果你不希望另一个 NgModule 看到它，就不要导出它。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7wxrw7z34kkrfqd1h7fbh7ips\">不可声明的对象，比如服务、函数、配置、实体模型等。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d664d4wzz4gtoy90go42tk9t5\">仅由路由器或引导动态加载的组件。 此类 \n<a href=\"guide/ngmodule-faq#q-entry-component-defined\">入口组件</a> 永远无法在另一个组件的模板中被选中。 虽然导出它们没有坏处，但也毫无益处。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4dcln2h1b02u89ispfbmhd2ar\">没有公共（导出）声明的纯服务模块。 例如，重新导出 \n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 毫无意义，因为它没有导出任何内容。 它的唯一目的是将 http 服务提供者添加到整个应用程序中。</li>\n</ul>\n<hr>\n<h2 id=\"can-i-re-export-classes-and-modules\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"buiwj8cw8viupvbm6sikuvsyw\"><i class=\"material-icons\">link</i>我可以重新导出类和模块吗？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7vo4eotcdt1sxkawzhaqaei0e\">毫无疑问。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9x55t0332b278wduppqjpb2hr\">NgModule 是一个很好的方法，可以从其他 NgModule 中选择性地聚合类，并在一个合并的便利模块中重新导出它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dnbwzssgx8hkq5vilxyls2u8f\">NgModule 可以重新导出整个 NgModule，这实际上会重新导出它们所有导出的类。 Angular 自身的 \n<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> 就像这样导出了一些 NgModule：</p>\n<code-example language=\"typescript\">\n  exports: [<a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/core/ApplicationModule\" class=\"code-anchor\">ApplicationModule</a>]\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"w71fvfssmm57p2ifbvw5goqg\">模块还能导出一个组合，它可以包含自己的声明、某些导入的类以及导入的模块。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eiv2oh9va5baui6qr4ede5nyn\">不要费心重新导出纯服务模块。 纯服务模块不导出另一个 NgModule 可以使用的 \n<a href=\"guide/bootstrapping#the-declarations-array\">可声明</a> 类。 例如，重新导出 \n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 毫无意义，因为它没有导出任何内容。 它的唯一目的是将 http 服务提供者添加到整个应用程序中。</p>\n<hr>\n<h2 id=\"what-is-the-forroot-method\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7ailka1s0q96em45kmvkguv3e\"><i class=\"material-icons\">link</i><code>forRoot()</code> 方法是什么？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7o6ule959ik0dmsdksjamq5v7\"><code>forRoot()</code> 静态方法是一种约定，它使开发人员能够轻松地配置模块的提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cs9iymt9wj8jnmiyylxki92w2\"><code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 方法就是一个很好的例子。 应用将 \n<code><a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a></code> 对象传递给 \n<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code>，以便使用路由配置应用范围内的 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code> 服务。 \n<code><a href=\"api/router/RouterModule#forRoot\" class=\"code-anchor\">RouterModule.forRoot()</a></code> 返回一个 \n<a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>。 你将该结果添加到根 \n<code>AppModule</code> 的 \n<code>imports</code> 列表中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2l7bk2ez1hos6n5s2vkmbjneu\">仅在根应用程序模块 \n<code>AppModule</code> 中调用和导入 \n<code>.forRoot()</code> 结果。 在任何其他模块中导入它，特别是在惰性加载模块中， 与意图相悖，并且很可能会产生运行时错误。 有关更多信息，请参阅 \n<a href=\"guide/singleton-services\">单例服务</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21wxsgffx3hy2beo9rol9bcnz\"><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> 还提供了一个 \n<code>forChild</code> 静态方法，用于配置惰性加载模块的路由。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1x7t8oty71qwockoiwnckwpwq\"><code>forRoot()</code> 和 \n<code>forChild()</code> 是分别用于配置根模块和特性模块中服务的传统名称。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e32q1tt4arvn808ki1snnjfrp\">Angular 不识别这些名称，但 Angular 开发人员会识别。 当你编写具有可配置服务提供者的类似模块时，请遵循此约定。</p>\n<!--KW--I don't understand how Angular doesn't understand these methods...-->\n<hr>\n<h2 id=\"why-is-a-service-provided-in-a-feature-module-visible-everywhere\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"7x8i2uhhe6yzusbcg6lodoqyp\"><i class=\"material-icons\">link</i>为什么在特性模块中提供的服务在整个应用中都可见？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9j8pz2fdd48x2sy9c5h8mpcdx\">在引导模块的 \n<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 中列出的提供者具有应用程序范围。 将服务提供者添加到 \n<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 实际上是将服务发布到整个应用程序。</p>\n<p>When you import an NgModule,\nAngular adds the module's service providers (the contents of its <code>providers</code> list)\nto the application root injector.</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"44msbop7abbre53g5ma079iji\">这使得提供者对应用程序中所有知道提供者查找令牌或知道其名称的类可见。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"824rv5xzu9mx05457xcfkrdk7\">这是设计使然。 通过 NgModule 导入进行扩展是 NgModule 系统的主要目标。 将 NgModule 提供者合并到应用程序注入器中 使模块库能够轻松地为整个应用程序提供新的服务。 通过添加 \n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code> 一次，每个应用程序组件都可以发出 HTTP 请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b87njdc15v9gt1d9w7v83xnpu\">但是，如果你期望模块的服务 仅对该特性模块声明的组件可见，这可能会让你感到意外。 如果 \n<code>HeroModule</code> 提供 \n<code>HeroService</code>，而根 \n<code>AppModule</code> 导入 \n<code>HeroModule</code>， 那么任何知道 \n<code>HeroService</code> \n<em>类型</em> 的类都可以注入该服务， 而不仅仅是 \n<code>HeroModule</code> 中声明的类。</p>\n<hr>\n<a id=\"q-lazy-loaded-module-provider-visibility\"></a>\n<h2 id=\"why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8d6u7kura4lfe84h3e8wvalgh\"><i class=\"material-icons\">link</i>为什么在惰性加载模块中声明的服务提供者只对该模块自身可见？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dkxtj8l4zq126fhg921kjbbmn\">与启动时加载的模块的提供者不同， 惰性加载模块的提供者是\n<em>模块范围</em>的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46wsvuq3wpih4qtpqequ3qvff\">当 Angular 路由器惰性加载模块时，它会创建一个新的执行上下文。 该 \n<a href=\"guide/ngmodule-faq#q-why-child-injector\" title=\"Why Angular creates a child injector\">上下文有自己的注入器</a>， 它是应用程序注入器的直接子级。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7735i5x7id0zxyds8327bmcg2\">路由器将惰性模块的提供者及其导入的 NgModule 的提供者添加到此子注入器中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2fbequmn1q9d2dv9qzrdgomtc\">这些提供者不会被拥有相同令牌的应用级别提供者的变化所影响。当路由器在惰性加载环境中创建组件时，Angular 优先使用惰性加载模块中的服务实例，而不是来自应用的根注入器的。</p>\n<hr>\n<h2 id=\"what-if-two-modules-provide-the-same-service\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do3ssf799zgpo4nmoqfnoh0f5\"><i class=\"material-icons\">link</i>如果两个模块提供相同的服务会怎样？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1uzafgquxf179os3mxgdp7eas\">当两个导入的模块在同一时间加载时，列出了具有相同令牌的提供者， 第二个模块的提供者“获胜”。这是因为两个提供者都添加到同一个注入器中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c85bmrvue8zc0nskqgna0rtcw\">当 Angular 查找要为该令牌注入服务时， 它会创建并传递由第二个提供者创建的实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"q5hkkpdc0jgsg35m4cdz25e8\"><em>每个</em>注入了该服务的类获得的都是由第二个提供者创建的实例。即使是声明在第一个模块中的类，它取得的实例也是来自第二个提供者的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bitqwz4ic2gq3gkn7g3ngsmnt\">如果 NgModule A 为令牌 'X' 提供服务，并导入也为令牌 'X' 提供服务的 NgModule B，那么 NgModule A 的服务定义“获胜”。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bqb4dpedl8odmjtnooi0ng3px\">由根 <code>AppModule</code> 提供的服务相对于所导入模块中提供的服务有优先权。换句话说：<code>AppModule</code> 总会获胜。</p>\n<hr>\n<h2 id=\"how-do-i-restrict-service-scope-to-a-module\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"1q7w15pbcu1wpn79wahdcx4sz\"><i class=\"material-icons\">link</i>我应该如何把服务的范围限制到模块中？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8t8qi9u5l7w1kqv02o0m86g92\">当模块在应用程序启动时加载时， 其 \n<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 具有\n<em>应用程序范围</em>； 也就是说，它们可以在整个应用程序中用于注入。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6jnzjy78dk2hw6itq0r2ub8z\">导入的提供者很容易被来自另一个导入的 NgModule 的提供者替换。 这种替换可能是设计使然。它也可能是无意的，并会产生不利后果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"crtszw6qizuo5wxln4enl6xe2\">作为一个通用的规则，应该<em>只导入一次</em>带提供者的模块，最好在应用的<em>根模块</em>中。那里也是配置、包装和重写这些服务的最佳位置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4jcs5shygx4cw5fgoct1e6j6u\">假设一个模块需要一个自定义的 \n<code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>，它为所有 Http 请求添加一个特殊标头。 如果应用程序中其他地方的另一个模块也自定义了 \n<code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 或仅仅导入 \n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>，它可能会覆盖此模块的 \n<code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 提供者， 从而丢失特殊标头。服务器将拒绝来自此模块的 http 请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5wbjf8jkxrrny7acm6ohn3ddu\">为了避免此问题，仅在 \n<code>AppModule</code>（应用程序\n<em>根模块</em>）中导入 \n<code><a href=\"api/common/http/HttpClientModule\" class=\"code-anchor\">HttpClientModule</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4kjl7131n67dx2jd1wqr22af8\">如果你必须防止这种“提供者损坏”，\n<em>不要依赖启动时模块的 <code>providers</code>。</em></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6oz1zvjsd3fkpgqlmk0h0aprz\">如果可以，请惰性加载模块。 Angular 会为 \n<a href=\"guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\">惰性加载模块</a> 提供自己的子注入器。 模块的提供者仅在使用此注入器创建的组件树中可见。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7qy1y0izu5cku0s9up294ibox\">如果你必须在应用程序启动时急切地加载模块， \n<em>请在组件中提供服务。</em></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2zb1670gnz01xvq7yr9c4koyy\">继续使用相同的示例，假设模块的组件确实需要一个私有的自定义 \n<code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9i9q0ppowmbosdixxcqdgqhg\">创建一个充当模块所有组件的根的“顶层组件”。 将自定义 \n<code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 提供者添加到顶层组件的 \n<code>providers</code> 列表中，而不是模块的 \n<code>providers</code>。 请记住，Angular 为每个组件实例创建一个子注入器，并使用组件自己的提供者填充注入器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6kjgbzxsqzg7si7bs2mpio7hl\">当此组件的子级请求 \n<code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服务时， Angular 会提供本地 \n<code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 服务， 而不是在应用程序根注入器中提供的版本。 无论其他模块对 \n<code><a href=\"api/common/http/HttpBackend\" class=\"code-anchor\">HttpBackend</a></code> 做了什么，子组件都会发出正确的 HTTP 请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bozk0lufm5wpgnidkfaboqbl\">确保将模块组件创建为此模块的顶层组件的子级。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2er7pns4j00jhvo13y002vpg6\">你可以在顶层组件的模板中嵌入子组件。 或者，通过为其提供 \n<code>&lt;<a href=\"api/router/RouterOutlet\" class=\"code-anchor\">router-outlet</a>&gt;</code>，使顶层组件成为路由主机。 定义子路由，并让路由器将模块组件加载到该出口中。</p>\n<hr>\n<a id=\"q-root-component-or-module\"></a>\n<h2 id=\"should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"8j8fqi96eaqi6tvyjfar89e1\"><i class=\"material-icons\">link</i>我应该把全应用级提供者添加到根模块 <code>AppModule</code> 中还是根组件 <code>AppComponent</code> 中？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"54wt9l0e5yeaovqgdrtibf9wu\">在根 \n<code>AppModule</code> 中注册应用程序范围内的提供者，而不是在 \n<code>AppComponent</code> 中注册。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4svm3jo05vaj9gkgej998oz7z\">惰性加载的模块及其组件可以注入 \n<code>AppModule</code> 服务； 它们不能注入 \n<code>AppComponent</code> 服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4e33xiybnjfa2474y0q4cuz19\">仅当服务必须对 \n<code>AppComponent</code> 树之外的组件隐藏时，才在 \n<code>AppComponent</code> 提供者中注册服务。这是一种罕见的使用情况。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"epi85lwd24rf57qrj2im3rb9b\">更一般地说，\n<a href=\"guide/ngmodule-faq#q-component-or-module\">优先在 NgModule 中注册提供者</a>，而不是在组件中注册。</p>\n<h3 class=\"no-toc\" id=\"discussion\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"e51zlya75cbuqy3o40kio43hf\"><i class=\"material-icons\">link</i>讨论</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bw14mv2qkbuxrwj865tfexpcl\">Angular 将所有启动模块提供者与应用程序根注入器注册。 根注入器提供者创建的服务具有应用程序范围，这意味着它们可供整个应用程序使用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5182wwhzk0dxhfxfji30o4s9w\">某些服务，例如 \n<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>，只有在应用程序根注入器中注册时才能正常工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ble9ah6k0jrbb1kolxdcpcd4\">相比之下，Angular 将 \n<code>AppComponent</code> 提供者与 \n<code>AppComponent</code> 自己的注入器注册。 \n<code>AppComponent</code> 服务仅可供该组件及其组件树使用。 它们具有组件范围。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ry4hyrhrnecvq0an00qv97ps\"><code>AppComponent</code> 的注入器是根注入器的子注入器，在注入器层次结构中向下移动一级。 对于不使用路由器的应用程序来说，这几乎是整个应用程序。 但在路由应用程序中，路由在根级别运行， 而 \n<code>AppComponent</code> 服务不存在。 这意味着惰性加载的模块无法访问它们。</p>\n<hr>\n<a id=\"q-component-or-module\"></a>\n<h2 id=\"should-i-add-other-providers-to-a-module-or-a-component\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"10yvigwtmiry3t76v6ig5qrhu\"><i class=\"material-icons\">link</i>我应该把其它提供者注册到模块中还是组件中？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bkgkxzm80em84izh6yaics39k\">一般来说，优先在模块（\n<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code>）中注册特定于功能的提供者， 而不是在组件（\n<code>@Component.providers</code>）中注册。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"358s11u9sila3s3jld36ni4ff\">当你\n<em>必须</em>将服务实例的范围限制在该组件及其组件树时，才将提供者与组件注册。 对将提供者与指令注册应用相同的推理。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38zjo10polowmf1gdk9364eyc\">例如，需要缓存服务私有副本的编辑组件应该将服务与组件注册。 然后，每个新的组件实例都会获得自己的缓存服务实例。 编辑器在其服务中所做的更改不会影响应用程序中其他地方的实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9xsrzvh8rfw786x3p953ep3uo\"><a href=\"guide/ngmodule-faq#q-root-component-or-module\">始终将<em>应用程序范围</em>的服务与根 <code>AppModule</code> 注册</a>， 而不是根 \n<code>AppComponent</code>。</p>\n<hr>\n<a id=\"q-why-bad\"></a>\n<h2 id=\"why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6690idlmkoo75mgw93vpradyz\"><i class=\"material-icons\">link</i>为什么在共享模块中为惰性加载模块提供服务是个馊主意？</h2>\n<h3 id=\"the-eagerly-loaded-scenario\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"axohv88mjbupeuk35fmrwzo7l\"><i class=\"material-icons\">link</i>急性加载的场景</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f57o4b3ucn27w218bnnneiijf\">当一个急切加载的模块提供一个服务时，例如 \n<code>UserService</code>，该服务在应用程序范围内可用。如果根模块提供 \n<code>UserService</code> 并且 导入另一个提供相同 \n<code>UserService</code> 的模块，Angular 会在根应用程序注入器中注册其中一个 （参见 \n<a href=\"guide/ngmodule-faq#q-reimport\">如果我两次导入同一个模块会怎样？</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ei1cxvv5x429kqvlt8z7j7w7h\">然后，当某个组件注入 \n<code>UserService</code> 时，Angular 会在应用程序根注入器中找到它， 并提供应用程序范围的单例服务。没问题。</p>\n<h3 id=\"the-lazy-loaded-scenario\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"5w1jx7br7jhy4m4z46mg948pp\"><i class=\"material-icons\">link</i>惰性加载场景</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"cd2znw82mlpmducfiz6izohvp\">现在，考虑一个惰性加载的模块，它也提供了一个名叫 <code>UserService</code> 的服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6tex4cz7gyprqyzlbkzw7xixs\">当路由器惰性加载模块时，它会创建一个子注入器，并将 \n<code>UserService</code> 提供者与该子注入器注册。子注入器\n<em>不是</em>根注入器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"838q5zhwadeyrx09hhnwwiujs\">当 Angular 为该模块创建一个惰性组件并注入 \n<code>UserService</code> 时， 它会在惰性模块的\n<em>子注入器</em>中找到一个 \n<code>UserService</code> 提供者， 并创建一个\n<em>新的</em> \n<code>UserService</code> 实例。 这是一个与 Angular 在急切加载的组件中注入的应用程序范围的单例版本完全不同的 \n<code>UserService</code> 实例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"26qaouo9fpnlxinavxhefybwr\">这种情况会导致你的应用程序每次都创建一个新实例，而不是使用单例。</p>\n<!--KW--What does this cause? I wasn't able to get the suggestion of this to work from\nthe current FAQ:\nTo demonstrate, run the <live-example name=\"ngmodule\">live example</live-example>.\nModify the `SharedModule` so that it provides the `UserService` rather than the `CoreModule`.\nThen toggle between the \"Contact\" and \"Heroes\" links a few times.\nThe username goes bonkers as the Angular creates a new `UserService` instance each time.\nI'd like to see the error so I can include it.-->\n<hr>\n<a id=\"q-why-child-injector\"></a>\n<h2 id=\"why-does-lazy-loading-create-a-child-injector\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4fr5cegjhii7hzy24nlj29foo\"><i class=\"material-icons\">link</i>为什么惰性加载模块会创建一个子注入器？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qjba4n2zh6ai12b95nfgheen\">Angular 将 \n<code>@<a href=\"api/core/NgModule#providers\" class=\"code-anchor\">NgModule.providers</a></code> 添加到应用程序根注入器，除非 NgModule 是惰性加载的。 对于惰性加载的 NgModule，Angular 会创建一个\n<em>子注入器</em>，并将模块的提供者添加到子注入器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2uos8mu1p05z7i2wgzu24d03k\">这意味着 NgModule 的行为会根据它是在应用程序启动时加载还是稍后惰性加载而有所不同。忽略这种差异会导致 \n<a href=\"guide/ngmodule-faq#q-why-bad\">不利后果</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3vdqqcsjqexsac6f5wwcn9y8y\">为什么 Angular 不像对待急切加载的 NgModule 那样，将惰性加载的提供者添加到应用程序根注入器？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9flamf9zx2x7qu0taw5hu6ulo\">答案基于 Angular 依赖注入系统的基本特征。 注入器可以\n<em>直到它第一次使用</em>才添加提供者。 一旦注入器开始创建和提供服务，它的提供者列表就会被冻结；不允许添加新的提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2mv6v36yn17nuneelfapyteb3\">当应用程序启动时，Angular 首先使用所有急切加载的 NgModule 的提供者配置根注入器， \n<em>在</em>创建第一个组件并注入任何提供的服务之前。 一旦应用程序开始运行，应用程序根注入器就会关闭，不再接受新的提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fdl09a119um23yk3s16easv3\">时间流逝，应用程序逻辑触发 NgModule 的惰性加载。 Angular 必须将惰性加载的模块的提供者添加到某个注入器中。 它不能将它们添加到应用程序根注入器中，因为该注入器已关闭，不再接受新的提供者。 因此，Angular 为惰性加载的模块上下文创建一个新的子注入器。</p>\n<hr>\n<a id=\"q-is-it-loaded\"></a>\n<h2 id=\"how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"bn149kiy3hogx2qjpkwp6xbx2\"><i class=\"material-icons\">link</i>我要如何知道一个模块或服务是否已经加载过了？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"34qyuwh6r8om7qseroc3u6c4y\">某些 NgModule 及其服务应该只由根 \n<code>AppModule</code> 加载一次。 通过惰性加载模块第二次导入该模块可能会 \n<a href=\"guide/ngmodule-faq#q-why-bad\">产生错误的行为</a>， 这可能难以检测和诊断。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bvb8tfx7lhdm49p0sd800pdrf\">为了防止此问题，编写一个构造函数，尝试从根应用程序注入器注入模块或服务。如果注入成功，则该类已第二次加载。 你可以抛出一个错误或采取其他补救措施。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"hdiopy5cbrmytytnjsktrobq\">某些 NgModule，例如 \n<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，实现了这样的保护。 以下是一个名为 \n<code>CoreModule</code> 的 NgModule 的自定义构造函数。</p>\n<code-example path=\"ngmodule-faq/src/app/core/core.module.ts\" region=\"ctor\" title=\"src/app/core/core.module.ts (Constructor)\" linenums=\"false\">\nconstructor (@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule: CoreModule) {\n  if (parentModule) {\n    throw new Error(\n      'CoreModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<hr>\n<a id=\"q-entry-component-defined\"></a>\n<h2 id=\"what-is-an-entry-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8naovthoiln1e1xeijvbisgw3\"><i class=\"material-icons\">link</i>什么是\n<code>入口组件</code>？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97wbssyka3dthfahmwuvweunv\">入口组件是 Angular \n<em>按类型</em>\n<em>强制</em>加载的任何组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6h297l8p5x5oo1ecy742123m3\">通过其选择器\n<em>声明式</em>加载的组件\n<em>不是</em>入口组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bfs1sxw3e74zu9sjzipzdet5q\">当使用组件的选择器在模板中定位元素时，Angular 会声明式地加载组件。 然后，Angular 创建组件的 HTML 表示形式，并将其插入到 DOM 中选定的元素中。这些不是入口组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"33okm31z20rr47cq3n46j0oe1\">引导的根 \n<code>AppComponent</code> 是一个\n<em>入口组件</em>。 没错，它的选择器与 \n<code>index.html</code> 中的元素标签匹配。 但 \n<code>index.html</code> 不是组件模板，\n<code>AppComponent</code> 选择器与任何组件模板中的元素都不匹配。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ccqnz2axfc6l0skcpejnctq3n\">路由定义中的组件也是\n<em>入口组件</em>。 路由定义通过其\n<em>类型</em>引用组件。 路由器会忽略路由组件的选择器（如果有的话），并 将组件动态加载到 \n<code><a href=\"api/router/RouterOutlet\" class=\"code-anchor\">RouterOutlet</a></code> 中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mrey4rsehuim7be5wbvbix5u\">有关更多信息，请参阅 \n<a href=\"guide/entry-components\">入口组件</a>。</p>\n<hr>\n<h2 id=\"whats-the-difference-between-a-bootstrap-component-and-an-entry-component\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b5cffkpflnsptlzo5m57tphur\"><i class=\"material-icons\">link</i><em>引导</em>组件和\n<em>入口组件</em>有什么区别？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d04zmdpj7wqphsoooiozmsz2o\">引导组件\n<em>是</em>一个 \n<a href=\"guide/ngmodule-faq#q-entry-component-defined\">入口组件</a>， Angular 在引导过程中（应用程序启动）将其加载到 DOM 中。 其他入口组件通过其他方式动态加载，例如使用路由器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5thqj3kz8038z6n3yri0ombe6\"><code>@<a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">NgModule.bootstrap</a></code> 属性告诉编译器这是一个入口组件\n<em>并且</em> 它应该生成代码来使用此组件引导应用程序。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74c6wx7tzylxmtm3qd3q0beea\">无需在 \n<code>bootstrap</code> 和 \n<code>entryComponents</code> 列表中都列出组件， 尽管这样做无害。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mrey4rsehuim7be5wbvbix5u\">有关更多信息，请参阅 \n<a href=\"guide/entry-components\">入口组件</a>。</p>\n<hr>\n<h2 id=\"when-do-i-add-components-to-entrycomponents\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5vndw5r426gvdivizyxxn848a\"><i class=\"material-icons\">link</i>什么时候将组件添加到\n<em>entryComponents</em>？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ae43h5j8s0yxxk57krorasedz\">大多数应用程序开发人员不需要将组件添加到 \n<code>entryComponents</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15pm9aliqpr2gfnmv15mpuxvv\">Angular 会自动将某些组件添加到\n<em>entryComponents</em>。 在 \n<code>@<a href=\"api/core/NgModule#bootstrap\" class=\"code-anchor\">NgModule.bootstrap</a></code> 中列出的组件会自动添加。 在路由配置中引用的组件会自动添加。 这两种机制几乎涵盖了所有入口组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2xjpq7js8y1rsdy1l2qf72pid\">如果你的应用程序碰巧以\n<em>类型</em>的方式引导或动态加载组件， 你必须显式地将其添加到 \n<code>entryComponents</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47tc1ogjrxhwdnyyp1j887lx\">虽然将组件添加到此列表无害， 但最好只添加真正\n<em>入口组件</em>的组件。 不要包含 \n<a href=\"guide/ngmodule-faq#q-template-reference\">在其他组件的模板中引用的</a> 组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mrey4rsehuim7be5wbvbix5u\">有关更多信息，请参阅 \n<a href=\"guide/entry-components\">入口组件</a>。</p>\n<hr>\n<h2 id=\"why-does-angular-need-entrycomponents\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bzuqmhte7czpyy3d2sujfv7zl\"><i class=\"material-icons\">link</i>为什么 Angular 需要\n<em>entryComponents</em>？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ofko185rvej7ra7dm21ngc4a\">原因是\n<em>摇树优化</em>。对于生产应用程序，你希望加载尽可能小的、最快的代码。代码应该只包含你实际需要的类。 它应该排除从未使用的组件，无论该组件是否已声明。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15iw7ymhdy42vzhonwhetd6e7\">事实上，许多库声明并导出你永远不会使用的组件。 如果你没有引用它们，摇树优化器会将这些组件从最终的代码包中删除。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a5uu4nzfypr3xnorawz2zh0b3\">如果 \n<a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular 编译器</a> 为每个声明的组件生成代码，它就会破坏摇树优化的目的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8iulhy8qxnsobizzqjxlbrgis\">相反，编译器采用递归策略，只为你使用的组件生成代码。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7as9i0ou4qp4gsxjgcjj4c5p9\">编译器从入口组件开始， 然后它为在入口组件模板中 \n<a href=\"guide/ngmodule-faq#q-template-reference\">找到的</a> 声明组件生成代码， 然后为在先前编译的组件的模板中发现的声明组件生成代码， 等等。在该过程结束时，编译器已经为每个入口组件 以及从入口组件可达的每个组件生成了代码。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5t80w4i4p4t4764a9246uge12\">如果组件不是\n<em>入口组件</em>或未在模板中找到， 编译器会忽略它。</p>\n<hr>\n<h2 id=\"what-kinds-of-modules-should-i-have-and-how-should-i-use-them\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"a6yyld2ye5n3zswpwej68mtwh\"><i class=\"material-icons\">link</i>有哪些类型的模块？我应该如何使用它们？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"da1yfkysxup64nki0dnzxgzng\">每个应用程序都不一样。开发人员对可用选项有不同的经验水平和舒适度。 一些建议和指南似乎具有广泛的吸引力。</p>\n<h3 id=\"sharedmodule\"><code>SharedModule</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5xwk8zxmlhkjgzauo8bvk8vje\"><code>SharedModule</code> 是一个约定俗成的名称，用于表示一个 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>，其中包含你在 应用程序中随处使用的组件、指令和管道。此模块应该完全由 \n<code>declarations</code> 组成， 其中大多数是导出的。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1crwm9rd6e02nba11u6rt37r1\"><code>SharedModule</code> 可能会重新导出其他小部件模块，例如 \n<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>， \n<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>，以及包含你最广泛使用的 UI 控件的 NgModule。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41j2qcz9gdo6k8pl6ik2bzozw\"><code>SharedModule</code> 不应该有 \n<code>providers</code>，原因 \n<a href=\"guide/ngmodule-faq#q-why-bad\">如前所述</a>。 它的任何导入或重新导出的模块也不应该有 \n<code>providers</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6pgo9libk39oufq9ut2pp0zsx\">在你的\n<em>特性</em>模块中导入 \n<code>SharedModule</code>，包括应用启动时加载的模块和之后惰性加载的模块。</p>\n<h3 id=\"coremodule\"><code>CoreModule</code></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6vqs3chl1fpo25h9on30oo45i\"><code>CoreModule</code> 是一个约定俗成的名称，用于表示一个 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>，它包含应用启动时加载的单例服务的 \n<code>providers</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dyjiye3z3zt7pls3xy5b9t8p5\">只在根 \n<code>AppModule</code> 中导入 \n<code>CoreModule</code>。不要在任何其他模块中导入 \n<code>CoreModule</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tyg3jqskxivg98rygg8xms3y\">考虑将 \n<code>CoreModule</code> 设为一个纯服务模块，不包含任何 \n<code>declarations</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ap3i0ydeyac13zkk1gla25bb\">更多信息，请参见 \n<a href=\"guide/sharing-ngmodules\">共享 NgModules</a> 和 \n<a href=\"guide/singleton-services\">单例服务</a>。</p>\n<h3 id=\"feature-modules\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6fljutr1i4kb9wann6aj1uskb\"><i class=\"material-icons\">link</i>特性模块</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4exh7bxbcjji4brrt16je74o\">特性模块是围绕特定应用业务领域、用户工作流和实用程序集合创建的模块。它们通过包含特定特性（如路由、服务、小部件等）来支持你的应用。为了概念化你的应用中可能存在的特性模块，可以考虑，如果你要将与某个功能（如搜索）相关的文件放在一个文件夹中，那么该文件夹的内容将是一个特性模块，你可以将其称为 \n<code>SearchModule</code>。它将包含构成搜索功能的所有组件、路由和模板。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21i1d8r2nkiqtsx9lerx5wo92\">更多信息，请参见 \n<a href=\"guide/feature-modules\">特性模块</a> 和 \n<a href=\"guide/module-types\">模块类型</a></p>\n<h2 id=\"whats-the-difference-between-ngmodules-and-javascript-modules\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"61z9e97qlnd1yb5jeq5lpwdsg\"><i class=\"material-icons\">link</i>在 NgModule 和 JavaScript 模块之间有什么不同？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"58ugd7lznfuwrxhwpl57b5c1v\">在 Angular 应用中，NgModule 会和 JavaScript 的模块一起工作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"415qqgpa6ty1ou2fppfvmu0im\">在现代 JavaScript 中，每个文件都是一个模块（参见 Exploring ES6 网站的 \n<a href=\"http://exploringjs.com/es6/ch_modules.html\">模块</a> 页面）。在每个文件中，你编写一个 \n<code>export</code> 语句来公开模块的某些部分。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2urwyx6x56ghmjc68xaoiwjh5\">Angular NgModule 是一个带有 \n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器的类——JavaScript 模块不需要 \n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 装饰器。Angular 的 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 有 \n<code>imports</code> 和 \n<code>exports</code>，它们的作用类似。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"f0fcx4qh2l2cacde8fuhxekwy\">你可以<em>导入</em>其它 NgModules，以便在当前模块的组件模板中使用它们导出的类。你可以<em>导出</em>当前 NgModules 中的类，以便<em>其它</em> NgModules 可以导入它们，并用在自己的组件模板中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3jbl4qaly3bf30ing0km2x0r\">更多信息，请参见 \n<a href=\"guide/ngmodule-vs-jsmodule\">JavaScript 模块与 NgModules</a>。</p>\n<hr>\n<a id=\"q-template-reference\"></a>\n<h2 id=\"how-does-angular-find-components-directives-and-pipes-in-a-templatewhat-is-a-template-reference\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97ceb42j4t1rnyz719lm666am\"><i class=\"material-icons\">link</i>Angular 如何在模板中找到组件、指令和管道？\n<br>什么是\n<em>模板引用</em>？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afmapv62wy0yzxelb37g70dy1\"><a href=\"guide/ngmodule-faq#q-angular-compiler\">Angular 编译器</a> 会在组件模板中查找其他组件、指令和管道。当它找到一个时，这就是一个模板引用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dh2htgezwcf8qtyqg1itwjfd8\">当 Angular 编译器能够将该组件或指令的\n<em>选择器</em>与模板中的某些 HTML 匹配时，它就会在模板中找到该组件或指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"98fcekn2j3ewz68vmywbkxnmu\">如果管道的\n<em>名称</em>出现在模板 HTML 的管道语法中，编译器就会找到该管道。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wbcid6xy3joubibbk6375wp6\">Angular 只会匹配由该模块声明或由该模块导入的模块导出的类的选择器和管道名称。</p>\n<hr>\n<a id=\"q-angular-compiler\"></a>\n<h2 id=\"what-is-the-angular-compiler\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"mmd1tmgvcr0we30ml68k78xa\"><i class=\"material-icons\">link</i>什么是 Angular 编译器？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apa5jpwe5yhjn7rrf3fla2lg6\">Angular 编译器将你编写的应用程序代码转换为高性能的 JavaScript 代码。\n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 元数据在指导编译过程方面起着重要作用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6eqxyszyrcgg2rzgzjr0a2vwf\">你编写的代码不能立即执行。例如，组件有包含自定义元素、属性指令、Angular 绑定声明以及一些明显不是原生 HTML 的特殊语法的模板。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dtckf5vwpaarcd9uv0rr929al\">Angular 编译器读取模板标记，将其与相应的组件类代码结合起来，并发出\n<em>组件工厂</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xbwcnm77a4e63bco34zf8vm9\">组件工厂创建组件的纯 100% JavaScript 表示，其中包含其 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 元数据中描述的所有内容：HTML、绑定指令、附加的样式。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aek4y1zxb7g5rtwuhqtnoj3de\">由于指令和管道出现在组件模板中，因此 Angular 编译器也会将它们合并到已编译的组件代码中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ytyi2h9gqnl97s62uwfy5upp\"><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 元数据告诉 Angular 编译器要为该模块编译哪些组件，以及如何将该模块与其他模块链接起来。</p>\n\n</div>\n<!-- links to this doc:\n - guide/change-log\n - guide/entry-components\n - guide/ngmodule-api\n - guide/ngmodule-vs-jsmodule\n - guide/providers\n - guide/singleton-services\n-->\n<!-- links from this doc:\n - api/common/CommonModule\n - api/common/NgIf\n - api/common/http/HttpBackend\n - api/common/http/HttpClientModule\n - api/core/ApplicationModule\n - api/core/Component\n - api/core/ModuleWithProviders\n - api/core/NgModule\n - api/core/NgModule#bootstrap\n - api/core/NgModule#providers\n - api/core/Optional\n - api/core/SkipSelf\n - api/forms/FormsModule\n - api/forms/NgModel\n - api/platform-browser/BrowserModule\n - api/router/Router\n - api/router/RouterModule\n - api/router/RouterModule#forRoot\n - api/router/RouterOutlet\n - api/router/Routes\n - guide/bootstrapping#the-declarations-array\n - guide/entry-components\n - guide/feature-modules\n - guide/module-types\n - guide/ngmodule-faq#can-i-re-export-classes-and-modules\n - guide/ngmodule-faq#coremodule\n - guide/ngmodule-faq#discussion\n - guide/ngmodule-faq#feature-modules\n - guide/ngmodule-faq#how-can-i-tell-if-an-ngmodule-or-service-was-previously-loaded\n - guide/ngmodule-faq#how-do-i-restrict-service-scope-to-a-module\n - guide/ngmodule-faq#how-does-angular-find-components-directives-and-pipes-in-a-templatewhat-is-a-template-reference\n - guide/ngmodule-faq#ngmodule-faqs\n - guide/ngmodule-faq#prerequisites\n - guide/ngmodule-faq#q-angular-compiler\n - guide/ngmodule-faq#q-browser-vs-common-module\n - guide/ngmodule-faq#q-component-or-module\n - guide/ngmodule-faq#q-entry-component-defined\n - guide/ngmodule-faq#q-lazy-loaded-module-provider-visibility\n - guide/ngmodule-faq#q-reexport\n - guide/ngmodule-faq#q-reimport\n - guide/ngmodule-faq#q-root-component-or-module\n - guide/ngmodule-faq#q-template-reference\n - guide/ngmodule-faq#q-why-bad\n - guide/ngmodule-faq#q-why-child-injector\n - guide/ngmodule-faq#sharedmodule\n - guide/ngmodule-faq#should-i-add-application-wide-providers-to-the-root-appmodule-or-the-root-appcomponent\n - guide/ngmodule-faq#should-i-add-other-providers-to-a-module-or-a-component\n - guide/ngmodule-faq#should-i-import-browsermodule-or-commonmodule\n - guide/ngmodule-faq#the-eagerly-loaded-scenario\n - guide/ngmodule-faq#the-lazy-loaded-scenario\n - guide/ngmodule-faq#what-classes-should-i-add-to-the-declarations-array\n - guide/ngmodule-faq#what-classes-should-i-not-add-to-declarations\n - guide/ngmodule-faq#what-does-cant-bind-to-x-since-it-isnt-a-known-property-of-y-mean\n - guide/ngmodule-faq#what-if-i-import-the-same-module-twice\n - guide/ngmodule-faq#what-if-two-modules-provide-the-same-service\n - guide/ngmodule-faq#what-is-a-declarable\n - guide/ngmodule-faq#what-is-an-entry-component\n - guide/ngmodule-faq#what-is-the-angular-compiler\n - guide/ngmodule-faq#what-is-the-forroot-method\n - guide/ngmodule-faq#what-kinds-of-modules-should-i-have-and-how-should-i-use-them\n - guide/ngmodule-faq#what-should-i-export\n - guide/ngmodule-faq#what-should-i-import\n - guide/ngmodule-faq#what-should-i-not-export\n - guide/ngmodule-faq#whats-the-difference-between-a-bootstrap-component-and-an-entry-component\n - guide/ngmodule-faq#whats-the-difference-between-ngmodules-and-javascript-modules\n - guide/ngmodule-faq#when-do-i-add-components-to-entrycomponents\n - guide/ngmodule-faq#why-does-angular-need-entrycomponents\n - guide/ngmodule-faq#why-does-lazy-loading-create-a-child-injector\n - guide/ngmodule-faq#why-is-a-service-provided-in-a-feature-module-visible-everywhere\n - guide/ngmodule-faq#why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module\n - guide/ngmodule-faq#why-is-it-bad-if-a-shared-module-provides-a-service-to-a-lazy-loaded-module\n - guide/ngmodule-faq#why-list-the-same-component-in-multiple-ngmodule-properties\n - guide/ngmodule-vs-jsmodule\n - guide/ngmodules\n - guide/sharing-ngmodules\n - guide/singleton-services\n - http://exploringjs.com/es6/ch_modules.html\n-->"
}