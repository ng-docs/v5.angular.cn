{
  "id": "guide/dependency-injection-pattern",
  "title": "The Dependency Injection pattern",
  "contents": "\n<div class=\"content\">\n<h1 id=\"the-dependency-injection-pattern\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-pattern#the-dependency-injection-pattern\"><i class=\"material-icons\">link</i></a>The Dependency Injection pattern</h1>\n<p><strong>Dependency injection</strong> is an important application design pattern.\nIt's used so widely that almost everyone just calls it <em>DI</em>.</p>\n<p>Angular has its own dependency injection framework, and\nyou really can't build an Angular application without it.</p>\n<p>This page covers what DI is and why it's useful.</p>\n<p>When you've learned the general pattern, you're ready to turn to\nthe <a href=\"guide/dependency-injection\">Angular Dependency Injection</a> guide to see how it works in an Angular app.</p>\n<a id=\"why-di\"></a>\n<h2 id=\"why-dependency-injection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/dependency-injection-pattern#why-dependency-injection\"><i class=\"material-icons\">link</i></a>Why dependency injection?</h2>\n<p>To understand why dependency injection is so important, consider an example without it.\nImagine writing the following code:</p>\n<code-example path=\"dependency-injection/src/app/car/car-no-di.ts\" region=\"car\" title=\"src/app/car/car.ts (without DI)\">\nexport class Car {\n\n  public engine: Engine;\n  public tires: Tires;\n  public description = 'No DI';\n\n  constructor() {\n    this.engine = new Engine();\n    this.tires = new Tires();\n  }\n\n  // Method using the engine and tires\n  drive() {\n    return `${this.description} car with ` +\n      `${this.engine.cylinders} cylinders and ${this.tires.make} tires.`;\n  }\n}\n\n</code-example>\n<p>The <code>Car</code> class creates everything it needs inside its constructor.\nWhat's the problem?\nThe problem is that the <code>Car</code> class is brittle, inflexible, and hard to test.</p>\n<p>This <code>Car</code> needs an engine and tires. Instead of asking for them,\nthe <code>Car</code> constructor instantiates its own copies from\nthe very specific classes <code>Engine</code> and <code>Tires</code>.</p>\n<p>What if the <code>Engine</code> class evolves and its constructor requires a parameter?\nThat would break the <code>Car</code> class and it would stay broken until you rewrote it along the lines of\n<code>this.engine = new Engine(theNewParameter)</code>.\nThe <code>Engine</code> constructor parameters weren't even a consideration when you first wrote <code>Car</code>.\nYou may not anticipate them even now.\nBut you'll <em>have</em> to start caring because\nwhen the definition of <code>Engine</code> changes, the <code>Car</code> class must change.\nThat makes <code>Car</code> brittle.</p>\n<p>What if you want to put a different brand of tires on your <code>Car</code>? Too bad.\nYou're locked into whatever brand the <code>Tires</code> class creates. That makes the\n<code>Car</code> class inflexible.</p>\n<p>Right now each new car gets its own <code>engine</code>. It can't share an <code>engine</code> with other cars.\nWhile that makes sense for an automobile engine,\nsurely you can think of other dependencies that should be shared, such as the onboard\nwireless connection to the manufacturer's service center. This <code>Car</code> lacks the flexibility\nto share services that have been created previously for other consumers.</p>\n<p>When you write tests for <code>Car</code> you're at the mercy of its hidden dependencies.\nIs it even possible to create a new <code>Engine</code> in a test environment?\nWhat does <code>Engine</code> depend upon? What does that dependency depend on?\nWill a new instance of <code>Engine</code> make an asynchronous call to the server?\nYou certainly don't want that going on during tests.</p>\n<p>What if the <code>Car</code> should flash a warning signal when tire pressure is low?\nHow do you confirm that it actually does flash a warning\nif you can't swap in low-pressure tires during the test?</p>\n<p>You have no control over the car's hidden dependencies.\nWhen you can't control the dependencies, a class becomes difficult to test.</p>\n<p>How can you make <code>Car</code> more robust, flexible, and testable?</p>\n<a id=\"ctor-injection\"></a>\n<p>That's super easy. Change the <code>Car</code> constructor to a version with DI:</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/car/car.ts (excerpt with DI)\" path=\"dependency-injection/src/app/car/car.ts\" region=\"car-ctor\">\npublic description = 'DI';\n\nconstructor(public engine: Engine, public tires: Tires) { }\n\n</code-pane>\n\n  <code-pane title=\"src/app/car/car.ts (excerpt without DI)\" path=\"dependency-injection/src/app/car/car-no-di.ts\" region=\"car-ctor\">\npublic engine: Engine;\npublic tires: Tires;\npublic description = 'No DI';\n\nconstructor() {\n  this.engine = new Engine();\n  this.tires = new Tires();\n}\n\n</code-pane>\n\n</code-tabs>\n<p>See what happened? The definition of the dependencies are\nnow in the constructor.\nThe <code>Car</code> class no longer creates an <code>engine</code> or <code>tires</code>.\nIt just consumes them.</p>\n<div class=\"l-sub-section\">\n<p>This example leverages TypeScript's constructor syntax for declaring\nparameters and properties simultaneously.</p>\n</div>\n<p>Now you can create a car by passing the engine and tires to the constructor.</p>\n<code-example path=\"dependency-injection/src/app/car/car-creations.ts\" region=\"car-ctor-instantiation\" linenums=\"false\">\n// Simple car with 4 cylinders and Flintstone tires.\nlet car = new Car(new Engine(), new Tires());\n\n</code-example>\n<p>How cool is that?\nThe definition of the <code>engine</code> and <code>tire</code> dependencies are\ndecoupled from the <code>Car</code> class.\nYou can pass in any kind of <code>engine</code> or <code>tires</code> you like, as long as they\nconform to the general API requirements of an <code>engine</code> or <code>tires</code>.</p>\n<p>Now, if someone extends the <code>Engine</code> class, that is not <code>Car</code>'s problem.</p>\n<div class=\"l-sub-section\">\n<p>The <em>consumer</em> of <code>Car</code> has the problem. The consumer must update the car creation code to\nsomething like this:</p>\n<code-example path=\"dependency-injection/src/app/car/car-creations.ts\" region=\"car-ctor-instantiation-with-param\" linenums=\"false\">\nclass Engine2 {\n  constructor(public cylinders: number) { }\n}\n// Super car with 12 cylinders and Flintstone tires.\nlet bigCylinders = 12;\nlet car = new Car(new Engine2(bigCylinders), new Tires());\n\n</code-example>\n<p>The critical point is this: the <code>Car</code> class did not have to change.\nYou'll take care of the consumer's problem shortly.</p>\n</div>\n<p>The <code>Car</code> class is much easier to test now because you are in complete control\nof its dependencies.\nYou can pass mocks to the constructor that do exactly what you want them to do\nduring each test:</p>\n<code-example path=\"dependency-injection/src/app/car/car-creations.ts\" region=\"car-ctor-instantiation-with-mocks\" linenums=\"false\">\nclass MockEngine extends Engine { cylinders = 8; }\nclass MockTires  extends Tires  { make = 'YokoGoodStone'; }\n\n// Test car with 8 cylinders and YokoGoodStone tires.\nlet car = new Car(new MockEngine(), new MockTires());\n\n</code-example>\n<p><strong>You just learned what dependency injection is</strong>.</p>\n<p>It's a coding pattern in which a class receives its dependencies from external\nsources rather than creating them itself.</p>\n<p>Cool! But what about that poor consumer?\nAnyone who wants a <code>Car</code> must now\ncreate all three parts: the <code>Car</code>, <code>Engine</code>, and <code>Tires</code>.\nThe <code>Car</code> class shed its problems at the consumer's expense.\nYou need something that takes care of assembling these parts.</p>\n<p>You <em>could</em> write a giant class to do that:</p>\n<code-example path=\"dependency-injection/src/app/car/car-factory.ts\" title=\"src/app/car/car-factory.ts\">\nimport { Engine, Tires, Car } from './car';\n\n// BAD <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>!\nexport class CarFactory {\n  createCar() {\n    let car = new Car(this.createEngine(), this.createTires());\n    car.description = 'Factory';\n    return car;\n  }\n\n  createEngine() {\n    return new Engine();\n  }\n\n  createTires() {\n    return new Tires();\n  }\n}\n\n\n</code-example>\n<p>It's not so bad now with only three creation methods.\nBut maintaining it will be hairy as the application grows.\nThis factory is going to become a huge spiderweb of\ninterdependent factory methods!</p>\n<p>Wouldn't it be nice if you could simply list the things you want to build without\nhaving to define which dependency gets injected into what?</p>\n<p>This is where the dependency injection framework comes into play.\nImagine the framework had something called an <em>injector</em>.\nYou register some classes with this injector, and it figures out how to create them.</p>\n<p>When you need a <code>Car</code>, you simply ask the injector to get it for you and you're good to go.</p>\n<code-example path=\"dependency-injection/src/app/car/car-injector.ts\" region=\"injector-call\" title=\"src/app/car/car-injector.ts\" linenums=\"false\">\nlet car = injector.get(Car);\n\n</code-example>\n<p>Everyone wins. The <code>Car</code> knows nothing about creating an <code>Engine</code> or <code>Tires</code>.\nThe consumer knows nothing about creating a <code>Car</code>.\nYou don't have a gigantic factory class to maintain.\nBoth <code>Car</code> and consumer simply ask for what they need and the injector delivers.</p>\n<p>This is what a <strong>dependency injection framework</strong> is all about.</p>\n<p>Now that you know what dependency injection is and appreciate its benefits,\nturn to the <a href=\"guide/dependency-injection\">Angular Dependency Injection</a> guide to see how it is implemented in Angular.</p>\n\n</div>\n<!-- links to this doc:\n - guide/dependency-injection\n-->\n<!-- links from this doc:\n - api/forms/PatternValidator\n - guide/dependency-injection\n - guide/dependency-injection-pattern#the-dependency-injection-pattern\n - guide/dependency-injection-pattern#why-dependency-injection\n-->"
}