{
  "id" : "guide/dependency-injection-pattern",
  "title" : "依赖注入模式",
  "contents" : "<div class=\"content\">\n<h1 id=\"the-dependency-injection-pattern\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bnvn6dvoswts95oc5l3rxgan2\"><i class=\"material-icons\">link</i>依赖注入模式</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dl4mc1jftkhdz5zz6yss8s28v\"><strong>依赖注入</strong>是一个重要的应用程序设计模式。 它被广泛使用，以至于几乎每个人都称之为 \n<em>DI</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zmhxr26xahrcbiq38nic1s9d\">Angular 有自己的依赖注入框架， 你实际上无法在没有它的情况下构建 Angular 应用程序。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c9opjcrtz81i9b2kfbope6rov\">本页介绍了什么是 DI 以及它为什么有用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"evbkkinbzsaekoy0g4wbggz54\">当你了解了通用模式后，就可以转向 \n<a href=\"guide/dependency-injection\">Angular 依赖注入</a> 指南，了解它在 Angular 应用程序中的工作原理。</p>\n<a id=\"why-di\"></a>\n<h2 id=\"why-dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"85bdtuuh6q4x8xvgvxeal8w8c\"><i class=\"material-icons\">link</i>为什么使用依赖注入？</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7xqvjvpr3mu99o9moh821ps31\">为了理解为什么依赖注入如此重要，请考虑一个没有它的示例。 想象一下编写以下代码：</p>\n<code-example path=\"dependency-injection/src/app/car/car-no-di.ts\" region=\"car\" title=\"src/app/car/car.ts (without DI)\">\nexport class Car {\n\n  public engine: Engine;\n  public tires: Tires;\n  public description = 'No DI';\n\n  constructor() {\n    this.engine = new Engine();\n    this.tires = new Tires();\n  }\n\n  // Method using the engine and tires\n  drive() {\n    return `${this.description} car with ` +\n      `${this.engine.cylinders} cylinders and ${this.tires.make} tires.`;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5gvvmgnpg493ov2hiy1f835z\"><code>Car</code> 类在其构造函数内部创建它需要的一切。 问题是什么？ 问题是 \n<code>Car</code> 类很脆弱、不灵活，而且难以测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4b9h9ecjnsvubyl29n6nxkja\">此 \n<code>Car</code> 需要一个发动机和轮胎。\n<code>Car</code> 构造函数没有请求它们，而是从非常具体的 \n<code>Engine</code> 和 \n<code>Tires</code> 类中实例化了自己的副本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1bvjb6f1ixub03lj5rvhct15m\">如果 \n<code>Engine</code> 类发生变化，并且它的构造函数需要一个参数怎么办？这会破坏 \n<code>Car</code> 类，并且它会一直处于损坏状态，直到你按照 \n<code>this.engine = new Engine(theNewParameter)</code> 的方式重写它。当你第一次编写 \n<code>Car</code> 时，\n<code>Engine</code> 构造函数参数甚至没有被考虑。你现在可能也无法预料到它们。但你必须开始关注它们，因为当 \n<code>Engine</code> 的定义发生变化时，\n<code>Car</code> 类必须发生变化。这使得 \n<code>Car</code> 变得脆弱。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aok65m8vye1tv6xulthm1idrb\">如果你想在你的 \n<code>Car</code> 上安装不同品牌的轮胎怎么办？太可惜了。你被锁定在 \n<code>Tires</code> 类创建的任何品牌中。这使得 \n<code>Car</code> 类变得不灵活。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41v4gw7ruy79p0bzehl5zewt6\">现在，每辆新车都拥有自己的 \n<code>engine</code>。它不能与其他汽车共享 \n<code>engine</code>。虽然这对汽车发动机来说是有意义的，但你肯定可以想到其他应该共享的依赖项，例如与制造商服务中心的无线连接。此 \n<code>Car</code> 缺乏灵活地共享以前为其他消费者创建的服务。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4j0633a2uab58ukv7twyqomit\">当你为 \n<code>Car</code> 编写测试时，你将受到其隐藏依赖项的支配。在测试环境中创建新的 \n<code>Engine</code> 甚至可能吗？\n<code>Engine</code> 依赖于什么？该依赖项又依赖于什么？\n<code>Engine</code> 的新实例会向服务器发出异步调用吗？你当然不希望在测试期间发生这种情况。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60d1oghewit4r9a8x0toml9n7\">如果 \n<code>Car</code> 应该在轮胎气压过低时闪烁警告信号怎么办？如果你不能在测试期间换上低气压轮胎，你怎么确认它真的会闪烁警告信号？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2nj1rxjuc0b8y0dckejotp74\">你无法控制汽车的隐藏依赖项。当你无法控制依赖项时，一个类就变得难以测试。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2u49qtxrow3zh6i4dhhpo8fiv\">如何使 \n<code>Car</code> 更加健壮、灵活和可测试？</p>\n<a id=\"ctor-injection\"></a>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b1qvu8p0s65dcifcl7mrjx4xi\">这非常容易。将 \n<code>Car</code> 构造函数更改为具有 DI 的版本：</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/car/car.ts (excerpt with DI)\" path=\"dependency-injection/src/app/car/car.ts\" region=\"car-ctor\">\npublic description = 'DI';\n\nconstructor(public engine: Engine, public tires: Tires) { }\n\n</code-pane>\n\n  <code-pane title=\"src/app/car/car.ts (excerpt without DI)\" path=\"dependency-injection/src/app/car/car-no-di.ts\" region=\"car-ctor\">\npublic engine: Engine;\npublic tires: Tires;\npublic description = 'No DI';\n\nconstructor() {\n  this.engine = new Engine();\n  this.tires = new Tires();\n}\n\n</code-pane>\n\n</code-tabs>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cfcqr2k4lrv1fzpje6k0a7wy8\">看看发生了什么？依赖项的定义现在在构造函数中。\n<code>Car</code> 类不再创建 \n<code>engine</code> 或 \n<code>tires</code>。它只是消费它们。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aomrk70mziaq4nvjrztuxzi4g\">此示例利用 TypeScript 的构造函数语法来同时声明参数和属性。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cj3r5do4obl93k096ysm1kajt\">现在，你可以通过将发动机和轮胎传递给构造函数来创建汽车。</p>\n<code-example path=\"dependency-injection/src/app/car/car-creations.ts\" region=\"car-ctor-instantiation\" linenums=\"false\">\n// Simple car with 4 cylinders and Flintstone tires.\nlet car = new Car(new Engine(), new Tires());\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3j2jxajcunle0rb502foklfwm\">这太酷了！\n<code>engine</code> 和 \n<code>tire</code> 依赖项的定义与 \n<code>Car</code> 类分离。你可以传入任何你喜欢的 \n<code>engine</code> 或 \n<code>tires</code>，只要它们符合 \n<code>engine</code> 或 \n<code>tires</code> 的通用 API 要求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c5dxso20fh3xh97t8bdn5rbae\">现在，如果有人扩展了 \n<code>Engine</code> 类，那不是 \n<code>Car</code> 的问题。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5o9ec8jfglylys9b5cpvc934i\"><code>Car</code> 的\n<em>消费者</em> 遇到了问题。消费者必须更新汽车创建代码，使其类似于以下代码：</p>\n<code-example path=\"dependency-injection/src/app/car/car-creations.ts\" region=\"car-ctor-instantiation-with-param\" linenums=\"false\">\nclass Engine2 {\n  constructor(public cylinders: number) { }\n}\n// Super car with 12 cylinders and Flintstone tires.\nlet bigCylinders = 12;\nlet car = new Car(new Engine2(bigCylinders), new Tires());\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlcghnpw46pw23qx8lnlercu0\">关键点在于：\n<code>Car</code> 类不需要改变。你很快就会解决消费者的问题。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cix3dj2a3xkjd7vz0v25534cz\"><code>Car</code> 类现在更容易测试，因为你完全控制着它的依赖项。你可以将模拟对象传递给构造函数，这些模拟对象在每次测试期间都执行你想要的操作：</p>\n<code-example path=\"dependency-injection/src/app/car/car-creations.ts\" region=\"car-ctor-instantiation-with-mocks\" linenums=\"false\">\nclass MockEngine extends Engine { cylinders = 8; }\nclass MockTires  extends Tires  { make = 'YokoGoodStone'; }\n\n// Test car with 8 cylinders and YokoGoodStone tires.\nlet car = new Car(new MockEngine(), new MockTires());\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5o9lxe10d1gxomvcghf3l97k\"><strong>你刚刚了解了什么是依赖注入</strong>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48egwx5x42rgpj6q01mzch1px\">它是一种编码模式，其中一个类从外部来源接收其依赖项，而不是自己创建它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ku5d17rn11kd9xdiw04t2a5v\">酷！但是那个可怜的消费者怎么办？任何想要 \n<code>Car</code> 的人都必须现在创建所有三个部分：\n<code>Car</code>、\n<code>Engine</code> 和 \n<code>Tires</code>。\n<code>Car</code> 类以消费者的代价摆脱了它的问题。你需要一些东西来负责组装这些部分。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dseenhmr1c8674cnux49r21x5\">你可以编写一个巨大的类来完成这项工作：</p>\n<code-example path=\"dependency-injection/src/app/car/car-factory.ts\" title=\"src/app/car/car-factory.ts\">\nimport { Engine, Tires, Car } from './car';\n\n// BAD <a href=\"api/forms/PatternValidator\" class=\"code-anchor\">pattern</a>!\nexport class CarFactory {\n  createCar() {\n    let car = new Car(this.createEngine(), this.createTires());\n    car.description = 'Factory';\n    return car;\n  }\n\n  createEngine() {\n    return new Engine();\n  }\n\n  createTires() {\n    return new Tires();\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dddl9ggvfwsx22tfaced9bujy\">现在只有三个创建方法，所以它并不糟糕。但是，随着应用程序的增长，维护它将变得很困难。这个工厂将变成一个巨大的相互依赖的工厂方法的蜘蛛网！</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ha2ko1c05gjnuuu43cil6uui\">如果你可以简单地列出你想要构建的东西，而无需定义哪个依赖项被注入到什么中，那不是很好吗？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rluh9xxvxeydk34ka1walouz\">这就是依赖注入框架发挥作用的地方。想象一下，框架中有一个叫做\n<em>注入器</em>的东西。你向这个注入器注册一些类，它会弄清楚如何创建它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"wqub6kg7ckvsn2vfx09kcg4y\">当你需要一个 \n<code>Car</code> 时，你只需请求注入器为你获取它，你就可以开始了。</p>\n<code-example path=\"dependency-injection/src/app/car/car-injector.ts\" region=\"injector-call\" title=\"src/app/car/car-injector.ts\" linenums=\"false\">\nlet car = injector.get(Car);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2yyf72q9pxrz3trx1jnvfxaci\">每个人都赢了。\n<code>Car</code> 不知道如何创建 \n<code>Engine</code> 或 \n<code>Tires</code>。消费者不知道如何创建 \n<code>Car</code>。你没有一个巨大的工厂类需要维护。\n<code>Car</code> 和消费者只需请求他们需要的东西，注入器就会提供。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cd8qosq4o6jdn3m08k2mwcy5z\">这就是\n<strong>依赖注入框架</strong>的全部意义所在。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5t722fljk9qo5iwhfly19i8v8\">现在你已经了解了什么是依赖注入，并且了解了它的好处，请转到 \n<a href=\"guide/dependency-injection\">Angular 依赖注入</a> 指南，了解它在 Angular 中是如何实现的。</p>\n\n</div>\n<!-- links to this doc:\n - guide/dependency-injection\n-->\n<!-- links from this doc:\n - api/forms/PatternValidator\n - guide/dependency-injection\n - guide/dependency-injection-pattern#the-dependency-injection-pattern\n - guide/dependency-injection-pattern#why-dependency-injection\n-->"
}