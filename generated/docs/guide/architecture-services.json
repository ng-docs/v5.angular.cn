{
  "id" : "guide/architecture-services",
  "title" : "服务和依赖注入简介",
  "contents" : "<div class=\"content\">\n<h1 id=\"introduction-to-services-and-dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bf32h5za0czlpfvt5swminq5q\"><i class=\"material-icons\">link</i>服务和依赖注入简介</h1>\n<img src=\"generated/images/guide/architecture/service.png\" alt=\"Service\" class=\"left\" width=\"161\" height=\"125\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2wtd5noq8rqp7bod2cvkruyhi\"><em>服务</em>是一个广泛的类别，涵盖应用程序需要的任何值、函数或特性。服务通常是一个具有狭窄、明确定义目的的类。它应该做一些具体的事情，并且做得很好。 \n<br class=\"clear\"></p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"12scdfo97oqaui41l266o9dr5\">Angular 区分组件和服务，以提高模块化和可重用性。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"56djnoar50akmce7r7mgef21p\">通过将组件的视图相关功能与其他类型的处理分离，你可以使组件类变得精简高效。理想情况下，组件的工作是启用用户体验，仅此而已。它应该提供用于数据绑定的属性和方法，以便在视图（由模板渲染）和应用程序逻辑（通常包括对\n<em>模型</em>的某种概念）之间进行协调。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a7xxlf3uc0y9h2farb7z9p5ej\">组件不应该需要定义诸如如何从服务器获取数据、验证用户输入或直接记录到控制台之类的事情。相反，它可以将这些任务委托给服务。通过在可注入的服务类中定义这种类型的处理任务，你可以使其对任何组件都可用。你还可以通过在不同情况下注入相同类型服务的不同提供者来使你的应用程序更具适应性。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41fg2hicq6a7jg1k33py0j0b5\">Angular 不会\n<em>强制执行</em>这些原则。Angular 确实可以帮助你\n<em>遵循</em>这些原则，方法是使将你的应用程序逻辑分解为服务并通过\n<em>依赖注入</em>使这些服务可用于组件变得容易。</p>\n<h2 id=\"service-examples\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a8bl73lz949i79hn8v0p6tzjx\"><i class=\"material-icons\">link</i>服务示例</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"25uczcza1f33ahtrcp7qkih0x\">以下是一个将日志记录到浏览器控制台的服务类示例：</p>\n<code-example path=\"architecture/src/app/logger.service.ts\" linenums=\"false\" title=\"src/app/logger.service.ts (class)\" region=\"class\">\nexport class Logger {\n  log(msg: any)   { console.log(msg); }\n  error(msg: any) { console.error(msg); }\n  warn(msg: any)  { console.warn(msg); }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"awxe2hx5hzjv343q6fuhutynj\">服务可以依赖于其他服务。例如，以下是一个 \n<code>HeroService</code>，它依赖于 \n<code>Logger</code> 服务，并且还使用 \n<code>BackendService</code> 来获取英雄。该服务反过来可能依赖于 \n<code><a href=\"api/common/http/HttpClient\" class=\"code-anchor\">HttpClient</a></code> 服务来异步地从服务器获取英雄。</p>\n<code-example path=\"architecture/src/app/hero.service.ts\" linenums=\"false\" title=\"src/app/hero.service.ts (class)\" region=\"class\">\nexport class HeroService {\n  private heroes: Hero[] = [];\n\n  constructor(\n    private backend: BackendService,\n    private logger: Logger) { }\n\n  getHeroes() {\n    this.backend.getAll(Hero).then( (heroes: Hero[]) =&gt; {\n      this.logger.log(`Fetched ${heroes.length} heroes.`);\n      this.heroes.push(...heroes); // fill cache\n    });\n    return this.heroes;\n  }\n}\n\n\n</code-example>\n<hr>\n<h2 id=\"dependency-injection\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"ev35fdpq1f46jvj853hmazgoj\"><i class=\"material-icons\">link</i>依赖注入</h2>\n<img src=\"generated/images/guide/architecture/dependency-injection.png\" alt=\"Service\" class=\"left\" width=\"200\" height=\"90\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ah78oe4w7lh0zuupzso8wg8ml\">组件使用服务；也就是说，你可以将服务\n<em>注入</em>到组件中，使组件能够访问该服务类。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cwcn5khty79jt1pduarhmp8mt\">要在 Angular 中将类定义为服务，请使用 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 装饰器来提供元数据，使 Angular 能够将其作为\n<em>依赖项</em>注入到组件中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5cgqb0cmy7xrkrogrzcrl16yj\">类似地，使用 \n<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> 装饰器来指示组件或其他类（例如另一个服务、管道或 NgModule）\n<em>具有</em>依赖项。依赖项不必是服务——它可以是函数，例如，也可以是值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nx48qljsdbacuqwp4ow6ald\"><em>依赖注入</em>（通常称为 DI）被连接到 Angular 框架中，并在所有地方使用，为新组件提供它们需要的服务或其他东西。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"81wuc1kka5jx4tdcnm3covbpt\"><em>注入器</em>是主要机制。你不需要创建 Angular 注入器。Angular 在引导过程中为你创建一个应用程序范围的注入器。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aj2jjxg2clinifxb6wx1dzagr\">注入器维护一个它已经创建的依赖项实例的\n<em>容器</em>，并在可能的情况下重复使用它们。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97nldld5g8z1k0e04j3nxqam\"><em>提供者</em>是创建依赖项的配方。对于服务，这通常是服务类本身。对于应用程序中需要的任何依赖项，必须向应用程序的注入器注册一个提供者，以便注入器可以使用它来创建新实例。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5y4v8134bblynbqmh2kg4r4lo\">当 Angular 创建组件类的实例时，它会通过查看构造函数参数的类型来确定该组件需要哪些服务或其他依赖项。例如，\n<code>HeroListComponent</code> 的构造函数需要一个 \n<code>HeroService</code>：</p>\n<code-example path=\"architecture/src/app/hero-list.component.ts\" linenums=\"false\" title=\"src/app/hero-list.component.ts (constructor)\" region=\"ctor\">\nconstructor(private service: HeroService) { }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"r6vix1tsrg05pjqscw7s33by\">当 Angular 发现组件依赖于服务时，它首先检查注入器是否已经存在该服务的任何实例。如果请求的服务实例尚不存在，注入器将使用注册的提供者创建一个实例，并在将服务返回给 Angular 之前将其添加到注入器中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"azi8pf0rs679xrhdnc8oegqwv\">当所有请求的服务都已解析并返回时，Angular 就可以用这些服务实例为参数，调用该组件的构造函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"289tbzfotkxb08scje2kx5jt7\"><code>HeroService</code> 注入的过程类似于以下步骤：</p>\n<figure>\n  <img src=\"generated/images/guide/architecture/injector-injects.png\" alt=\"Service\" class=\"left\" width=\"479\" height=\"218\">\n</figure>\n<h3 id=\"providing-services\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvipb1zc3mws7yo28dgl1og1z\"><i class=\"material-icons\">link</i>提供服务</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9x4r7j17a9vx8tgkljmiqo3yi\">必须注册至少一个要使用的服务的\n<em>提供者</em>。可以在模块或组件中注册提供者。</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3b4tcablnhykygz6elub7r9yw\">将提供者添加到 \n<a href=\"guide/architecture-modules\">根模块</a> 时，应用程序中所有组件都可以使用服务的同一实例。</li>\n</ul>\n<code-example path=\"architecture/src/app/app.module.ts\" linenums=\"false\" title=\"src/app/app.module.ts (module providers)\" region=\"providers\">\nproviders: [\n  BackendService,\n  HeroService,\n  Logger\n],\n\n</code-example>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ogdrodmq7ya66uh1saurufxj\">在组件级别注册提供者时，每个组件的新实例都会获得一个新的服务实例。在组件级别，在 \n<code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> 元数据的 \n<code>providers</code> 属性中注册服务提供者：</li>\n</ul>\n<code-example path=\"architecture/src/app/hero-list.component.ts\" linenums=\"false\" title=\"src/app/hero-list.component.ts (component providers)\" region=\"providers\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector:    'app-hero-list',\n  templateUrl: './hero-list.component.html',\n  providers:  [ HeroService ]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"24xdhyugj1yzi1z7olez8vtx1\">有关更详细的信息，请参阅 \n<a href=\"guide/dependency-injection\">依赖注入</a> 部分。</p>\n<hr>\n\n</div>\n<!-- links to this doc:\n - guide/architecture\n - guide/architecture-modules\n-->\n<!-- links from this doc:\n - api/common/http/HttpClient\n - api/core/Component\n - api/core/Injectable\n - guide/architecture-modules\n - guide/architecture-services#dependency-injection\n - guide/architecture-services#introduction-to-services-and-dependency-injection\n - guide/architecture-services#providing-services\n - guide/architecture-services#service-examples\n - guide/dependency-injection\n-->"
}