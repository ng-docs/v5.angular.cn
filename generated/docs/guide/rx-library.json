{
  "id" : "guide/rx-library",
  "title" : "RxJS 库",
  "contents" : "<div class=\"content\">\n<h1 id=\"the-rxjs-library\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9oessfy3od8pm2dvyizdfw3a3\"><i class=\"material-icons\">link</i>RxJS 库</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2lqon081kz1wiqnbnshjljgg9\">响应式编程是一种异步编程范式，它关注数据流和变化的传播（\n<a href=\"https://en.wikipedia.org/wiki/Reactive_programming\">维基百科</a>）。RxJS（Reactive Extensions for JavaScript）是一个使用可观察者的响应式编程库，它使异步或基于回调的代码更容易组合（\n<a href=\"http://reactivex.io/rxjs/\">RxJS 文档</a>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3arhxr74nlbuquk5s3se17m7i\">RxJS 提供了 \n<code>Observable</code> 类型的实现，这在该类型成为语言的一部分之前以及浏览器支持它之前是必需的。该库还提供了用于创建和使用可观察者的实用函数。这些实用函数可用于：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8uz6o9m2vb8jrgch3j6yb5tf\">将现有异步操作代码转换为可观察者</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ayyao4s960piqnbe78h2n9xq\">遍历流中的值</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"can9as43ly37mceqffp2d1d61\">将值映射到不同的类型</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e8t8rhm99fmosbn17bduhp4u0\">过滤流</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c1vmdo7h9e1zy5j63hbyka23e\">组合多个流</li>\n</ul>\n<h2 id=\"observable-creation-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9fdwaf1uudsdkfrj1l5n2noyg\"><i class=\"material-icons\">link</i>可观察者创建函数</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4usqv7craoyh5c18yeo1mu3s\">RxJS 提供了许多函数，可用于创建新的可观察者。这些函数可以简化从事件、计时器、Promise 等创建可观察者的过程。例如：</p>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"promise\" title=\"Create an observable from a promise\">\n\nimport { fromPromise } from 'rxjs/observable/fromPromise';\n\n// Create an Observable out of <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> promise\nconst data = fromPromise(fetch('/api/endpoint'));\n// Subscribe to begin listening for <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> result\ndata.subscribe({\n next(response) { console.log(response); },\n error(err) { console.error('Error: ' + err); },\n complete() { console.log('Completed'); }\n});\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"interval\" title=\"Create an observable from a counter\">\n\nimport { interval } from 'rxjs/observable/interval';\n\n// Create an Observable that will publish <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> value on an interval\nconst secondsCounter = interval(1000);\n// Subscribe to begin publishing values\nsecondsCounter.subscribe(n =&gt;\n  console.log(`It's been ${n} seconds since subscribing!`));\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"event\" title=\"Create an observable from an event\">\n\nimport { fromEvent } from 'rxjs/observable/fromEvent';\n\nconst el = document.getElementById('my-element');\n\n// Create an Observable that will publish mouse movements\nconst mouseMoves = fromEvent(el, 'mousemove');\n\n// Subscribe to start listening for mouse-move events\nconst subscription = mouseMoves.subscribe((evt: MouseEvent) =&gt; {\n  // Log coords of mouse movements\n  console.log(`Coords: ${evt.clientX} X ${evt.clientY}`);\n\n  // When the mouse is over the upper-left of the screen,\n  // unsubscribe to stop listening for mouse movements\n  if (evt.clientX &lt; 40 &amp;&amp; evt.clientY &lt; 40) {\n    subscription.unsubscribe();\n  }\n});\n\n\n</code-example>\n<code-example path=\"rx-library/src/simple-creation.ts\" region=\"ajax\" title=\"Create an observable that creates an AJAX request\">\n\nimport { ajax } from 'rxjs/observable/dom/ajax';\n\n// Create an Observable that will create an AJAX request\nconst apiData = ajax('/api/data');\n// Subscribe to create the request\napiData.subscribe(res =&gt; console.log(res.status, res.response));\n\n\n</code-example>\n<h2 id=\"operators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"an57klyawyw99dnz7jlqbaqbm\"><i class=\"material-icons\">link</i>操作符</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5engw2f3au3twucpmz4p9milm\">操作符是基于可观察者基础构建的函数，可以对集合进行复杂的操纵。例如，RxJS 定义了 \n<code>map()</code>、\n<code>filter()</code>、\n<code>concat()</code> 和 \n<code>flatMap()</code> 等操作符。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c55z3azbotd9jirzow27bqntg\">操作符接受配置选项，并返回一个接受源可观察者的函数。在执行此返回的函数时，操作符会观察源可观察者的发射值，对其进行转换，并返回一个包含这些转换值的新可观察者。这是一个简单的示例：</p>\n<code-example path=\"rx-library/src/operators.ts\" title=\"Map operator\">\n\nimport { map } from 'rxjs/operators';\n\nconst nums = Observable.of(1, 2, 3);\n\nconst squareValues = map((val: number) =&gt; val * val);\nconst squaredNums = squareValues(nums);\n\nsquaredNums.subscribe(x =&gt; console.log(x));\n\n// Logs\n// 1\n// 4\n// 9\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ceum4trsusvnnptg4z4aoaxz\">你可以使用\n<em>管道</em>将操作符链接在一起。管道允许你将多个函数组合成一个函数。\n<code>pipe()</code> 函数将你想要组合的函数作为参数，并返回一个新函数，该函数在执行时会按顺序运行组合的函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7rp7cy0w6ivgt17ae2btlrjsj\">应用于可观察者的一组操作符是一个配方，即一组用于生成你感兴趣的值的指令。配方本身不会做任何事情。你需要调用 \n<code>subscribe()</code> 来通过配方生成结果。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"694j2q0e3sjq6g51w51ybdsj5\">这是一个例子：</p>\n<code-example path=\"rx-library/src/operators.1.ts\" title=\"Standalone pipe function\">\n\nimport { pipe } from 'rxjs/util/pipe';\nimport { filter, map } from 'rxjs/operators';\n\nconst nums = Observable.of(1, 2, 3, 4, 5);\n\n// Create <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> function that accepts an Observable.\nconst squareOddVals = pipe(\n  filter(n =&gt; n % 2),\n  map(n =&gt; n * n)\n);\n\n// Create an Observable that will run the filter and map functions\nconst squareOdd = squareOddVals(nums);\n\n// Suscribe to run the combined functions\nsquareOdd.subscribe(x =&gt; console.log(x));\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55ii4jd29k0s4rgdd58gypd66\"><code>pipe()</code> 函数也是 RxJS \n<code>Observable</code> 上的一个方法，因此你可以使用这种更短的形式来定义相同的操作：</p>\n<code-example path=\"rx-library/src/operators.2.ts\" title=\"Observable.pipe function\">\n\nimport { filter } from 'rxjs/operators/filter';\nimport { map } from 'rxjs/operators/map';\n\nconst squareOdd = Observable.of(1, 2, 3, 4, 5)\n  .pipe(\n    filter(n =&gt; n % 2 !== 0),\n    map(n =&gt; n * n)\n  );\n\n// Subscribe to get values\nsquareOdd.subscribe(x =&gt; console.log(x));\n\n\n</code-example>\n<h3 id=\"common-operators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"78g2qp12pizac8tokqsl3okne\"><i class=\"material-icons\">link</i>常用操作符</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1b85qpzq68fko9ooud7i788d4\">RxJS 提供了许多操作符（超过 150 个），但只有少数几个经常使用。以下是一些常用操作符的列表；有关使用示例，请参阅 RxJS 文档中的 \n<a href=\"https://github.com/btroncone/learn-rxjs/blob/master/operators/complete.md\">RxJS 5 Operators By Example</a>。</p>\n<div class=\"l-sub-section\">\n  Note that, for Angular apps, we prefer combining operators with pipes, rather than chaining. Chaining is used in many RxJS examples.\n</div>\n<table>\n<thead>\n<tr>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d742luiuirvtpjq6i9pf70lxw\">区域</th>\n<th align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"an57klyawyw99dnz7jlqbaqbm\">操作符</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65aoee8m9iko3yov1zjh599wy\">创建</td>\n<td align=\"left\"><code>from</code>\n, \n<code>fromPromise</code>\n,\n<code>fromEvent</code>\n, \n<code>of</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48rahxmxpog6m0gafxeklkgvv\">组合</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"z40vkcoe46feuqmih3hhsrdo\"><code>combineLatest</code> , \n<code>concat</code> , \n<code>merge</code> , \n<code>startWith</code> , \n<code>withLatestFrom</code> , \n<code>zip</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"94ye9s2javqh643hiahgawu6w\">过滤</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dxezceyjk6pkit11jc69odd0q\"><code>debounceTime</code> , \n<code>distinctUntilChanged</code> , \n<code>filter</code> , \n<code>take</code> , \n<code>takeUntil</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"72ukel3br3qslodz8jbw6u19b\">转换</td>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2f2ru5njau0d9b8r3m1yvyg3\"><code>bufferTime</code> , \n<code>concatMap</code> , \n<code>map</code> , \n<code>mergeMap</code> , \n<code>scan</code> , \n<code>switchMap</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8tadsrgfaa9f0q28cmet8e9fd\">实用工具</td>\n<td align=\"left\"><code>tap</code></td>\n</tr>\n<tr>\n<td align=\"left\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"75w6lif46mxdlj13k02e4kbzg\">多播</td>\n<td align=\"left\"><code>share</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"error-handling\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ad0cx4y7txhii62pgdd0mpma9\"><i class=\"material-icons\">link</i>错误处理</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d0t26l7awxevxrv17psh2m8q9\">除了你在订阅时提供的 \n<code>error()</code> 处理程序之外，RxJS 还提供了 \n<code>catchError</code> 操作符，它允许你在可观察者配方中处理已知的错误。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5op3sc5gl7codk0bhh9ibsk7q\">例如，假设你有一个可观察者，它发出一个 API 请求并映射到来自服务器的响应。如果服务器返回错误或值不存在，则会产生错误。如果你捕获此错误并提供一个默认值，则你的流将继续处理值，而不是出错。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ahv12o9k7thsjqjxyuoc4hlay\">以下是如何使用 \n<code>catchError</code> 操作符来实现这一点的示例：</p>\n<code-example path=\"rx-library/src/error-handling.ts\" title=\"catchError operator\">\n\nimport { ajax } from 'rxjs/observable/dom/ajax';\nimport { map, catchError } from 'rxjs/operators';\n// Return \"response\" from the API. If an error happens,\n// return an empty array.\nconst apiData = ajax('/api/data').pipe(\n  map(res =&gt; {\n    if (!res.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  catchError(err =&gt; Observable.of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log('data: ', x); },\n  error(err) { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<h3 id=\"retry-failed-observable\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"74w470n1ay7a5lj6iddro8tnz\"><i class=\"material-icons\">link</i>重试失败的可观察者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"82eg4udsgxnmsmjkngpst76m9\"><code>catchError</code> 操作符提供了一个简单的恢复路径，而 \n<code>retry</code> 操作符允许你重试失败的请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"47pizqp668yoqiy2nxpp6jw60\">在 \n<code>catchError</code> 操作符之前使用 \n<code>retry</code> 操作符。它会重新订阅原始源可观察者，这将重新运行导致错误的完整操作序列。如果这包括一个 HTTP 请求，它将重试该 HTTP 请求。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cb4et1uhw0poe1xf8yk1rxoql\">以下将前面的示例转换为在捕获错误之前重试请求：</p>\n<code-example path=\"rx-library/src/retry-on-error.ts\" title=\"retry operator\">\n\nimport { ajax } from 'rxjs/observable/dom/ajax';\nimport { map, retry, catchError } from 'rxjs/operators';\n\nconst apiData = ajax('/api/data').pipe(\n  retry(3), // Retry up to 3 times before failing\n  map(res =&gt; {\n    if (!res.response) {\n      throw new Error('Value expected!');\n    }\n    return res.response;\n  }),\n  catchError(err =&gt; Observable.of([]))\n);\n\napiData.subscribe({\n  next(x) { console.log('data: ', x); },\n  error(err) { console.log('errors already caught... will not run'); }\n});\n\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7b0kcji5jvvcap8xge4rxoule\">不要重试\n<strong>身份验证</strong>请求，因为这些请求应该只由用户操作发起。我们不希望用用户未发起的重复登录请求锁定用户帐户。</p>\n</div>\n<h2 id=\"naming-conventions-for-observables\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8v08yzzckvuqsgqvxx7l7wj04\"><i class=\"material-icons\">link</i>可观察者的命名约定</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8jyj80re9bti86rio3ojqtocz\">由于 Angular 应用程序主要用 TypeScript 编写，因此你通常会知道何时一个变量是可观察者。虽然 Angular 框架没有强制执行可观察者的命名约定，但你经常会看到可观察者以“$”符号结尾。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4041a38t3u0j82xnr6kxwcdse\">这在扫描代码并查找可观察者值时很有用。此外，如果你想使用一个属性来存储来自可观察者的最新值，则简单地使用相同名称（带或不带“$”）会很方便。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4reizjf10jcs1ftw359bt1ndz\">比如：</p>\n<code-example path=\"rx-library/src/naming-convention.ts\" title=\"Naming observables\">\n\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-stopwatch',\n  templateUrl: './stopwatch.component.html'\n})\nexport class StopwatchComponent {\n\n  stopwatchValue: number;\n  stopwatchValue$: Observable&lt;number&gt;;\n\n  start() {\n    this.stopwatchValue$.subscribe(num =&gt;\n      this.stopwatchValue = num\n    );\n  }\n}\n\n\n</code-example>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/testing/async\n - api/router/RouterLinkWithHref\n - guide/rx-library#common-operators\n - guide/rx-library#error-handling\n - guide/rx-library#naming-conventions-for-observables\n - guide/rx-library#observable-creation-functions\n - guide/rx-library#operators\n - guide/rx-library#retry-failed-observable\n - guide/rx-library#the-rxjs-library\n - http://reactivex.io/rxjs/\n - https://en.wikipedia.org/wiki/Reactive_programming\n - https://github.com/btroncone/learn-rxjs/blob/master/operators/complete.md\n-->"
}