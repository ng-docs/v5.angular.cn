{
  "id": "guide/form-validation",
  "title": "Form Validation",
  "contents": "\n<div class=\"content\">\n<h1 id=\"form-validation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#form-validation\"><i class=\"material-icons\">link</i></a>Form Validation</h1>\n<p>Improve overall data quality by validating user input for accuracy and completeness.</p>\n<p>This page shows how to validate user input in the UI and display useful validation messages\nusing both reactive and template-driven forms. It assumes some basic knowledge of the two\nforms modules.</p>\n<div class=\"l-sub-section\">\n<p>If you're new to forms, start by reviewing the <a href=\"guide/forms\">Forms</a> and\n<a href=\"guide/reactive-forms\">Reactive Forms</a> guides.</p>\n</div>\n<h2 id=\"template-driven-validation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#template-driven-validation\"><i class=\"material-icons\">link</i></a>Template-driven validation</h2>\n<p>To add validation to a template-driven form, you add the same validation attributes as you\nwould with <a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation\">native HTML form validation</a>.\nAngular uses directives to match these attributes with validator functions in the framework.</p>\n<p>Every time the value of a form control changes, Angular runs validation and generates\neither a list of validation errors, which results in an INVALID status, or null, which results in a VALID status.</p>\n<p>You can then inspect the control's state by exporting <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> to a local template variable.\nThe following example exports <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> into a variable called <code>name</code>:</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-with-error-msg\" title=\"template/hero-form-template.component.html (name)\" linenums=\"false\">\n&#x3C;input id=\"name\" name=\"name\" class=\"form-control\"\n       required <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\" appForbiddenName=\"bob\"\n       [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\" >\n\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &#x26;&#x26; (name.dirty || name.touched)\"\n     class=\"alert alert-danger\">\n\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.required\">\n    Name is required.\n  &#x3C;/div>\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.minlength\">\n    Name must be at least 4 characters long.\n  &#x3C;/div>\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.forbiddenName\">\n    Name cannot be Bob.\n  &#x3C;/div>\n\n&#x3C;/div>\n\n</code-example>\n<p>Note the following:</p>\n<ul>\n<li>\n<p>The <code>&#x3C;input></code> element carries the HTML validation attributes: <code>required</code> and <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>. It\nalso carries a custom validator directive, <code>forbiddenName</code>. For more\ninformation, see <a href=\"guide/form-validation#custom-validators\">Custom validators</a> section.</p>\n</li>\n<li>\n<p><code>#name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"</code> exports <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> into a local variable called <code>name</code>. <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> mirrors many of the properties of its underlying\n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance, so you can use this in the template to check for control states such as <code>valid</code> and <code>dirty</code>. For a full list of control properties, see the <a href=\"api/forms/AbstractControl\">AbstractControl</a>\nAPI reference.</p>\n</li>\n<li>\n<p>The <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> on the <code>&#x3C;div></code> element reveals a set of nested message <code>divs</code>\nbut only if the <code>name</code> is invalid and the control is either <code>dirty</code> or <code>touched</code>.</p>\n</li>\n<li>\n<p>Each nested <code>&#x3C;div></code> can present a custom message for one of the possible validation errors.\nThere are messages for <code>required</code>, <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>, and <code>forbiddenName</code>.\n</p>\n</li>\n</ul>\n<div class=\"l-sub-section\">\n<h4 id=\"why-check-dirty-and-touched\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#why-check-dirty-and-touched\"><i class=\"material-icons\">link</i></a>Why check <em>dirty</em> and <em>touched</em>?</h4>\n<p>You may not want your application to display errors before the user has a chance to edit the form.\nThe checks for <code>dirty</code> and <code>touched</code> prevent errors from showing until the user\ndoes one of two things: changes the value,\nturning the control dirty; or blurs the form control element, setting the control to touched.</p>\n</div>\n<h2 id=\"reactive-form-validation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#reactive-form-validation\"><i class=\"material-icons\">link</i></a>Reactive form validation</h2>\n<p>In a reactive form, the source of truth is the component class. Instead of adding validators through attributes in the template, you add validator functions directly to the form control model in the component class. Angular then calls these functions whenever the value of the control changes.</p>\n<h3 id=\"validator-functions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#validator-functions\"><i class=\"material-icons\">link</i></a>Validator functions</h3>\n<p>There are two types of validator functions: sync validators and async validators.  </p>\n<ul>\n<li>\n<p><strong>Sync validators</strong>: functions that take a control instance and immediately return either a set of validation errors or <code>null</code>. You can pass these in as the second argument when you instantiate a <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>.</p>\n</li>\n<li>\n<p><strong>Async validators</strong>: functions that take a control instance and return a Promise\nor Observable that later emits a set of validation errors or <code>null</code>. You can\npass these in as the third argument when you instantiate a <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>. </p>\n</li>\n</ul>\n<p>Note: for performance reasons, Angular only runs async validators if all sync validators pass. Each must complete before errors are set.</p>\n<h3 id=\"built-in-validators\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#built-in-validators\"><i class=\"material-icons\">link</i></a>Built-in validators</h3>\n<p>You can choose to <a href=\"guide/form-validation#custom-validators\">write your own validator functions</a>, or you can use some of\nAngular's built-in validators. </p>\n<p>The same built-in validators that are available as attributes in template-driven forms, such as <code>required</code> and <code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>, are all available to use as functions from the <code><a href=\"api/forms/Validators\" class=\"code-anchor\">Validators</a></code> class. For a full list of built-in validators, see the <a href=\"api/forms/Validators\">Validators</a> API reference.</p>\n<p>To update the hero form to be a reactive form, you can use some of the same\nbuilt-in validators—this time, in function form. See below:</p>\n<a id=\"reactive-component-class\"></a>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\" region=\"form-group\" title=\"reactive/hero-form-reactive.component.ts (validator functions)\" linenums=\"false\">\nngOnInit(): void {\n  this.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n    'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n      Validators.required,\n      Validators.minLength(4),\n      forbiddenNameValidator(/bob/i) // &#x3C;-- Here's how you pass in the custom validator.\n    ]),\n    'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n    'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required)\n  });\n}\n\nget name() { return this.heroForm.get('name'); }\n\nget power() { return this.heroForm.get('power'); }\n\n</code-example>\n<p>Note that:</p>\n<ul>\n<li>The name control sets up two built-in validators—<code>Validators.required</code> and <code>Validators.minLength(4)</code>—and one custom validator, <code>forbiddenNameValidator</code>. For more details see the <a href=\"guide/form-validation#custom-validators\">Custom validators</a> section in this guide.</li>\n<li>As these validators are all sync validators, you pass them in as the second argument. </li>\n<li>Support multiple validators by passing the functions in as an array.</li>\n<li>This example adds a few getter methods. In a reactive form, you can always access any form control through the <code>get</code> method on its parent group, but sometimes it's useful to define getters as shorthands\nfor the template.</li>\n</ul>\n<p>If you look at the template for the name input again, it is fairly similar to the template-driven example. </p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"name-with-error-msg\" title=\"reactive/hero-form-reactive.component.html (name with error msg)\" linenums=\"false\">\n&#x3C;input id=\"name\" class=\"form-control\"\n       <a href=\"api/forms/FormControlName\" class=\"code-anchor\">formControlName</a>=\"name\" required >\n\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &#x26;&#x26; (name.dirty || name.touched)\"\n     class=\"alert alert-danger\">\n\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.required\">\n    Name is required.\n  &#x3C;/div>\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.minlength\">\n    Name must be at least 4 characters long.\n  &#x3C;/div>\n  &#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.forbiddenName\">\n    Name cannot be Bob.\n  &#x3C;/div>\n&#x3C;/div>\n\n</code-example>\n<p>Key takeaways:</p>\n<ul>\n<li>The form no longer exports any directives, and instead uses the <code>name</code> getter defined in\nthe component class.</li>\n<li>The <code>required</code> attribute is still present. While it's not necessary for validation purposes,\nyou may want to keep it in your template for CSS styling or accessibility reasons.</li>\n</ul>\n<h2 id=\"custom-validators\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#custom-validators\"><i class=\"material-icons\">link</i></a>Custom validators</h2>\n<p>Since the built-in validators won't always match the exact use case of your application, sometimes you'll want to create a custom validator. </p>\n<p>Consider the <code>forbiddenNameValidator</code> function from previous\n<a href=\"guide/form-validation#reactive-component-class\">examples</a> in\nthis guide. Here's what the definition of that function looks like:</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"custom-validator\" title=\"shared/forbidden-name.directive.ts (forbiddenNameValidator)\" linenums=\"false\">\n/** A hero's name can't match the given regular expression */\nexport function forbiddenNameValidator(nameRe: RegExp): <a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a> {\n  return (control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): {[key: string]: any} => {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? {'forbiddenName': {value: control.value}} : null;\n  };\n}\n\n</code-example>\n<p>The function is actually a factory that takes a regular expression to detect a <em>specific</em> forbidden name and returns a validator function.</p>\n<p>In this sample, the forbidden name is \"bob\", so the validator will reject any hero name containing \"bob\".\nElsewhere it could reject \"alice\" or any name that the configuring regular expression matches.</p>\n<p>The <code>forbiddenNameValidator</code> factory returns the configured validator function.\nThat function takes an Angular control object and returns <em>either</em>\nnull if the control value is valid <em>or</em> a validation error object.\nThe validation error object typically has a property whose name is the validation key, <code>'forbiddenName'</code>,\nand whose value is an arbitrary dictionary of values that you could insert into an error message, <code>{name}</code>.</p>\n<p>Custom async validators are similar to sync validators, but they must instead return a Promise or Observable\nthat later emits null or a validation error object. In the case of an Observable, the Observable must complete,\nat which point the form uses the last value emitted for validation.</p>\n<h3 id=\"adding-to-reactive-forms\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-to-reactive-forms\"><i class=\"material-icons\">link</i></a>Adding to reactive forms</h3>\n<p>In reactive forms, custom validators are fairly simple to add. All you have to do is pass the function directly\nto the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code>.</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\" region=\"custom-validator\" title=\"reactive/hero-form-reactive.component.ts (validator functions)\" linenums=\"false\">\nthis.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    forbiddenNameValidator(/bob/i) // &#x3C;-- Here's how you pass in the custom validator.\n  ]),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required)\n});\n\n</code-example>\n<h3 id=\"adding-to-template-driven-forms\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#adding-to-template-driven-forms\"><i class=\"material-icons\">link</i></a>Adding to template-driven forms</h3>\n<p>In template-driven forms, you don't have direct access to the <code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> instance, so you can't pass the\nvalidator in like you can for reactive forms. Instead, you need to add a directive to the template.</p>\n<p>The corresponding <code>ForbiddenValidatorDirective</code> serves as a wrapper around the <code>forbiddenNameValidator</code>.</p>\n<p>Angular recognizes the directive's role in the validation process because the directive registers itself\nwith the <code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> provider, a provider with an extensible collection of validators.</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive-providers\" title=\"shared/forbidden-name.directive.ts (providers)\" linenums=\"false\">\nproviders: [{provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>, useExisting: ForbiddenValidatorDirective, multi: true}]\n\n</code-example>\n<p>The directive class then implements the <code><a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a></code> interface, so that it can easily integrate\nwith Angular forms. Here is the rest of the directive to help you get an idea of how it all\ncomes together:</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive\" title=\"shared/forbidden-name.directive.ts (directive)\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appForbiddenName]',\n  providers: [{provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>, useExisting: ForbiddenValidatorDirective, multi: true}]\n})\nexport class ForbiddenValidatorDirective implements <a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appForbiddenName') forbiddenName: string;\n\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): {[key: string]: any} {\n    return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)\n                              : null;\n  }\n}\n\n</code-example>\n<p>Once the <code>ForbiddenValidatorDirective</code> is ready, you can simply add its selector, <code>appForbiddenName</code>, to any input element to activate it. For example:</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-input\" title=\"template/hero-form-template.component.html (forbidden-name-input)\" linenums=\"false\">\n&#x3C;input id=\"name\" name=\"name\" class=\"form-control\"\n       required <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\" appForbiddenName=\"bob\"\n       [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\" >\n\n</code-example>\n<div class=\"l-sub-section\">\n<p>You may have noticed that the custom validation directive is instantiated with <code>useExisting</code>\nrather than <code>useClass</code>. The registered validator must be <em>this instance</em> of\nthe <code>ForbiddenValidatorDirective</code>—the instance in the form with\nits <code>forbiddenName</code> property bound to “bob\". If you were to replace\n<code>useExisting</code> with <code>useClass</code>, then you’d be registering a new class instance, one that\ndoesn’t have a <code>forbiddenName</code>.</p>\n</div>\n<h2 id=\"control-status-css-classes\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/form-validation#control-status-css-classes\"><i class=\"material-icons\">link</i></a>Control status CSS classes</h2>\n<p>Like in AngularJS, Angular automatically mirrors many control properties onto the form control element as CSS classes. You can use these classes to style form control elements according to the state of the form. The following classes are currently supported:</p>\n<ul>\n<li><code>.ng-valid</code></li>\n<li><code>.ng-invalid</code></li>\n<li><code>.ng-pending</code></li>\n<li><code>.ng-pristine</code></li>\n<li><code>.ng-dirty</code></li>\n<li><code>.ng-untouched</code></li>\n<li><code>.ng-touched</code></li>\n</ul>\n<p>The hero form uses the <code>.ng-valid</code> and <code>.ng-invalid</code> classes to\nset the color of each form control's border.</p>\n<code-example path=\"form-validation/src/assets/forms.css\" title=\"forms.css (status classes)\">\n\n.ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n\n\n</code-example>\n<p><strong>You can run the <live-example></live-example> to see the complete reactive and template-driven example code.</strong></p>\n\n</div>\n<!-- links to this doc:\n - guide/reactive-forms\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core/Directive\n - api/core/Input\n - api/forms/AbstractControl\n - api/forms/FormControl\n - api/forms/FormControlName\n - api/forms/FormGroup\n - api/forms/MinLengthValidator\n - api/forms/NG_VALIDATORS\n - api/forms/NgModel\n - api/forms/Validator\n - api/forms/ValidatorFn\n - api/forms/Validators\n - guide/form-validation#adding-to-reactive-forms\n - guide/form-validation#adding-to-template-driven-forms\n - guide/form-validation#built-in-validators\n - guide/form-validation#control-status-css-classes\n - guide/form-validation#custom-validators\n - guide/form-validation#form-validation\n - guide/form-validation#reactive-component-class\n - guide/form-validation#reactive-form-validation\n - guide/form-validation#template-driven-validation\n - guide/form-validation#validator-functions\n - guide/form-validation#why-check-dirty-and-touched\n - guide/forms\n - guide/reactive-forms\n - https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation\n-->"
}