{
  "id" : "guide/form-validation",
  "title" : "表单验证",
  "contents" : "<div class=\"content\">\n<h1 id=\"form-validation\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4jbzhk81rf9f1scbcmnccgjky\"><i class=\"material-icons\">link</i>表单验证</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c00rpnviuewfg0jgouh7tkzgf\">通过验证用户输入的准确性和完整性来提高整体数据质量。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dhya3c64yp01fd3yrzvv6ik6v\">此页面展示了如何在 UI 中验证用户输入，并使用响应式表单和模板驱动表单显示有用的验证消息。它假设你对这两个表单模块有一些基本了解。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"45t9vke49oki4ecr0yp8x9b4\">如果你不熟悉表单，请先查看 \n<a href=\"guide/forms\">表单</a> 和 \n<a href=\"guide/reactive-forms\">响应式表单</a> 指南。</p>\n</div>\n<h2 id=\"template-driven-validation\">Template-driven validation</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3770y29knbri9p6bonfo419v9\">要向模板驱动表单添加验证，你需要添加与使用 \n<a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation\">原生 HTML 表单验证</a> 相同的验证属性。Angular 使用指令将这些属性与框架中的验证器函数匹配。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"au3sprq4vzp63a8h2q1o55b88\">每次表单控件的值发生变化时，Angular 都会运行验证，并生成一个验证错误列表（导致 INVALID 状态）或 null（导致 VALID 状态）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23iym1j7axg1x9hy31gnr8es4\">然后，你可以通过将 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 导出到本地模板变量来检查控件的状态。以下示例将 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 导出到名为 \n<code>name</code> 的变量中：</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-with-error-msg\" title=\"template/hero-form-template.component.html (name)\" linenums=\"false\">\n&lt;input id=\"name\" name=\"name\" class=\"form-control\"\n       required <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\" appForbiddenName=\"bob\"\n       [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\" &gt;\n\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &amp;&amp; (name.dirty || name.touched)\"\n     class=\"alert alert-danger\"&gt;\n\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.required\"&gt;\n    Name is required.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.minlength\"&gt;\n    Name must be at least 4 characters long.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.forbiddenName\"&gt;\n    Name cannot be Bob.\n  &lt;/div&gt;\n\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c9nsd32oev8x6qkc13baeioq9\">注意以下几点：</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6sjxcg8wz8fd380ayznf6ugnr\"><code>&lt;input&gt;</code> 元素包含 HTML 验证属性：\n<code>required</code> 和 \n<code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>。它还包含一个自定义验证器指令 \n<code>forbiddenName</code>。有关更多信息，请参阅 \n<a href=\"guide/form-validation#custom-validators\">自定义验证器</a> 部分。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ews7uxvazxtnsxn8ix2rjbeog\"><code>#name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\"</code> 将 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 导出到名为 \n<code>name</code> 的本地变量中。\n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> 反映了其底层 \n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例的许多属性，因此你可以在模板中使用它来检查控件状态，例如 \n<code>valid</code> 和 \n<code>dirty</code>。有关控件属性的完整列表，请参阅 \n<a href=\"api/forms/AbstractControl\">AbstractControl</a> API 参考。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6ll6r8oevqc2qfmtsdvd0zdxy\"><code>&lt;div&gt;</code> 元素上的 \n<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> 显示一组嵌套的消息 \n<code>div</code>，但前提是 \n<code>name</code> 无效，并且控件处于 \n<code>dirty</code> 或 \n<code>touched</code> 状态。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ak3xex3v7wgdzatfei6r9qzbr\">每个嵌套的 \n<code>&lt;div&gt;</code> 可以为可能的验证错误之一提供自定义消息。有针对 \n<code>required</code>、\n<code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code> 和 \n<code>forbiddenName</code> 的消息。</p>\n</li>\n</ul>\n<div class=\"l-sub-section\">\n<h4 id=\"why-check-dirty-and-touched\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4e8f1rwnsnhknnmogi8c8c4i3\"><i class=\"material-icons\">link</i>为什么要检查 \n<em>dirty</em> 和 \n<em>touched</em>？</h4>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ati0brh69rzgpspo0k069nwey\">你可能不希望应用程序在用户有机会编辑表单之前显示错误。对 \n<code>dirty</code> 和 \n<code>touched</code> 的检查可以防止错误在用户执行以下两项操作之一之前显示：更改值，使控件变为 dirty；或将焦点从表单控件元素上移开，将控件设置为 touched。</p>\n</div>\n<h2 id=\"reactive-form-validation\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dhgfy0fan2iu7nf9sbtcss9w4\"><i class=\"material-icons\">link</i>响应式表单验证</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eresob17no06jy2x0xzuhm07r\">在响应式表单中，事实之源是组件类。你无需在模板中通过属性添加验证器，而是直接在组件类中的表单控件模型中添加验证器函数。然后，Angular 会在控件的值发生变化时调用这些函数。</p>\n<h3 id=\"validator-functions\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"amf6d696khzdbvd2xpvhh26ly\"><i class=\"material-icons\">link</i>验证器（Validator）函数</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1uk62gxigik1js2iatqtziqqx\">验证器函数有两种类型：同步验证器和异步验证器。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"atvxqxb1l0jo34lxg3va1plnb\"><strong>同步验证器</strong>：接受控件实例并立即返回一组验证错误或 \n<code>null</code> 的函数。在实例化 \n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 时，你可以将这些函数作为第二个参数传递。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f44wnx98dpjwcz14atkc2lf5g\"><strong>异步验证器</strong>：接受控件实例并返回一个 Promise 或 Observable，该 Promise 或 Observable 稍后会发出验证错误集或 \n<code>null</code> 的函数。在实例化 \n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 时，你可以将这些函数作为第三个参数传递。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"apwioxdwifnfwfjxezxdrz8vv\">注意：出于性能原因，Angular 仅在所有同步验证器都通过时才会运行异步验证器。每个验证器都必须完成，然后才能设置错误。</p>\n<h3 id=\"built-in-validators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bps5i1ke1omce0bx6hxhlfd61\"><i class=\"material-icons\">link</i>内置验证器</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"blr9vk50o15og2e4shcndw6tl\">你可以选择 \n<a href=\"guide/form-validation#custom-validators\">编写自己的验证器函数</a>，也可以使用 Angular 的一些内置验证器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8cyzc9r9sybvgdq304q9qzvpb\">与模板驱动表单中作为属性可用的内置验证器（例如 \n<code>required</code> 和 \n<code><a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a></code>）相同，所有这些验证器都可以在 \n<code><a href=\"api/forms/Validators\" class=\"code-anchor\">Validators</a></code> 类中作为函数使用。有关内置验证器的完整列表，请参阅 \n<a href=\"api/forms/Validators\">Validators</a> API 参考。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"clg19arfkz12r4u2okmemkn2s\">要将英雄表单更新为响应式表单，你可以使用一些相同的内置验证器——这次以函数形式。请参见以下内容：</p>\n<a id=\"reactive-component-class\"></a>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\" region=\"form-group\" title=\"reactive/hero-form-reactive.component.ts (validator functions)\" linenums=\"false\">\nngOnInit(): void {\n  this.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n    'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n      Validators.required,\n      Validators.minLength(4),\n      forbiddenNameValidator(/bob/i) // &lt;-- Here's how you pass in the custom validator.\n    ]),\n    'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n    'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required)\n  });\n}\n\nget name() { return this.heroForm.get('name'); }\n\nget power() { return this.heroForm.get('power'); }\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2njxfwczp6kc1fknmqwnbiv5s\">注意：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9mmz7mkjxx9h3sn8pad1o4q80\">name 控件设置了两个内置验证器——\n<code>Validators.required</code> 和 \n<code>Validators.minLength(4)</code>——以及一个自定义验证器 \n<code>forbiddenNameValidator</code>。有关更多详细信息，请参阅本指南中的 \n<a href=\"guide/form-validation#custom-validators\">自定义验证器</a> 部分。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"crkafwl6ole9k0k1yprac8v1j\">由于这些验证器都是同步验证器，因此你将它们作为第二个参数传递。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4gg91xivak7q3p23swe9enrlb\">通过将函数作为数组传递来支持多个验证器。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"21j215v7cw2a98mm24lbvgi28\">此示例添加了一些 getter 方法。在响应式表单中，你始终可以通过其父组上的 \n<code>get</code> 方法访问任何表单控件，但有时定义 getter 作为模板的简写会很有用。</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6h3vxec6hoc214c1bw03xtvmo\">如果你再次查看 name 输入的模板，你会发现它与模板驱动示例非常相似。</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.html\" region=\"name-with-error-msg\" title=\"reactive/hero-form-reactive.component.html (name with error msg)\" linenums=\"false\">\n&lt;input id=\"name\" class=\"form-control\"\n       <a href=\"api/forms/FormControlName\" class=\"code-anchor\">formControlName</a>=\"name\" required &gt;\n\n&lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.invalid &amp;&amp; (name.dirty || name.touched)\"\n     class=\"alert alert-danger\"&gt;\n\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.required\"&gt;\n    Name is required.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.minlength\"&gt;\n    Name must be at least 4 characters long.\n  &lt;/div&gt;\n  &lt;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"name.errors.forbiddenName\"&gt;\n    Name cannot be Bob.\n  &lt;/div&gt;\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ezotcil2eeelhtesbichg7b8j\">主要要点：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"11jskxavwpivsb5822ehpt47k\">表单不再导出任何指令，而是使用组件类中定义的 \n<code>name</code> getter。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"225zfg1eb0ojajab8jhmpjoj\"><code>required</code> 属性仍然存在。虽然它对于验证目的不是必需的，但你可能希望将其保留在模板中，以用于 CSS 样式或无障碍性原因。</li>\n</ul>\n<h2 id=\"custom-validators\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4bzl9glddeu1deu58inqnrlh1\"><i class=\"material-icons\">link</i>自定义验证器</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5z039gwnvnnhq1w8dqov06om5\">由于内置验证器并不总是能满足应用程序的具体用例，因此有时你需要创建自定义验证器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7u1vc7x0qpvbc2jg1v9dgvnpf\">考虑本指南中先前 \n<a href=\"guide/form-validation#reactive-component-class\">示例</a> 中的 \n<code>forbiddenNameValidator</code> 函数。以下是该函数的定义：</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"custom-validator\" title=\"shared/forbidden-name.directive.ts (forbiddenNameValidator)\" linenums=\"false\">\n/** A hero's name can't match the given regular expression */\nexport function forbiddenNameValidator(nameRe: RegExp): <a href=\"api/forms/ValidatorFn\" class=\"code-anchor\">ValidatorFn</a> {\n  return (control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): {[key: string]: any} =&gt; {\n    const forbidden = nameRe.test(control.value);\n    return forbidden ? {'forbiddenName': {value: control.value}} : null;\n  };\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlihcyk6ycifnn2h7vdfo0s52\">该函数实际上是一个工厂，它接受一个正则表达式来检测\n<em>特定</em>的禁止名称，并返回一个验证器函数。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"97117k5cmuruyiwshaqi3dnbi\">在此示例中，禁止的名称是“bob”，因此验证器将拒绝任何包含“bob”的英雄名称。在其他地方，它可能会拒绝“alice”或配置的正则表达式匹配的任何名称。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"pm1hi9hqs6ze3inhsrjwwnid\"><code>forbiddenNameValidator</code> 工厂返回配置的验证器函数。该函数接受一个 Angular 控件对象，并返回\n<em>要么</em>为 null（如果控件值有效）\n<em>要么</em>为验证错误对象。验证错误对象通常具有一个属性，其名称是验证键 \n<code>'forbiddenName'</code>，其值为你可以插入错误消息的任意字典，\n<code>{name}</code>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mjleunj3bg765nijaoywfpql\">自定义异步验证器类似于同步验证器，但它们必须返回一个 Promise 或 Observable，该 Promise 或 Observable 稍后会发出 null 或验证错误对象。在 Observable 的情况下，Observable 必须完成，此时表单使用最后发出的值进行验证。</p>\n<h3 id=\"adding-to-reactive-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hh0bpbi3a4w6sp6489oh1sv5\"><i class=\"material-icons\">link</i>添加到响应式表单</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4hen9wznpqsc1gxllwqe6i25f\">在响应式表单中，添加自定义验证器非常简单。你只需将函数直接传递给 \n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 即可。</p>\n<code-example path=\"form-validation/src/app/reactive/hero-form-reactive.component.ts\" region=\"custom-validator\" title=\"reactive/hero-form-reactive.component.ts (validator functions)\" linenums=\"false\">\nthis.heroForm = new <a href=\"api/forms/FormGroup\" class=\"code-anchor\">FormGroup</a>({\n  'name': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.name, [\n    Validators.required,\n    Validators.minLength(4),\n    forbiddenNameValidator(/bob/i) // &lt;-- Here's how you pass in the custom validator.\n  ]),\n  'alterEgo': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.alterEgo),\n  'power': new <a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a>(this.hero.power, Validators.required)\n});\n\n</code-example>\n<h3 id=\"adding-to-template-driven-forms\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ejkljl42w5crjv3zhdjeqq0r9\"><i class=\"material-icons\">link</i>添加到模板驱动表单</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"w2hoicdawbkshlapz6sg5kxa\">在模板驱动表单中，你无法直接访问 \n<code><a href=\"api/forms/FormControl\" class=\"code-anchor\">FormControl</a></code> 实例，因此你无法像响应式表单那样传递验证器。相反，你需要在模板中添加一个指令。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ae5imfgt0q56vcpyqd29k7hbf\">相应的 \n<code>ForbiddenValidatorDirective</code> 充当 \n<code>forbiddenNameValidator</code> 的包装器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cd9qvid5jihwfvhymyxxhkm7r\">Angular 识别指令在验证过程中的作用，因为指令使用 \n<code><a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a></code> 提供者（一个具有可扩展验证器集合的提供者）进行注册。</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive-providers\" title=\"shared/forbidden-name.directive.ts (providers)\" linenums=\"false\">\nproviders: [{provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>, useExisting: ForbiddenValidatorDirective, multi: true}]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6pc639u4w5mk7nkbddegz27lo\">然后，指令类实现 \n<code><a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a></code> 接口，以便它可以轻松地与 Angular 表单集成。以下是指令的其余部分，可以帮助你了解它是如何组合在一起的：</p>\n<code-example path=\"form-validation/src/app/shared/forbidden-name.directive.ts\" region=\"directive\" title=\"shared/forbidden-name.directive.ts (directive)\">\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: '[appForbiddenName]',\n  providers: [{provide: <a href=\"api/forms/NG_VALIDATORS\" class=\"code-anchor\">NG_VALIDATORS</a>, useExisting: ForbiddenValidatorDirective, multi: true}]\n})\nexport class ForbiddenValidatorDirective implements <a href=\"api/forms/Validator\" class=\"code-anchor\">Validator</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>('appForbiddenName') forbiddenName: string;\n\n  validate(control: <a href=\"api/forms/AbstractControl\" class=\"code-anchor\">AbstractControl</a>): {[key: string]: any} {\n    return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control)\n                              : null;\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bkysy1dauns4qd199fg3mq5q9\">一旦 \n<code>ForbiddenValidatorDirective</code> 准备就绪，你就可以简单地将它的选择器 \n<code>appForbiddenName</code> 添加到任何输入元素以激活它。例如：</p>\n<code-example path=\"form-validation/src/app/template/hero-form-template.component.html\" region=\"name-input\" title=\"template/hero-form-template.component.html (forbidden-name-input)\" linenums=\"false\">\n&lt;input id=\"name\" name=\"name\" class=\"form-control\"\n       required <a href=\"api/forms/MinLengthValidator\" class=\"code-anchor\">minlength</a>=\"4\" appForbiddenName=\"bob\"\n       [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" #name=\"<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>\" &gt;\n\n</code-example>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dun4b7pfg3y3zcng3mtpsj1yn\">你可能已经注意到，自定义验证指令使用 \n<code>useExisting</code> 而不是 \n<code>useClass</code> 进行实例化。注册的验证器必须是 \n<code>ForbiddenValidatorDirective</code> 的\n<em>此实例</em>——表单中具有 \n<code>forbiddenName</code> 属性绑定到“bob”的实例。如果你将 \n<code>useExisting</code> 替换为 \n<code>useClass</code>，那么你将注册一个新的类实例，该实例没有 \n<code>forbiddenName</code>。</p>\n</div>\n<h2 id=\"control-status-css-classes\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"a22sgpj699qql2r1ygca7zu05\"><i class=\"material-icons\">link</i>控件状态 CSS 类</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bty9u9guhiruey1qf3veoo65w\">就像 AngularJS 一样，Angular 会自动将许多控件属性镜像到表单控件元素上，作为 CSS 类。你可以使用这些类根据表单的状态来设置表单控件元素的样式。目前支持以下类：</p>\n<ul>\n<li><code>.ng-valid</code></li>\n<li><code>.ng-invalid</code></li>\n<li><code>.ng-pending</code></li>\n<li><code>.ng-pristine</code></li>\n<li><code>.ng-dirty</code></li>\n<li><code>.ng-untouched</code></li>\n<li><code>.ng-touched</code></li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"241dcs6dc9ptth7m33jerd2nv\">英雄表单使用 \n<code>.ng-valid</code> 和 \n<code>.ng-invalid</code> 类来设置每个表单控件边框的颜色。</p>\n<code-example path=\"form-validation/src/assets/forms.css\" title=\"forms.css (status classes)\">\n\n.ng-valid[required], .ng-valid.required  {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid:not(form)  {\n  border-left: 5px solid #a94442; /* red */\n}\n\n\n</code-example>\n<p><strong data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c3459ir1vrxazwbvvxgs3i2yf\">你可以运行 \n<live-example></live-example> 来查看完整的响应式和模板驱动示例代码。</strong></p>\n\n</div>\n<!-- links to this doc:\n - guide/reactive-forms\n-->\n<!-- links from this doc:\n - api/common/NgIf\n - api/core/Directive\n - api/core/Input\n - api/forms/AbstractControl\n - api/forms/FormControl\n - api/forms/FormControlName\n - api/forms/FormGroup\n - api/forms/MinLengthValidator\n - api/forms/NG_VALIDATORS\n - api/forms/NgModel\n - api/forms/Validator\n - api/forms/ValidatorFn\n - api/forms/Validators\n - guide/form-validation#adding-to-reactive-forms\n - guide/form-validation#adding-to-template-driven-forms\n - guide/form-validation#built-in-validators\n - guide/form-validation#control-status-css-classes\n - guide/form-validation#custom-validators\n - guide/form-validation#form-validation\n - guide/form-validation#reactive-component-class\n - guide/form-validation#reactive-form-validation\n - guide/form-validation#template-driven-validation\n - guide/form-validation#validator-functions\n - guide/form-validation#why-check-dirty-and-touched\n - guide/forms\n - guide/reactive-forms\n - https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation\n-->"
}