{
  "id" : "guide/hierarchical-dependency-injection",
  "title" : "分层依赖注入器",
  "contents" : "<div class=\"content\">\n<h1 id=\"hierarchical-dependency-injectors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"59iuqh61zzv91hu5k7ngnzinp\"><i class=\"material-icons\">link</i>分层依赖注入器</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4yeml9u7ch9szydi6tcwp72zz\">你在 \n<a href=\"guide/dependency-injection\">依赖注入</a> 指南中学习了 Angular 依赖注入的基础知识。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3ih3tp7kzc97k9lltkgabfot8\">Angular 具有一个\n<em>分层依赖注入</em>系统。实际上，存在一个与应用程序组件树平行的注入器树。你可以在该组件树的任何级别重新配置注入器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9agjhl7l4j8vy3ta14lpoh58s\">本指南探讨了此系统以及如何利用它来发挥优势。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4w10r0225jg8vpmpvo9l7v4wj\">尝试 \n<live-example></live-example>。</p>\n<h2 id=\"the-injector-tree\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b5k58wgw8xhgm8s09ojnaq9kt\"><i class=\"material-icons\">link</i>注入器树</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eb1w7molk2cy0ugplj30rbarw\">在 \n<a href=\"guide/dependency-injection\">依赖注入</a> 指南中，你学习了如何配置依赖注入器以及如何在需要的地方检索依赖项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9c77zo8m3013sz1100p4vm6fd\">实际上，不存在\n<strong><em>唯一</em></strong>的注入器。一个应用程序可能有多个注入器。Angular 应用程序是组件树。每个组件实例都有自己的注入器。组件树与注入器树平行。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"194udh106b1jqhqv792bqiqxi\">组件的注入器可能是组件树中更高层祖先注入器的\n<em>代理</em>。这是一个提高效率的实现细节。你不会注意到区别，你的心理模型应该是每个组件都有自己的注入器。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ew8ybngolaw6ba24ov8oocm4s\">考虑本指南对英雄之旅应用程序的变体。在最顶层是 \n<code>AppComponent</code>，它有一些子组件。其中一个是 \n<code>HeroesListComponent</code>。\n<code>HeroesListComponent</code> 持有并管理多个 \n<code>HeroTaxReturnComponent</code> 实例。下图表示本指南的三级组件树在同时打开三个 \n<code>HeroTaxReturnComponent</code> 实例时的状态。</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection/component-hierarchy.png\" alt=\"injector tree\" width=\"600\" height=\"224\">\n</figure>\n<h3 id=\"injector-bubbling\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5cuj17v146q0eses2f4s1eveu\"><i class=\"material-icons\">link</i>注入器冒泡</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bc34qtenv9tqmvpocl17kc0el\">当组件请求依赖项时，Angular 会尝试使用在该组件自身注入器中注册的提供者来满足该依赖项。如果组件的注入器缺少提供者，它会将请求传递给其父组件的注入器。如果该注入器无法满足请求，它会将其传递给\n<em>其</em>父注入器。请求会一直冒泡，直到 Angular 找到一个可以处理请求的注入器或用完祖先注入器。如果用完祖先，Angular 会抛出错误。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63rdpf3eg28612kjvggwuu516\">你可以限制冒泡。中间组件可以声明自己是「宿主」组件。对提供者的搜索不会超过该宿主组件的注入器。这是另一个主题。</p>\n</div>\n<h3 id=\"re-providing-a-service-at-different-levels\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"kwnydcx8741hve8z9qwdcwft\"><i class=\"material-icons\">link</i>在不同级别重新提供服务</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6c2lmlgbtgj9dm735d6l0npsl\">你可以在注入器树的多个级别重新注册特定依赖项令牌的提供者。你\n<em>不必</em>重新注册提供者。除非有充分的理由，否则你不应该这样做。但是你\n<em>可以</em>这样做。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1mh8696ulb179gn0aqfcqcwwb\">由于解析逻辑向上工作，因此遇到的第一个提供者获胜。因此，中间注入器中的提供者会拦截来自树中较低级别内容的服务请求。它有效地「重新配置」并「遮蔽」树中更高级别的提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6n3c1k924agi6nqn8qpgpfm1t\">如果你只在顶层（通常是根 \n<code>AppModule</code>）指定提供者，则注入器树看起来是平坦的。所有请求都会冒泡到你使用 \n<code>bootstrapModule</code> 方法配置的根 \n<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 注入器。</p>\n<h2 id=\"component-injectors\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d52pq64wyx1m52oc23pbhxn07\"><i class=\"material-icons\">link</i>组件注入器</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d6sorb59a56psh7aqde8f0yg4\">能够在不同级别配置一个或多个提供者开辟了有趣且有用的可能性。</p>\n<h3 id=\"scenario-service-isolation\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"aobumz97mlirkdbbqpjdtzt4j\"><i class=\"material-icons\">link</i>场景：服务隔离</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5bj3hrs10zcadqs8chgxfgmfb\">架构原因可能会导致你限制对服务的访问，使其仅限于其所属的应用程序域。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"65kt1oxrye0w7qiv027x5le51\">指南示例包含一个 \n<code>VillainsListComponent</code>，它显示一个反派列表。它从 \n<code>VillainsService</code> 获取这些反派。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4abxg75vf042mhk2ox3e5ne1u\">虽然你\n<em>可以</em>在根 \n<code>AppModule</code> 中提供 \n<code>VillainsService</code>（你将在那里找到 \n<code>HeroesService</code>），但这会使 \n<code>VillainsService</code> 在整个应用程序中可用，包括\n<em>英雄</em>工作流程。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1qkvbveab7x44qp0et4e6t79e\">如果你以后修改了 \n<code>VillainsService</code>，你可能会破坏某个英雄组件中的某些内容。这本不应该发生，但在根 \n<code>AppModule</code> 中提供服务会造成这种风险。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dck8g16hmojbfv4vtiw8k166t\">相反，在 \n<code>VillainsListComponent</code> 的 \n<code>providers</code> 元数据中提供 \n<code>VillainsService</code>，如下所示：</p>\n<code-example path=\"hierarchical-dependency-injection/src/app/villains-list.component.ts\" linenums=\"false\" title=\"src/app/villains-list.component.ts (metadata)\" region=\"metadata\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-villains-list',\n  templateUrl: './villains-list.component.html',\n  providers: [ VillainsService ]\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1xp5ri82s3d111g8sp673lffz\">通过在 \n<code>VillainsListComponent</code> 元数据中提供 \n<code>VillainsService</code>，而不是在其他地方提供，该服务仅在 \n<code>VillainsListComponent</code> 及其子组件树中可用。它仍然是单例，但它是一个仅存在于\n<em>反派</em>域中的单例。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1jwp6c2o9atsrr8o2qgwalewi\">现在你知道英雄组件无法访问它了。你减少了出错的可能性。</p>\n<h3 id=\"scenario-multiple-edit-sessions\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2w92sf2uzrfd7wgusr5x22bfo\"><i class=\"material-icons\">link</i>场景：多重编辑会话</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6k1npw98h4t78c9z1r0k50hqy\">许多应用程序允许用户同时处理多个打开的任务。例如，在税务申报应用程序中，申报人可以处理多个税务申报表，在一天中从一个申报表切换到另一个申报表。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7gnxaaxhtnkr2ch975nn60h6x\">本指南以英雄管理主题中的示例演示了这种情况。想象一个外部的 \n<code>HeroListComponent</code>，它显示了一个超级英雄列表。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"2i9h71u2uocfeu4xzpx4khswy\">要打开一个英雄的报税单，申报者点击英雄名，它就会打开一个组件来编辑那个申报单。每个选中的申报单都会在自己的组件中打开，并且可以同时打开多个申报单。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"a7mhq0qmq3dndr8qhu8rnkjj3\">每个报税单组件都有下列特征：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"60y30u45wb2i66utzc4ug566t\">是它自己的税务申报表编辑会话。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"abwo9qjsnsowes1zho3l6pw3m\">可以更改税务申报表，而不会影响另一个组件中的申报表。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5dk7orulndq0m2tu7yeyrmnrr\">有能力保存对税务申报表的更改或取消更改。</li>\n</ul>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection/hid-heroes-anim.gif\" alt=\"Heroes in action\" width=\"500\" height=\"384\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"42bpfcyu9u8cnfz4trbbaotaj\">有人可能会认为 \n<code>HeroTaxReturnComponent</code> 具有管理和恢复更改的逻辑。对于简单的英雄税务申报表来说，这将是一项非常简单的任务。在现实世界中，使用丰富的税务申报表数据模型，更改管理将很棘手。你可能会将该管理委托给辅助服务，就像本示例所做的那样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6e45e1da9l6vmv2i9bnpntcgp\">以下是 \n<code>HeroTaxReturnService</code>。它缓存单个 \n<code>HeroTaxReturn</code>，跟踪对该申报表的更改，并且可以保存或恢复它。它还委托给应用程序范围的单例 \n<code>HeroService</code>，它通过注入获取该服务。</p>\n<code-example path=\"hierarchical-dependency-injection/src/app/hero-tax-return.service.ts\" title=\"src/app/hero-tax-return.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }    from '@angular/core';\nimport { HeroTaxReturn } from './hero';\nimport { HeroesService } from './heroes.service';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroTaxReturnService {\n  private currentTaxReturn: HeroTaxReturn;\n  private originalTaxReturn: HeroTaxReturn;\n\n  constructor(private heroService: HeroesService) { }\n\n  set taxReturn (htr: HeroTaxReturn) {\n    this.originalTaxReturn = htr;\n    this.currentTaxReturn  = htr.clone();\n  }\n\n  get taxReturn (): HeroTaxReturn {\n    return this.currentTaxReturn;\n  }\n\n  restoreTaxReturn() {\n    this.taxReturn = this.originalTaxReturn;\n  }\n\n  saveTaxReturn() {\n    this.taxReturn = this.currentTaxReturn;\n    this.heroService.saveTaxReturn(this.currentTaxReturn).subscribe();\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cxp75bfk1c8bj2bipmsbnjzz6\">以下是使用它的 \n<code>HeroTaxReturnComponent</code>。</p>\n<code-example path=\"hierarchical-dependency-injection/src/app/hero-tax-return.component.ts\" title=\"src/app/hero-tax-return.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { HeroTaxReturn }        from './hero';\nimport { HeroTaxReturnService } from './hero-tax-return.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-tax-return',\n  templateUrl: './hero-tax-return.component.html',\n  styleUrls: [ './hero-tax-return.component.css' ],\n  providers: [ HeroTaxReturnService ]\n})\nexport class HeroTaxReturnComponent {\n  message = '';\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() close = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&lt;void&gt;();\n\n  get taxReturn(): HeroTaxReturn {\n    return this.heroTaxReturnService.taxReturn;\n  }\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()\n  set taxReturn (htr: HeroTaxReturn) {\n    this.heroTaxReturnService.taxReturn = htr;\n  }\n\n  constructor(private heroTaxReturnService: HeroTaxReturnService ) { }\n\n  onCanceled()  {\n    this.flashMessage('Canceled');\n    this.heroTaxReturnService.restoreTaxReturn();\n  };\n\n  onClose()  { this.close.emit(); };\n\n  onSaved() {\n    this.flashMessage('Saved');\n    this.heroTaxReturnService.saveTaxReturn();\n  }\n\n  flashMessage(msg: string) {\n    this.message = msg;\n    setTimeout(() =&gt; this.message = '', 500);\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c2eqinqnxu8uwtkf3ja6vgmvf\"><em>要编辑的税务申报表</em>通过输入属性到达，该属性使用 getter 和 setter 实现。setter 使用传入的申报表初始化组件自己的 \n<code>HeroTaxReturnService</code> 实例。getter 始终返回该服务认为是英雄当前状态的内容。该组件还要求该服务保存和恢复此税务申报表。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6y1t04vuuo0aikjwe4qqgloou\">如果\n<em>此</em>服务是应用程序范围的单例，就会出现大问题。每个组件都会共享同一个服务实例。每个组件都会覆盖属于另一个英雄的税务申报表。多么混乱！</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"czblpziq9m5fb9a7i4m4vasmc\">仔细查看 \n<code>HeroTaxReturnComponent</code> 的元数据。注意 \n<code>providers</code> 属性。</p>\n<code-example path=\"hierarchical-dependency-injection/src/app/hero-tax-return.component.ts\" linenums=\"false\" title=\"src/app/hero-tax-return.component.ts (providers)\" region=\"providers\">\nproviders: [ HeroTaxReturnService ]\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dmw4mnaznb7tlwe5m064nas4b\"><code>HeroTaxReturnComponent</code> 有它自己的 \n<code>HeroTaxReturnService</code> 提供者。回想一下，每个组件\n<em>实例</em>都有它自己的注入器。在组件级别提供服务可确保组件的\n<em>每个</em>实例都获得它自己的私有服务实例。没有税务申报表覆盖。没有混乱。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bimqfltovmme25pvnjqda52jq\">该场景的其余代码依赖于其他 Angular 特性和技术，你可以在文档的其他地方了解这些特性和技术。你可以从 \n<live-example></live-example> 中查看和下载它。</p>\n</div>\n<h3 id=\"scenario-specialized-providers\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bu80yjgzs1u1i4uljokemu1j1\"><i class=\"material-icons\">link</i>场景：专门的提供者</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"hsbgf0cp19u9iit3ltt6xzdt\">重新提供服务的另一个原因是替换该服务的\n<em>更专门</em>的实现，在组件树中更深层的位置。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4f99bxdc41s50mjvg62iev3i2\">再次考虑来自 \n<a href=\"guide/dependency-injection\">依赖注入</a> 指南的汽车示例。假设你使用 \n<code>CarService</code>、\n<code>EngineService</code> 和 \n<code>TiresService</code> 的\n<em>通用</em>提供者配置了根注入器（标记为 A）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5s725w3r4ah2ek7zqhwt4clni\">你创建了一个汽车组件（A），它显示由这三个通用服务构建的汽车。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dajrmvsy4ui5d1ktpcixixpih\">然后，你创建了一个子组件（B），它为 \n<code>CarService</code> 和 \n<code>EngineService</code> 定义了自己的\n<em>专门</em>提供者，这些提供者具有适合组件（B）中正在发生的事情的特殊功能。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dsksdo14hhmuv4k6x230hkovn\">组件（B）是另一个组件（C）的父组件，该组件为 \n<code>CarService</code> 定义了自己的、甚至\n<em>更专门</em>的提供者。</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection/car-components.png\" alt=\"car components\" width=\"338\" height=\"201\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"d3e7wcdupc8jgdgeojkhgbedf\">在幕后，每个组件都有自己的注入器，这个注入器带有为组件本身准备的 0 个、1 个或多个提供者。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2urko9tj8300u6e7ff95muf47\">当你解析最深层组件（C）中的 \n<code>Car</code> 实例时，它的注入器会生成一个由注入器（C）解析的 \n<code>Car</code> 实例，其中包含由注入器（B）解析的 \n<code>Engine</code> 和由根注入器（A）解析的 \n<code>Tires</code>。</p>\n<figure>\n  <img src=\"generated/images/guide/dependency-injection/injector-tree.png\" alt=\"car injector tree\" width=\"600\" height=\"248\">\n</figure>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aiu5gfrq0ck707r1tiodlgvcj\">此\n<em>汽车</em>场景的代码位于示例的 \n<code>car.components.ts</code> 和 \n<code>car.services.ts</code> 文件中，你可以从 \n<live-example></live-example> 中查看和下载它。</p>\n</div>\n\n</div>\n<!-- links to this doc:\n - guide/change-log\n - guide/dependency-injection\n - guide/upgrade\n-->\n<!-- links from this doc:\n - api/core/Component\n - api/core/EventEmitter\n - api/core/Injectable\n - api/core/Input\n - api/core/NgModule\n - api/core/Output\n - guide/dependency-injection\n - guide/hierarchical-dependency-injection#component-injectors\n - guide/hierarchical-dependency-injection#hierarchical-dependency-injectors\n - guide/hierarchical-dependency-injection#injector-bubbling\n - guide/hierarchical-dependency-injection#re-providing-a-service-at-different-levels\n - guide/hierarchical-dependency-injection#scenario-multiple-edit-sessions\n - guide/hierarchical-dependency-injection#scenario-service-isolation\n - guide/hierarchical-dependency-injection#scenario-specialized-providers\n - guide/hierarchical-dependency-injection#the-injector-tree\n-->"
}