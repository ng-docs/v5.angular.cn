{
  "id" : "guide/pipes",
  "title" : "管道",
  "contents" : "<div class=\"content\">\n<h1 id=\"pipes\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"4c1vv1rgp7phpgpk7rg59bjk0\"><i class=\"material-icons\">link</i>管道</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4vqn5jy003wqe3cru4mjdjbh9\">每个应用程序都从一个看似简单的任务开始：获取数据、转换数据并将其显示给用户。 获取数据可能像创建局部变量一样简单，也可能像通过 WebSocket 流式传输数据一样复杂。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3orvhg6oiulg4pgkpuv9s5lly\">一旦数据到达，你就可以将它们的原始 \n<code>toString</code> 值直接推送到视图中， 但这很少能带来良好的用户体验。 例如，在大多数情况下，用户更喜欢看到一个简单的日期格式，例如 \n<samp>April 15, 1988</samp>，而不是原始字符串格式 \n<samp>Fri Apr 15 1988 00:00:00 GMT-0700 (Pacific Daylight Time)</samp>.</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zph940c90yt44p9c4hfveznc\">显然，一些值需要进行一些编辑。你可能会注意到，你 在许多应用程序中，无论是内部还是跨应用程序，都反复需要许多相同的转换。 你几乎可以把它们看作是样式。 事实上，你可能希望在 HTML 模板中像使用样式一样应用它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7jnv077xsvwzs22ox01shj6bw\">介绍 Angular 管道，这是一种在 HTML 中声明显示值转换的方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fliytthw8ajl1jed0jtyvesz\">你可以在 Stackblitz 中运行 \n<live-example></live-example> 并从那里下载代码。</p>\n<h2 id=\"using-pipes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41gn85mravmawj6jk0yspwllp\"><i class=\"material-icons\">link</i>使用管道</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yl0u3vy5fyxvcbx8uuq266z4\">管道接收数据作为输入，并将其转换为所需的输出。 在本页中，你将使用管道将组件的 birthday 属性转换为 人类友好的日期。</p>\n<code-example path=\"pipes/src/app/hero-birthday1.component.ts\" title=\"src/app/hero-birthday1.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-birthday',\n  template: `&lt;p&gt;The hero's birthday is {{ birthday | date }}&lt;/p&gt;`\n})\nexport class HeroBirthdayComponent {\n  birthday = new Date(1988, 3, 15); // April 15, 1988\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4ax0b8jtii0utc5z094gbu6h4\">注意组件的模板。</p>\n<code-example path=\"pipes/src/app/app.component.html\" region=\"hero-birthday-template\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;p&gt;The hero's birthday is {{ birthday | date }}&lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dec56j5s9yo5q5ja6hq9ejyr3\">在插值表达式中，你通过 \n<a href=\"guide/template-syntax#pipe\">管道运算符</a> ( | ) 将组件的 \n<code>birthday</code> 值传递到右侧的 \n<a href=\"api/common/DatePipe\">Date 管道</a> 函数。所有管道都是这样工作的。</p>\n<h2 id=\"built-in-pipes\" data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"6e9u3fgdjnw9ws1eoxsrwc8bu\"><i class=\"material-icons\">link</i>内置管道</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bsvgyh8mkd8c9z2bx3bnvizzn\">Angular 带有一组管道，例如 \n<code><a href=\"api/common/DatePipe\" class=\"code-anchor\">DatePipe</a></code>、\n<code><a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a></code>、\n<code><a href=\"api/common/LowerCasePipe\" class=\"code-anchor\">LowerCasePipe</a></code>、\n<code><a href=\"api/common/CurrencyPipe\" class=\"code-anchor\">CurrencyPipe</a></code> 和 \n<code><a href=\"api/common/PercentPipe\" class=\"code-anchor\">PercentPipe</a></code>。 它们都可以在任何模板中使用。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2uaesea899eb7vmpu3ijspflx\">在 \n<a href=\"api?type=pipe\">管道主题</a> 的 \n<a href=\"api\">API 参考</a> 中阅读有关这些管道和其他许多内置管道的更多信息；筛选包含“管道”一词的条目。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"do4t89qxtzp3v3egzrkowrxv3\">Angular 没有 \n<code>FilterPipe</code> 或 \n<code>OrderByPipe</code>，原因在本文档的 \n<a href=\"guide/pipes#no-filter-pipe\">附录</a> 中解释。</p>\n</div>\n<h2 id=\"parameterizing-a-pipe\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8mq8ik9pez6hdbulq1es6p8vo\"><i class=\"material-icons\">link</i>参数化管道</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6t5wigry8fr13f3k9f98ggy3g\">管道可以接受任意数量的可选参数来微调其输出。 要向管道添加参数，请在管道名称后面加上冒号 ( : )，然后是参数值 （例如 \n<code>currency:'EUR'</code>）。如果管道接受多个参数，请用冒号 ( : ) 分隔这些值（例如 \n<code>slice:1:5</code>）。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2u3j5mw2br1t3qnm1hzfb6zos\">修改 birthday 模板以向 date 管道提供一个 format 参数。 在格式化英雄的 4 月 15 日生日后，它将渲染为 \n<strong><samp>04/15/88</samp></strong>：</p>\n<code-example path=\"pipes/src/app/app.component.html\" region=\"format-birthday\" title=\"src/app/app.component.html\" linenums=\"false\">\n&lt;p&gt;The hero's birthday is {{ birthday | date:\"MM/dd/yy\" }} &lt;/p&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6doah8er8z4w1rfgzehocoxak\">参数值可以是任何有效的模板表达式， （参见 \n<a href=\"guide/template-syntax#template-expressions\">模板表达式</a> 部分的 \n<a href=\"guide/template-syntax\">模板语法</a> 页面） 例如字符串字面量或组件属性。 换句话说，你可以通过绑定来控制格式，就像你通过绑定来控制 birthday 值一样。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhyapt47wippyd8n1boen45jt\">编写第二个组件，将管道的 format 参数 \n<em>绑定</em>到组件的 \n<code>format</code> 属性。以下是该组件的模板：</p>\n<code-example path=\"pipes/src/app/hero-birthday2.component.ts\" region=\"template\" title=\"src/app/hero-birthday2.component.ts (template)\" linenums=\"false\">\ntemplate: `\n  &lt;p&gt;The hero's birthday is {{ birthday | date:format }}&lt;/p&gt;\n  &lt;button (click)=\"toggleFormat()\"&gt;Toggle Format&lt;/button&gt;\n`\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"du8w23bacfeab3y5kdc5hi3ib\">你还向模板添加了一个按钮，并将它的点击事件绑定到组件的 \n<code>toggleFormat()</code> 方法。 该方法在短格式 (\n<code>'shortDate'</code>) 和长格式 (\n<code>'fullDate'</code>) 之间切换组件的 \n<code>format</code> 属性。</p>\n<code-example path=\"pipes/src/app/hero-birthday2.component.ts\" region=\"class\" title=\"src/app/hero-birthday2.component.ts (class)\" linenums=\"false\">\nexport class HeroBirthday2Component {\n  birthday = new Date(1988, 3, 15); // April 15, 1988\n  toggle = true; // start with true == shortDate\n\n  get format()   { return this.toggle ? 'shortDate' : 'fullDate'; }\n  toggleFormat() { this.toggle = !this.toggle; }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fo45ajk0ajnm0m5zui0dh0gp\">当你点击按钮时，显示的日期会在 \"\n<strong><samp>04/15/1988</samp></strong>\" 和 \"\n<strong><samp>Friday, April 15, 1988</samp></strong>\" 之间交替。</p>\n<figure>\n  <img src=\"generated/images/guide/pipes/date-format-toggle-anim.gif\" alt=\"Date Format Toggle\" width=\"300\" height=\"62\">\n</figure>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"yewnq8uiypts7wwaxcdsskal\">在 \n<a href=\"api/common/DatePipe\">Date Pipe</a> API 参考页面中阅读有关 \n<code><a href=\"api/common/DatePipe\" class=\"code-anchor\">DatePipe</a></code> 格式选项的更多信息。</p>\n</div>\n<h2 id=\"chaining-pipes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4moqu4t0qd1qz7njd7uhnqluc\"><i class=\"material-icons\">link</i>链接管道</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4g65y97oy0wwbpxxe8vogb6xc\">你可以将管道链接在一起，形成可能很有用的组合。 在以下示例中，要以大写形式显示生日， 生日被链接到 \n<code><a href=\"api/common/DatePipe\" class=\"code-anchor\">DatePipe</a></code>，然后链接到 \n<code><a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">UpperCasePipe</a></code>。 生日显示为 \n<strong><samp>APR 15, 1988</samp></strong>。</p>\n<code-example path=\"pipes/src/app/app.component.html\" region=\"chained-birthday\" title=\"src/app/app.component.html\" linenums=\"false\">\nThe chained hero's birthday is\n{{ birthday | date | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dibxe6jattdeexsvs7wiax6bd\">此示例（显示 \n<strong><samp>FRIDAY, APRIL 15, 1988</samp></strong>）链接 了与上面相同的管道，但还向 \n<code>date</code> 传递了一个参数。</p>\n<code-example path=\"pipes/src/app/app.component.html\" region=\"chained-parameter-birthday\" title=\"src/app/app.component.html\" linenums=\"false\">\nThe chained hero's birthday is\n{{  birthday | date:'fullDate' | uppercase}}\n\n</code-example>\n<h2 id=\"custom-pipes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3q7ggi6aoglnpeya6ttge96gj\"><i class=\"material-icons\">link</i>自定义管道</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"63bj6kdj3exn42mqk3x9jkfzl\">你可以编写自己的自定义管道。 以下是一个名为 \n<code>ExponentialStrengthPipe</code> 的自定义管道，它可以增强英雄的力量：</p>\n<code-example path=\"pipes/src/app/exponential-strength.pipe.ts\" title=\"src/app/exponential-strength.pipe.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n/*\n * Raise the value exponentially\n * Takes an exponent argument that defaults to 1.\n * Usage:\n *   value | exponentialStrength:exponent\n * Example:\n *   {{ 2 | exponentialStrength:10 }}\n *   formats to: 1024\n*/\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({name: 'exponentialStrength'})\nexport class ExponentialStrengthPipe implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(value: number, exponent: string): number {\n    let exp = parseFloat(exponent);\n    return Math.pow(value, isNaN(exp) ? 1 : exp);\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"55ljsf4fmwtsk57yp4heqp7h0\">此管道定义揭示了以下关键点：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d1jplf8jpy5ggah7wcfw2seeh\">管道是一个用管道元数据装饰的类。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dudg90rqbjri6a9uqawml5y35\">管道类实现了 \n<code><a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a></code> 接口的 \n<code>transform</code> 方法，该方法 接受一个输入值，后面跟着可选参数，并返回转换后的值。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1kavcnl8690gaw48h5ib943hg\">对于传递给管道的每个参数，\n<code>transform</code> 方法将有一个额外的参数。 你的管道有一个这样的参数：\n<code>exponent</code>。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d31cvqjot8cucui95a1g6cf1c\">为了告诉 Angular 这是一个管道，你应用了 \n<code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code> 装饰器，你从 Angular 核心库中导入它。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arlpb56ljjyoovbjs583jhdfx\"><code>@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code> 装饰器允许你定义 你在模板表达式中使用的管道名称。它必须是一个有效的 JavaScript 标识符。 你的管道的名称是 \n<code>exponentialStrength</code>。</li>\n</ul>\n<div class=\"l-sub-section\">\n<h2 id=\"the-pipetransform-interface\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ca5gzcm6ayxj72pl6bj3dp5t6\"><i class=\"material-icons\">link</i><em>PipeTransform</em> 接口</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3klhjkay7mf6ic9d406dv0x98\"><code>transform</code> 方法对于管道来说是必不可少的。 \n<code><a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a></code> \n<em>接口</em>定义了该方法，并指导工具和编译器。 从技术上讲，它是可选的；Angular 会查找并执行 \n<code>transform</code> 方法，无论如何。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zolo05pklqgqvudh3ztujfzt\">现在你需要一个组件来演示管道。</p>\n<code-example path=\"pipes/src/app/power-booster.component.ts\" title=\"src/app/power-booster.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-power-booster',\n  template: `\n    &lt;h2&gt;Power Booster&lt;/h2&gt;\n    &lt;p&gt;Super power boost: {{2 | exponentialStrength: 10}}&lt;/p&gt;\n  `\n})\nexport class PowerBoosterComponent { }\n\n\n</code-example>\n<figure>\n  <img src=\"generated/images/guide/pipes/power-booster.png\" alt=\"Power Booster\" width=\"300\" height=\"105\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c9nsd32oev8x6qkc13baeioq9\">注意以下几点：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"brzartld0i5e12ehqezaaqr7x\">你使用自定义管道的方式与使用内置管道的方式相同。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ep75cbttgv2fjqbyp4a4lcsu5\">你必须将你的管道包含在 \n<code>AppModule</code> 的 \n<code>declarations</code> 数组中。</li>\n</ul>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ckze6unyq3ylkciad7d9eukwx\">记住 declarations 数组</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"egwx7dnv5gfq4532yxsxlu083\">你必须注册自定义管道。 如果你不这样做，Angular 会报告错误。 Angular CLI 的生成器会自动注册管道。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2vbsnidaoddcs775dn5idyw4i\">为了探查 \n<live-example></live-example> 中的行为， 更改模板中的值和可选指数。</p>\n<h2 id=\"power-boost-calculator\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"306la3s7v8l59xma2etgw5eep\"><i class=\"material-icons\">link</i>力量提升计算器</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3j8epmgj150n3u3nlaxpst6c2\">仅仅更新模板来测试自定义管道并不有趣。 将示例升级为一个“力量提升计算器”，它将你的管道和双向数据绑定与 \n<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a></code> 结合起来。</p>\n<code-example path=\"pipes/src/app/power-boost-calculator.component.ts\" title=\"src/app/power-boost-calculator.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-power-boost-calculator',\n  template: `\n    &lt;h2&gt;Power Boost Calculator&lt;/h2&gt;\n    &lt;div&gt;Normal power: &lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"power\"&gt;&lt;/div&gt;\n    &lt;div&gt;Boost factor: &lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"factor\"&gt;&lt;/div&gt;\n    &lt;p&gt;\n      Super Hero Power: {{power | exponentialStrength: factor}}\n    &lt;/p&gt;\n  `\n})\nexport class PowerBoostCalculatorComponent {\n  power = 5;\n  factor = 1;\n}\n\n\n</code-example>\n<figure>\n  <img src=\"generated/images/guide/pipes/power-boost-calculator-anim.gif\" alt=\"Power Boost Calculator\" width=\"296\" height=\"136\">\n</figure>\n<a id=\"change-detection\"></a>\n<h2 id=\"pipes-and-change-detection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cv42pzqk3b9x8vmg0gd37hjyk\"><i class=\"material-icons\">link</i>管道和变更检测</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2y9fkf48xzhe7u7czdeeyd5a5\">Angular 通过一个\n<em>变更检测</em>过程来查找数据绑定值的变化，该过程在每个 DOM 事件之后运行： 每次按键、鼠标移动、计时器滴答和服务器响应。这可能很昂贵。 Angular 尽力在可能和适当的时候降低成本。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ygh3jlsxwbv54knl4iw91e92\">当你使用管道时，Angular 会选择一个更简单、更快的变更检测算法。</p>\n<h3 class=\"no-toc\" id=\"no-pipe\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ctmskzp5zzyzije7itbvwe1r\"><i class=\"material-icons\">link</i>没有管道</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0ba4x4duq60i891tobjkwowt\">在下一个示例中，组件使用默认的、积极的变更检测策略来监控和更新 它对 \n<code>heroes</code> 数组中每个英雄的显示。以下是模板：</p>\n<code-example path=\"pipes/src/app/flying-heroes.component.html\" region=\"template-1\" title=\"src/app/flying-heroes.component.html (v1)\" linenums=\"false\">\nNew hero:\n  &lt;input type=\"text\" #box\n          (keyup.enter)=\"addHero(box.value); box.value=''\"\n          placeholder=\"hero name\"&gt;\n  &lt;button (click)=\"reset()\"&gt;Reset&lt;/button&gt;\n  &lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\"&gt;\n    {{hero.name}}\n  &lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"27vdgacfhk9d004zr0h1zmb5u\">配套的组件类提供英雄，将英雄添加到数组中，并且可以重置数组。</p>\n<code-example path=\"pipes/src/app/flying-heroes.component.ts\" region=\"v1\" title=\"src/app/flying-heroes.component.ts (v1)\" linenums=\"false\">\nexport class FlyingHeroesComponent {\n  heroes: any[] = [];\n  canFly = true;\n  constructor() { this.reset(); }\n\n  addHero(name: string) {\n    name = name.trim();\n    if (!name) { return; }\n    let hero = {name, canFly: this.canFly};\n    this.heroes.push(hero);\n  }\n\n  reset() { this.heroes = HEROES.slice(); }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ck3l5fkem3x9ew3w9i7igr1u6\">你可以添加英雄，当你这样做时，Angular 会更新显示。 如果你点击 \n<code>reset</code> 按钮，Angular 会用原始英雄的新数组替换 \n<code>heroes</code>，并更新显示。 如果你添加了删除或更改英雄的功能，Angular 会检测这些变化并更新显示。</p>\n<h3 class=\"no-toc\" id=\"flyingheroespipe\"><i>FlyingHeroesPipe</i></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dlamtmeus8ag6i9ck03zkkrto\">在 \n<code>*<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> 重复器中添加一个 \n<code>FlyingHeroesPipe</code>，它将英雄列表过滤为只有那些会飞的英雄。</p>\n<code-example path=\"pipes/src/app/flying-heroes.component.html\" region=\"template-flying-heroes\" title=\"src/app/flying-heroes.component.html (flyers)\" linenums=\"false\">\n&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of (heroes | flyingHeroes)\"&gt;\n  {{hero.name}}\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1u06g2lwa40juqr75shxvy8t\">以下是 \n<code>FlyingHeroesPipe</code> 的实现，它遵循前面描述的自定义管道的模式。</p>\n<code-example path=\"pipes/src/app/flying-heroes.pipe.ts\" region=\"pure\" title=\"src/app/flying-heroes.pipe.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\nimport { Flyer } from './heroes';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({ name: 'flyingHeroes' })\nexport class FlyingHeroesPipe implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(allHeroes: Flyer[]) {\n    return allHeroes.filter(hero =&gt; hero.canFly);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"953k80ycvy302mxq6alwz0wno\">注意 \n<live-example></live-example> 中的奇怪行为： 当你添加会飞的英雄时，它们都不会显示在“会飞的英雄”下。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a4rfxb8pk1souh2xta81f9zhl\">虽然你没有得到你想要的行为，但 Angular 并没有坏掉。 它只是使用了一种不同的变更检测算法，该算法会忽略对列表或其任何条目的更改。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bs1b34l6glc8vza2dk8253mgd\">注意英雄是如何添加的：</p>\n<code-example path=\"pipes/src/app/flying-heroes.component.ts\" region=\"push\" title=\"src/app/flying-heroes.component.ts\" linenums=\"false\">\nthis.heroes.push(hero);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9g5zvxusdgjrr7ylwshrjg2cv\">你将英雄添加到 \n<code>heroes</code> 数组中。对数组的引用没有改变。 它还是同一个数组。这就是 Angular 所关心的。从它的角度来看，\n<em>同一个数组，没有变化，没有显示更新</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a3cx1igjj7fja7bvzrfe9un78\">为了解决这个问题，创建一个包含新英雄的数组，并将它赋值给 \n<code>heroes</code>。 这次 Angular 检测到数组引用发生了变化。 它执行管道并使用包含新会飞英雄的新数组更新显示。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1f8mgds3eyrwbryibp977ybj8\">如果你\n<em>修改</em>数组，则不会调用任何管道，并且显示不会更新； 如果你\n<em>替换</em>数组，则管道会执行，并且显示会更新。 Flying Heroes 应用程序扩展了 代码，其中包含复选框开关和额外的显示，以帮助你体验这些效果。</p>\n<figure>\n  <img src=\"generated/images/guide/pipes/flying-heroes-anim.gif\" alt=\"Flying Heroes\" width=\"360\" height=\"412\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"emqiy1ss53414uyv004r4cc62\">替换数组是向 Angular 发出信号更新显示的有效方法。 你什么时候替换数组？当数据发生变化时。 这是一个在\n<em>这个</em>示例中很容易遵循的规则 因为更改数据的唯一方法是添加英雄。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"co7iqn5sfipbdvomoivn8qhfr\">更常见的是，你不知道数据何时发生了变化， 尤其是在以多种方式修改数据的应用程序中， 也许是在应用程序中很远的地方。 这样的应用程序中的组件通常无法知道这些变化。 此外，为了适应管道而扭曲组件设计是不明智的。 努力保持组件类独立于 HTML。 组件应该不知道管道。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"er9ldraortoyfghz95x3h64oe\">对于过滤会飞的英雄，考虑使用一个\n<em>非纯管道</em>。</p>\n<h2 id=\"pure-and-impure-pipes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4rmchkw0hlogxq9unyh73toe4\"><i class=\"material-icons\">link</i>纯管道和非纯管道</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7k7hwwkln5qahx9jwdl77x81q\">管道分为两类：\n<em>纯</em>和\n<em>非纯</em>。 管道默认情况下是纯的。你到目前为止看到的每个管道都是纯的。 你可以通过将管道的纯标志设置为 false 来使管道变为非纯。你可以像这样使 \n<code>FlyingHeroesPipe</code> 变为非纯：</p>\n<code-example path=\"pipes/src/app/flying-heroes.pipe.ts\" region=\"pipe-decorator\" title=\"src/app/flying-heroes.pipe.ts\" linenums=\"false\">\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({\n  name: 'flyingHeroesImpure',\n  pure: false\n})\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"nzs9n0mvupaskc30wp25vbls\">在这样做之前，先了解纯和非纯之间的区别，从纯管道开始。</p>\n<h3 class=\"no-toc\" id=\"pure-pipes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2z09xv5u7z5ce4h6s70saub2\"><i class=\"material-icons\">link</i>纯管道</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5le3k4qzrd73oikkbaobj3mje\">Angular 仅在检测到输入值的\n<em>纯变化</em>时才执行\n<em>纯管道</em>。 纯变化是指对原始输入值（\n<code>String</code>、\n<code>Number</code>、\n<code>Boolean</code>、\n<code>Symbol</code>） 或更改的对象引用（\n<code>Date</code>、\n<code>Array</code>、\n<code>Function</code>、\n<code>Object</code>）的更改。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"289knypvvgqetgm83quz2k7uf\">Angular 会忽略（复合）对象内部的变化。 如果你更改输入月份、向输入数组添加内容或更新输入对象属性，它不会调用纯管道。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5qrzj57h2hu7aa9kch21j6mhn\">这可能看起来很严格，但它也很快。 对象引用检查很快——比深度检查差异快得多——因此 Angular 可以快速确定它是否可以跳过 管道执行和视图更新。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"77i9h2xm4f0zcfo6gaxxa75g8\">因此，当你能够接受变更检测策略时，纯管道是更好的选择。 当你不能接受时，你可以\n<em>使用</em>非纯管道。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cc0kywminvua6ob1gplsxzy9\">或者你可能根本不使用管道。 使用组件的属性来实现管道的目的可能更好， 这一点将在本页面的后面部分讨论。</p>\n</div>\n<h3 class=\"no-toc\" id=\"impure-pipes\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2sjfymcqiedwzwp8a7xb0jilb\"><i class=\"material-icons\">link</i>非纯管道</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e13rp5hbuyp2pt4xjn7n85sdc\">Angular 在每个组件变更检测周期中都会执行\n<em>非纯管道</em>。 非纯管道被频繁调用，就像每次按键或鼠标移动一样频繁。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8f51adem3quog0mu4a0n33hdv\">考虑到这一点，请谨慎地实现非纯管道。 一个昂贵、运行时间长的管道可能会破坏用户体验。</p>\n<a id=\"impure-flying-heroes\"></a>\n<h3 class=\"no-toc\" id=\"an-impure-flyingheroespipe\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"38r4b70hfi4tg7tas5oahysq9\"><i class=\"material-icons\">link</i>一个非纯的 \n<i>FlyingHeroesPipe</i></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9m5dxo0vldvoapzk9nzrixld9\">将开关切换一下，就会将 \n<code>FlyingHeroesPipe</code> 变成 \n<code>FlyingHeroesImpurePipe</code>。 完整的实现如下：</p>\n<code-tabs>\n\n  <code-pane title=\"FlyingHeroesImpurePipe\" path=\"pipes/src/app/flying-heroes.pipe.ts\" region=\"impure\">\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({\n  name: 'flyingHeroesImpure',\n  pure: false\n})\nexport class FlyingHeroesImpurePipe extends FlyingHeroesPipe {}\n\n</code-pane>\n\n  <code-pane title=\"FlyingHeroesPipe\" path=\"pipes/src/app/flying-heroes.pipe.ts\" region=\"pure\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\nimport { Flyer } from './heroes';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({ name: 'flyingHeroes' })\nexport class FlyingHeroesPipe implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(allHeroes: Flyer[]) {\n    return allHeroes.filter(hero =&gt; hero.canFly);\n  }\n}\n\n</code-pane>\n\n</code-tabs>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ggzjjy146qbyep8tyq0w9ruk\">你继承自 \n<code>FlyingHeroesPipe</code>，以证明内部没有任何变化。 唯一的区别是管道元数据中的 \n<code>pure</code> 标志。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3fgeilxs3pm9xtsjnl60c3frf\">这是一个适合使用非纯管道的例子，因为 \n<code>transform</code> 函数很简单且速度很快。</p>\n<code-example path=\"pipes/src/app/flying-heroes.pipe.ts\" linenums=\"false\" title=\"src/app/flying-heroes.pipe.ts (filter)\" region=\"filter\">\nreturn allHeroes.filter(hero =&gt; hero.canFly);\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bhkc5ylat2p0bqb0xh1ae00wc\">你可以从 \n<code>FlyingHeroesComponent</code> 派生出 \n<code>FlyingHeroesImpureComponent</code>。</p>\n<code-example path=\"pipes/src/app/flying-heroes-impure.component.html\" linenums=\"false\" title=\"src/app/flying-heroes-impure.component.html (excerpt)\" region=\"template-flying-heroes\">\n&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of (heroes | flyingHeroesImpure)\"&gt;\n  {{hero.name}}\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b2po4oizqrttjtvxgwly6y6ee\">唯一的实质性变化是模板中的管道。 你可以在 \n<live-example></live-example> 中确认，即使你修改了 \n<code>heroes</code> 数组，\n<em>飞翔的英雄</em> 显示也会随着你添加英雄而更新。</p>\n<a id=\"async-pipe\"></a>\n<h3 class=\"no-toc\" id=\"the-impure-asyncpipe\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cexm7m6nn6jfh3w0x75idy657\"><i class=\"material-icons\">link</i>非纯的 \n<i>AsyncPipe</i></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dcny10vzm54jo5n4puymvpfq1\">Angular 的 \n<code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code> 是一个有趣的非纯管道示例。 \n<code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code> 接受 \n<code>Promise</code> 或 \n<code>Observable</code> 作为输入， 并自动订阅输入，最终返回发射的值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fkmd6orgjm1pax8bbofw1ges\"><code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code> 也是有状态的。 管道维护对输入 \n<code>Observable</code> 的订阅， 并随着它们到达而不断地从该 \n<code>Observable</code> 中传递值。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f429d0yeucxzpm4cg7mts45xd\">下一个示例将 \n<code>Observable</code> 的消息字符串 （\n<code>message$</code>）与 \n<code><a href=\"api/core/testing/async\" class=\"code-anchor\">async</a></code> 管道绑定到视图。</p>\n<code-example path=\"pipes/src/app/hero-async-message.component.ts\" title=\"src/app/hero-async-message.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/observable/interval';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/take';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-message',\n  template: `\n    &lt;h2&gt;Async Hero Message and <a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a>&lt;/h2&gt;\n    &lt;p&gt;Message: {{ message$ | <a href=\"api/core/testing/async\" class=\"code-anchor\">async</a> }}&lt;/p&gt;\n    &lt;button (click)=\"resend()\"&gt;Resend&lt;/button&gt;`,\n})\nexport class HeroAsyncMessageComponent {\n  message$: Observable&lt;string&gt;;\n\n  private messages = [\n    'You are my hero!',\n    'You are the best hero!',\n    'Will you be my hero?'\n  ];\n\n  constructor() { this.resend(); }\n\n  resend() {\n    this.message$ = Observable.interval(500)\n      .map(i =&gt; this.messages[i])\n      .take(this.messages.length);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3gw14ek79gyr0t1jvj50fp0yy\">Async 管道节省了组件代码中的样板代码。 组件不必订阅异步数据源， 提取求解的值并将其公开以供绑定， 也不必在销毁时取消订阅 （这是一种潜在的内存泄漏来源）。</p>\n<h3 class=\"no-toc\" id=\"an-impure-caching-pipe\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"520842m9qbgxoxqpbb5vrqktk\"><i class=\"material-icons\">link</i>非纯缓存管道</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"djdbf7vlo4dcl6jksts1n4krv\">再写一个非纯管道，一个发出 HTTP 请求的管道。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8wffi9haysfgciyuz6bviegnc\">请记住，非纯管道每隔几毫秒就会被调用。 如果你不小心，这个管道会用请求来惩罚服务器。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"71fmwhk2yaypmfiznaggh510g\">在下面的代码中，管道只在请求 URL 发生变化时才调用服务器，并缓存服务器响应。 代码使用 \n<a href=\"guide/http\">Angular http</a> 客户端来检索数据：</p>\n<code-example path=\"pipes/src/app/fetch-json.pipe.ts\" title=\"src/app/fetch-json.pipe.ts\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\nimport { <a href=\"api/http/Http\" class=\"code-anchor\">Http</a> }                from '@angular/http';\n\nimport 'rxjs/add/operator/map';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({\n  name: 'fetch',\n  pure: false\n})\nexport class FetchJsonPipe  implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  private cachedData: any = null;\n  private cachedUrl = '';\n\n  constructor(private http: <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>) { }\n\n  transform(url: string): any {\n    if (url !== this.cachedUrl) {\n      this.cachedData = null;\n      this.cachedUrl = url;\n      this.http.get(url)\n        .map( result =&gt; result.json() )\n        .subscribe( result =&gt; this.cachedData = result );\n    }\n\n    return this.cachedData;\n  }\n}\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7e1v8ovbsxqbgnjhbm6880ygc\">现在在一个测试组件中演示它，该组件的模板定义了两个对该管道的绑定， 两者都从 \n<code>heroes.json</code> 文件中请求英雄。</p>\n<code-example path=\"pipes/src/app/hero-list.component.ts\" title=\"src/app/hero-list.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero-list',\n  template: `\n    &lt;h2&gt;Heroes from JSON File&lt;/h2&gt;\n\n    &lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of ('assets/heroes.json' | fetch) \"&gt;\n      {{hero.name}}\n    &lt;/div&gt;\n\n    &lt;p&gt;Heroes as JSON:\n      {{'assets/heroes.json' | fetch | <a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>}}\n    &lt;/p&gt;`\n})\nexport class HeroListComponent { }\n\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"causgyk86gvrcj8t0vr5mwuit\">组件渲染如下：</p>\n<figure>\n  <img src=\"generated/images/guide/pipes/hero-list.png\" alt=\"Hero List\" width=\"400\" height=\"232\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bwkswi1izdox23er0uv93hniu\">在管道请求数据的断点处，显示如下：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4h3u1kumhbpolp6b5hlkubvjs\">每个绑定都有自己的管道实例。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1027hu4agh1og4v3gpcz4v2wu\">每个管道实例都缓存自己的 URL 和数据。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"arw4b5nrainh5ntdmey2392pm\">每个管道实例只调用服务器一次。</li>\n</ul>\n<h3 class=\"no-toc\" id=\"jsonpipe\"><i>JsonPipe</i></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6lgi0gcf1qpbvtlubqvzagpqw\">在前面的代码示例中，第二个 \n<code>fetch</code> 管道绑定演示了更多管道链式处理。 它通过链式处理到内置的 \n<code><a href=\"api/common/JsonPipe\" class=\"code-anchor\">JsonPipe</a></code>，以 JSON 格式显示相同的英雄数据。</p>\n<div class=\"callout is-helpful\">\n<header data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f2rra2dq5hprhy2tdx831ia2j\">使用 json 管道进行调试</header>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8un5j6ratx7ye2744m0oz696q\"><a href=\"api/common/JsonPipe\">JsonPipe</a> 提供了一种简单的方法来诊断神秘失败的数据绑定或 检查对象以供将来绑定。</p>\n</div>\n<a id=\"pure-pipe-pure-fn\"></a>\n<h3 class=\"no-toc\" id=\"pure-pipes-and-pure-functions\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5thamjujhu8l3jvabv92fpquz\"><i class=\"material-icons\">link</i>纯管道和纯函数</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cbi47ed6j3t1ys884u93f6y4\">纯管道使用纯函数。 纯函数处理输入并返回值，没有可检测的副作用。 给定相同的输入，它们应该始终返回相同的输出。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2erqyjjqzdfi1tm5fhibl3jta\">本页前面讨论的管道是用纯函数实现的。 内置的 \n<code><a href=\"api/common/DatePipe\" class=\"code-anchor\">DatePipe</a></code> 是一个具有纯函数实现的纯管道。 \n<code>ExponentialStrengthPipe</code> 和 \n<code>FlyingHeroesPipe</code> 也是如此。 几步之前，你回顾了 \n<code>FlyingHeroesImpurePipe</code>——一个具有纯函数的非纯管道。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0q41uazf6wenqpucoqt0ekb1\">但始终用\n<em>纯函数</em>实现\n<em>纯管道</em>。 否则，你会看到很多关于表达式在检查后发生变化的控制台错误。</p>\n<h2 id=\"next-steps\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c4pkljueu68ifjoi5994e9l8o\"><i class=\"material-icons\">link</i>下一步</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"gsqgioy31ote2beee40tgt8s\">管道是封装和共享常见显示值 转换的一种好方法。像使用样式一样使用它们，将它们 放到模板的表达式中，以增强视图的吸引力和可用性。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7s4qmxglv6s84za4llcwh8qqz\">在 \n<a href=\"api?type=pipe\">API 参考</a> 中探索 Angular 的内置管道库。 尝试编写一个自定义管道，并将其贡献给社区。</p>\n<a id=\"no-filter-pipe\"></a>\n<h2 id=\"appendix-no-filterpipe-or-orderbypipe\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9hhjxd5kbxc3ohdkven1zxx8h\"><i class=\"material-icons\">link</i>附录：没有 \n<em>FilterPipe</em> 或 \n<em>OrderByPipe</em></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cazdbzbnpsrm5rch4z489cm1f\">Angular 不提供用于过滤或排序列表的管道。 熟悉 AngularJS 的开发人员知道它们是 \n<code>filter</code> 和 \n<code>orderBy</code>。 Angular 中没有等效项。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"elrav7o793ukln25p97y33t7\">这不是疏忽。Angular 不提供此类管道，因为 它们性能很差，并且会阻止积极的缩小。 \n<code>filter</code> 和 \n<code>orderBy</code> 都需要引用对象属性的参数。 本页前面，你了解到此类管道必须是 \n<a href=\"guide/pipes#pure-and-impure-pipes\">非纯的</a>，并且 Angular 在几乎每个变更检测周期中都会调用非纯管道。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7aoctzvqm6gwglr3qo60iu20k\">过滤和排序，尤其是排序，都是昂贵的操作。 对于中等大小的列表，当 Angular 每秒调用这些管道方法很多次时，用户体验可能会严重下降。 \n<code>filter</code> 和 \n<code>orderBy</code> 在 AngularJS 应用中经常被滥用，导致人们抱怨 Angular 本身很慢。 这种指责在间接意义上是合理的，因为 AngularJS 最初提供了 \n<code>filter</code> 和 \n<code>orderBy</code>，从而导致了这种性能陷阱。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d1vz1bempa4px4i25fm5wd6qh\">缩小风险也很大，虽然不那么明显。想象一下，将排序管道应用于英雄列表。 该列表可能按英雄的 \n<code>name</code> 和来源 \n<code>planet</code> 属性排序，如下所示：</p>\n<code-example language=\"html\">\n  &lt;!-- NOT REAL CODE! --&gt;\n  &lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes | orderBy:'name,planet'\"&gt;&lt;/div&gt;\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eipumb46w5nf23viuh96l7jn4\">你通过文本字符串识别排序字段，期望管道通过索引引用属性值 （例如 \n<code>hero['name']</code>）。 不幸的是，积极的缩小会操纵 \n<code>Hero</code> 属性名称，使 \n<code>Hero.name</code> 和 \n<code>Hero.planet</code> 变成类似 \n<code>Hero.a</code> 和 \n<code>Hero.b</code> 的东西。显然 \n<code>hero['name']</code> 不起作用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"a9onnh9q38ujbp42pzrvfy55x\">虽然有些人可能不关心如此积极地缩小， 但 Angular 产品不应该阻止任何人积极地缩小。 因此，Angular 团队决定，Angular 提供的所有内容都将安全地缩小。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5w3a5mkhd2rlmo6yywvkpjq3e\">Angular 团队和许多经验丰富的 Angular 开发人员强烈建议将 过滤和排序逻辑移到组件本身。 组件可以公开 \n<code>filteredHeroes</code> 或 \n<code>sortedHeroes</code> 属性，并控制 何时以及如何执行支持逻辑。 你可能放在管道中并在整个应用中共享的任何功能都可以 写入过滤/排序服务并注入到组件中。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9wiedbqftzqu682icvdrknmf0\">如果这些性能和缩小问题不适用于你，你始终可以创建自己的此类管道 （类似于 \n<a href=\"guide/pipes#impure-flying-heroes\">FlyingHeroesPipe</a>）或在社区中找到它们。</p>\n\n</div>\n<!-- links to this doc:\n - guide/ajs-quick-reference\n - guide/bootstrapping\n - guide/glossary\n - guide/template-syntax\n - tutorial/toh-pt1\n-->\n<!-- links from this doc:\n - api\n - api/common/AsyncPipe\n - api/common/CurrencyPipe\n - api/common/DatePipe\n - api/common/JsonPipe\n - api/common/LowerCasePipe\n - api/common/NgForOf\n - api/common/PercentPipe\n - api/common/UpperCasePipe\n - api/core/Component\n - api/core/Pipe\n - api/core/PipeTransform\n - api/core/testing/async\n - api/forms/NgModel\n - api/http/Http\n - api?type=pipe\n - guide/http\n - guide/pipes#an-impure-caching-pipe\n - guide/pipes#an-impure-flyingheroespipe\n - guide/pipes#appendix-no-filterpipe-or-orderbypipe\n - guide/pipes#built-in-pipes\n - guide/pipes#chaining-pipes\n - guide/pipes#custom-pipes\n - guide/pipes#flyingheroespipe\n - guide/pipes#impure-flying-heroes\n - guide/pipes#impure-pipes\n - guide/pipes#jsonpipe\n - guide/pipes#next-steps\n - guide/pipes#no-filter-pipe\n - guide/pipes#no-pipe\n - guide/pipes#parameterizing-a-pipe\n - guide/pipes#pipes\n - guide/pipes#pipes-and-change-detection\n - guide/pipes#power-boost-calculator\n - guide/pipes#pure-and-impure-pipes\n - guide/pipes#pure-pipes\n - guide/pipes#pure-pipes-and-pure-functions\n - guide/pipes#the-impure-asyncpipe\n - guide/pipes#the-pipetransform-interface\n - guide/pipes#using-pipes\n - guide/template-syntax\n - guide/template-syntax#pipe\n - guide/template-syntax#template-expressions\n-->"
}