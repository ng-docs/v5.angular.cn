{
  "id" : "guide/lifecycle-hooks",
  "title" : "生命周期钩子",
  "contents" : "<div class=\"content\">\n<h1 id=\"lifecycle-hooks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3qew97hapc5gpvz81cc3c5px6\"><i class=\"material-icons\">link</i>生命周期钩子</h1>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e5hvmwxdhlgatpvjqw0qnnkop\">组件的生命周期由 Angular 管理。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bjje2zcw5vuqyyx8yfgp3nktf\">Angular 创建它，渲染它，创建并渲染它的子组件，在它的数据绑定属性发生变化时检查它，并在从 DOM 中删除它之前销毁它。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5jf122vutoqcxlejwkx26yr5c\">Angular 提供了 \n<strong>生命周期钩子</strong>，它们可以让你了解这些关键的生命周期时刻，并让你能够在这些时刻发生时采取行动。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"951wzoww4fjqjvsmv89g6q2nk\">指令具有相同的生命周期钩子集。</p>\n<a id=\"hooks-overview\"></a>\n<h2 id=\"component-lifecycle-hooks-overview\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9i3lf4v0vctkjh4ktls0kqv2b\"><i class=\"material-icons\">link</i>组件生命周期钩子概述</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"fxmczgtdxeiao2uj1sk0gpwe\">指令和组件实例具有生命周期，因为 Angular 创建、更新和销毁它们。开发人员可以通过在 Angular \n<code>core</code> 库中实现一个或多个 \n<em>生命周期钩子</em> 接口，来利用生命周期中的关键时刻。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d60e343whi49je0qjhdp0dj9y\">每个接口都有一个单独的钩子方法，其名称是接口名称加上前缀 \n<code>ng</code>。例如，\n<code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code> 接口有一个名为 \n<code>ngOnInit()</code> 的钩子方法，Angular 在创建组件后不久就会调用它：</p>\n<code-example path=\"lifecycle-hooks/src/app/peek-a-boo.component.ts\" region=\"ngOnInit\" title=\"peek-a-boo.component.ts (excerpt)\" linenums=\"false\">\nexport class PeekABoo implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  constructor(private logger: LoggerService) { }\n\n  // implement <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>'s `ngOnInit` method\n  ngOnInit() { this.logIt(`<a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>`); }\n\n  logIt(msg: string) {\n    this.logger.log(`#${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9rbczt3jhomxvkcdrrenpb6i0\">没有指令或组件会实现所有生命周期钩子。Angular 仅在 \n<em>定义</em> 指令/组件钩子方法时才会调用它。</p>\n<a id=\"hooks-purpose-timing\"></a>\n<h2 id=\"lifecycle-sequence\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"365ghftnkaax2o98zbn9pb40\"><i class=\"material-icons\">link</i>生命周期序列</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"46xboix2m5627wk2tuxphjn4m\"><em>在</em>通过调用构造函数创建组件/指令\n<em>之后</em>，Angular 会在特定时刻按以下顺序调用生命周期钩子方法：</p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  <col width=\"80%\">\n  </colgroup><tbody><tr>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"azs5is22x8jg5z33gvmvot45t\">钩子</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bz8sz2k5td6fkihmiewim2y8h\">目的和时机</th>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnChanges()</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bze5mfvzkhxr0r6fzmhe4qro\">响应 Angular（重新）设置数据绑定的输入属性时。 此方法接收一个包含当前和先前属性值的 \n<code><a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a></code> 对象。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3wqx0x75cn7if9u1av9xrbeih\">在 \n<code>ngOnInit()</code> 之前调用，以及每当一个或多个数据绑定的输入属性发生变化时调用。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnInit()</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3zotoggfuf62ws55fxxd2m2\">在 Angular 首次显示数据绑定的属性并设置指令/组件的输入属性之后初始化指令/组件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ev5acaos8j4r0eav7w3u785fu\">调用\n<em>一次</em>，在\n<em>第一次</em> \n<code>ngOnChanges()</code> 之后。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngDoCheck()</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6isoc7cypmsfpc5q6gsya9nft\">检测并处理 Angular 无法或不愿自行检测的变化。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7i8pqdg29i39g4uiogckbyos0\">在每次变更检测运行期间调用，紧接在 \n<code>ngOnChanges()</code> 和 \n<code>ngOnInit()</code> 之后。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterContentInit()</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e6npma6fktkf9df4fq1rljmw5\">响应 Angular 将外部内容投影到组件视图/指令所在的视图中之后。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8aphp3g78peh1d10sjwlb0smh\">在\n<em>第一次</em> \n<code>ngDoCheck()</code> 之后调用\n<em>一次</em>。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterContentChecked()</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"afd88jjdq8ktrawbieskzt5rs\">响应 Angular 检查投影到指令/组件中的内容之后。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8dcd7qkk7lo76afv8bl6gqdm2\">在 \n<code>ngAfterContentInit()</code> 之后以及每次后续 \n<code>ngDoCheck()</code> 之后调用。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterViewInit()</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b0i3ardcd8lo5wjc2p6u4wvk7\">响应 Angular 初始化组件视图和子视图/指令所在的视图之后。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cok8d0qin1dwib2br1aupgsay\">在\n<em>第一次</em> \n<code>ngAfterContentChecked()</code> 之后调用\n<em>一次</em>。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngAfterViewChecked()</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1veg65reli0xb3u1mp69dps2\">响应 Angular 检查组件视图和子视图/指令所在的视图之后。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"61k7dtyhcolnco4iueed1va5g\">在 \n<code>ngAfterViewInit</code> 之后以及每次后续 \n<code>ngAfterContentChecked()</code> 之后调用。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <code>ngOnDestroy()</code>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"471h9ew7jo6jw63d7pqefufsf\">在 Angular 销毁指令/组件之前进行清理。 取消订阅可观察者并分离事件处理程序以避免内存泄漏。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5m458abg2zwg693nqczadhynw\">在 Angular \n<em>即将</em>销毁指令/组件之前调用。</p>\n    </td>\n  </tr>\n</tbody></table>\n<a id=\"interface-optional\"></a>\n<h2 id=\"interfaces-are-optional-technically\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"41hbni47n0nk744xd9czq6eq1\"><i class=\"material-icons\">link</i>接口是可选的（从技术上讲）</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"23uuy2hw7qv8lnpxv1mfevp8l\">从纯粹的技术角度来看，对于 JavaScript 和 TypeScript 开发人员来说，接口是可选的。 JavaScript 语言没有接口。 Angular 在运行时无法看到 TypeScript 接口，因为它们在转译后的 JavaScript 中消失了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9asowe43nqi78j21yi12kfm5j\">幸运的是，它们不是必需的。 你不必将生命周期钩子接口添加到指令和组件中，就可以从钩子本身中获益。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"e0xr65abjjla73sx6cn4jswn2\">Angular 会检查指令和组件类，并在\n<em>定义</em>钩子方法时调用它们。 Angular 会找到并调用诸如 \n<code>ngOnInit()</code> 之类的函数，无论是否使用接口。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5ovng0ot4nkuw047lcln7mhcf\">尽管如此，将接口添加到 TypeScript 指令类中是一个好习惯，以便从强类型和编辑器工具中获益。</p>\n<a id=\"other-lifecycle-hooks\"></a>\n<h2 id=\"other-angular-lifecycle-hooks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4e5ulq2rfevh9dyc9qwzxkbzh\"><i class=\"material-icons\">link</i>其他 Angular 生命周期钩子</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4h77qbrozpdbnekl1pixwmqzt\">除了这些组件钩子之外，其他 Angular 子系统可能也有自己的生命周期钩子。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"62pdu9tqdlkr3qbnhtsxz3hv6\">第三方库也可能实现自己的钩子，以便让开发人员更好地控制这些库的使用方式。</p>\n<a id=\"the-sample\"></a>\n<h2 id=\"lifecycle-examples\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"17ao8gzgov5g9ati8v6pf0s1v\"><i class=\"material-icons\">link</i>生命周期示例</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7ezjq5hsn0pfqowepqv1ih1jm\">此 \n<live-example></live-example> 通过一系列练习演示了生命周期钩子的实际应用，这些练习以根 \n<code>AppComponent</code> 控制下的组件形式呈现。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"byf0u4jkkendx8nka3632y456\">它们遵循一种常见模式：\n<em>父</em>组件充当\n<em>子</em>组件的测试平台，该\n<em>子</em>组件演示了一个或多个生命周期钩子方法。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"31v8hmam0rl0gq5ymus4oy79y\">以下是每项练习的简要说明：</p>\n<table width=\"100%\">\n  <colgroup><col width=\"20%\">\n  <col width=\"80%\">\n  </colgroup><tbody><tr>\n    <th data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2n8tguxhs6hbmqbwyqfclvff1\">组件</th>\n    <th data-ng_translator_product=\"100\" data-ng_translator_confirmed data-ng_translator_ref_id=\"ar5q09mdsagdppsbze96eagxl\">说明</th>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#peek-a-boo\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f12yvncf74a35a7pcn229g89w\">捉迷藏</a>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8f0oyapu0wobprvw4hjup09k7\">演示了所有生命周期钩子。 每个钩子方法都会写入屏幕上的日志。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#spy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cu3echtv4w4poikljzpcpjpf2\">间谍</a>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"aj84z5ybhhxal34pbqb4nn5n7\">指令也有生命周期钩子。 \n<code>SpyDirective</code> 可以使用 \n<code>ngOnInit</code> 和 \n<code>ngOnDestroy</code> 钩子记录它所监视的元素何时创建或销毁。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7gnbg0z6srdz09ouf44qsn63z\">此示例将 \n<code>SpyDirective</code> 应用于 \n<code>&lt;div&gt;</code>，该 \n<code>&lt;div&gt;</code> 位于由父 \n<code>SpyComponent</code> 管理的 \n<code><a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a></code> \n<em>英雄</em>重复器中。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#onchanges\">OnChanges</a>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8ewizfvwdxg90qroitwr3a3kz\">查看 Angular 如何在每次组件输入属性发生变化时使用 \n<code>changes</code> 对象调用 \n<code>ngOnChanges()</code> 钩子。 展示如何解释 \n<code>changes</code> 对象。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#docheck\">DoCheck</a>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5cigrucf1ywqofh516fl7sd4c\">实现了一个带有自定义变更检测的 \n<code>ngDoCheck()</code> 方法。 查看 Angular 多久调用一次此钩子，并观察它将更改发布到日志中。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#afterview\">AfterView</a>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"66yesk3kfigwg41vaf34t6cu2\">展示了 Angular 所谓的\n<em>视图</em>。 演示了 \n<code>ngAfterViewInit</code> 和 \n<code>ngAfterViewChecked</code> 钩子。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td>\n      <a href=\"guide/lifecycle-hooks#aftercontent\">AfterContent</a>\n    </td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"drxk58b4kyt77o2bujtcsfsmc\">展示了如何将外部内容投影到组件中，以及如何区分投影内容和组件的视图子项。 演示了 \n<code>ngAfterContentInit</code> 和 \n<code>ngAfterContentChecked</code> 钩子。</p>\n    </td>\n  </tr>\n  <tr style=\"vertical-align:top\">\n    <td data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avef31elg2czq0zf02cfd9w19\">计数器</td>\n    <td>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nc0gz4ouoz93mf0lhr9w2sdl\">演示了组件和指令的组合，每个都具有自己的钩子。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qpky7u3313xod1tkgbz5mpek\">在此示例中，\n<code>CounterComponent</code> 在每次父组件递增其输入计数器属性时记录更改（通过 \n<code>ngOnChanges</code>）。 同时，前一个示例中的 \n<code>SpyDirective</code> 应用于 \n<code>CounterComponent</code> 日志，它监视日志条目被创建和销毁。</p>\n    </td>\n  </tr>\n</tbody></table>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1htntnr3l2ao1pld0b4911zre\">本页的其余部分将更详细地讨论选定的练习。</p>\n<a id=\"peek-a-boo\"></a>\n<h2 id=\"peek-a-boo-all-hooks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4fem0cpp129x13lomv1xu77py\"><i class=\"material-icons\">link</i>捉迷藏：所有钩子</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5tsa2xzvlikpqh7vsz9ctia0w\"><code>PeekABooComponent</code> 演示了所有钩子在一个组件中的应用。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bb3pbqm1epjzl3llm87m9a6be\">你很少（如果有的话）会像这样实现所有接口。 捉迷藏的存在是为了展示 Angular 如何按预期顺序调用钩子。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"o4a46mzzi7sqsywd3vb646ex\">此快照反映了用户单击\n<em>创建...</em>按钮，然后单击\n<em>销毁...</em>按钮后日志的状态。</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/peek-a-boo.png\" alt=\"Peek-a-boo\" width=\"309\" height=\"366\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bn0z2nkpestojcubg2rcldcac\">日志消息的顺序遵循规定的钩子调用顺序： \n<code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code>、\n<code><a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a></code>、\n<code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code>&nbsp;(3 次)、\n<code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a></code>、\n<code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code>&nbsp;(3 次)、 \n<code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a></code>、\n<code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code>&nbsp;(3 次) 以及 \n<code><a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a></code>。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3bwbnvzw4g5m1vytm7jva66j8\">构造函数本身并不是 Angular 钩子。 日志确认了输入属性（在本例中为 \n<code>name</code> 属性）在构造时没有赋值。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"c06axe5ohypqiufqctccn8lcx\">如果用户点击了 \n<em>更新英雄</em> 按钮，日志将显示另一个 \n<code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 以及另外两个 \n<code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code>、\n<code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a></code> 和 \n<code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a></code> 三元组。 很明显，这三个钩子会 \n<em>频繁</em> 触发。请尽可能地简化这些钩子中的逻辑！</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ax28bhd5j1zhyt2654ee2sfmo\">接下来的示例将重点介绍钩子的细节。</p>\n<a id=\"spy\"></a>\n<h2 id=\"spying-oninit-and-ondestroy\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"br8zj5hz9lkb5zlvqqx20vj6o\"><i class=\"material-icons\">link</i>监控 \n<em>OnInit</em> 和 \n<em>OnDestroy</em></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7tu0x0obn34uxdjs6ld35hkw4\">使用这两个间谍钩子潜入，发现元素何时被初始化或销毁。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"715d4ku595lx0vlqpowkxguvm\">这对于指令来说是完美的渗透工作。 英雄们永远不会知道他们正在被监视。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"15yjxn96tc0bap4p4exjcu47h\">说笑归说笑，请注意以下两个关键点：</p>\n<ol>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9fkv9uljvkouzw7jj63qdgi57\">Angular 会为 \n<em>指令</em> 和组件调用钩子方法。\n<br>\n<br></p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qekab1l56e8yrdhrr4ggh315\">间谍指令可以提供对无法直接更改的 DOM 对象的洞察。 显然，你无法触碰原生 \n<code>&lt;div&gt;</code> 的实现。 你也无法修改第三方组件。 但你可以使用指令来监视两者。</p>\n</li>\n</ol>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2q2zbaxirg67dgxopsi1bjo50\">这个偷偷摸摸的间谍指令很简单，几乎完全由 \n<code>ngOnInit()</code> 和 \n<code>ngOnDestroy()</code> 钩子组成，它们通过注入的 \n<code>LoggerService</code> 向父级记录消息。</p>\n<code-example path=\"lifecycle-hooks/src/app/spy.directive.ts\" region=\"spy-directive\" title=\"src/app/spy.directive.ts\" linenums=\"false\">\n// Spy on any element to which it is applied.\n// Usage: &lt;div mySpy&gt;...&lt;/div&gt;\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({selector: '[mySpy]'})\nexport class SpyDirective implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a>, <a href=\"api/core/OnDestroy\" class=\"code-anchor\">OnDestroy</a> {\n\n  constructor(private logger: LoggerService) { }\n\n  ngOnInit()    { this.logIt(`onInit`); }\n\n  ngOnDestroy() { this.logIt(`onDestroy`); }\n\n  private logIt(msg: string) {\n    this.logger.log(`Spy #${nextId++} ${msg}`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cu7uzcyl9s45wvcwc5liqeuw1\">你可以将间谍应用于任何原生或组件元素，它将与该元素同时初始化和销毁。 这里它被附加到重复的英雄 \n<code>&lt;div&gt;</code> 上：</p>\n<code-example path=\"lifecycle-hooks/src/app/spy.component.html\" region=\"template\" title=\"src/app/spy.component.html\" linenums=\"false\">\n&lt;div *<a href=\"api/common/NgForOf\" class=\"code-anchor\">ngFor</a>=\"let hero of heroes\" mySpy class=\"heroes\"&gt;\n  {{hero}}\n&lt;/div&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2sggaxpfkxcy1gbcrwgplr27u\">每个间谍的诞生和死亡都标志着附加的英雄 \n<code>&lt;div&gt;</code> 的诞生和死亡，并在 \n<em>钩子日志</em> 中留下记录，如下所示：</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/spy-directive.gif\" alt=\"Spy Directive\" width=\"656\" height=\"378\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"n8r1b8cjbgj21atcjsjhij2m\">添加英雄会导致一个新的英雄 \n<code>&lt;div&gt;</code>。间谍的 \n<code>ngOnInit()</code> 会记录该事件。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"48o5vsndg972gn8usijzahx92\"><em>重置</em> 按钮会清除 \n<code>heroes</code> 列表。 Angular 会从 DOM 中移除所有英雄 \n<code>&lt;div&gt;</code> 元素，并同时销毁它们的间谍指令。 间谍的 \n<code>ngOnDestroy()</code> 方法会报告其最后的时刻。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6uxuj7tzqhipj2stu6vfyhpf\"><code>ngOnInit()</code> 和 \n<code>ngOnDestroy()</code> 方法在实际应用中扮演着更重要的角色。</p>\n<a id=\"oninit\"></a>\n<h3 id=\"oninit\"><em>OnInit()</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7r45xidntw6d99nggf2ldjapd\">使用 \n<code>ngOnInit()</code> 主要有两个原因：</p>\n<ol>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"k0n3az1836ilsehhxx030ex6\">在构造之后执行复杂的初始化操作。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7hmy4samac0cd84fnbylo44b\">在 Angular 设置输入属性之后设置组件。</li>\n</ol>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"77yf0iowrpicrur49udc8m5fy\">经验丰富的开发人员一致认为，组件的构造应该廉价且安全。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2tlnuwpindu1lzi0dvonzhhoh\">Angular 团队负责人 Misko Hevery， \n<a href=\"http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/\">解释了为什么</a> 你应该避免复杂的构造函数逻辑。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"5uz98tq1vil8filp0joduhsmg\">不要在组件构造函数中获取数据。 你不应该担心，当在测试中创建或在你决定显示它之前，一个新的组件会尝试联系远程服务器。 构造函数应该只做设置初始局部变量为简单值的操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bvztkbe2jx41lasso841gc6xh\"><code>ngOnInit()</code> 是组件获取其初始数据的理想位置。 \n<a href=\"tutorial/toh-pt4#oninit\">英雄之旅教程</a> 指南展示了如何操作。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3q4677m28hdmh0mxe2ygz5qcj\">还要记住，指令的数据绑定输入属性直到 \n<em>构造之后</em> 才会被设置。 如果你需要根据这些属性初始化指令，这将是一个问题。 它们将在 \n<code>ngOnInit()</code> 运行时被设置。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cd7prrytf4jnrt285nnn75f4v\"><code>ngOnChanges()</code> 方法是访问这些属性的第一个机会。 Angular 会在 \n<code>ngOnInit()</code> 之前以及之后多次调用 \n<code>ngOnChanges()</code>。 它只调用 \n<code>ngOnInit()</code> 一次。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"avly6vu7p4qigjtatm34mzfi5\">你可以相信 Angular 会在创建组件 \n<em>之后不久</em> 调用 \n<code>ngOnInit()</code> 方法。 这就是放置繁重的初始化逻辑的地方。</p>\n<a id=\"ondestroy\"></a>\n<h3 id=\"ondestroy\"><em>OnDestroy()</em></h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"asd4ahahsns7z8wcdw82r6czt\">将清理逻辑放在 \n<code>ngOnDestroy()</code> 中，该逻辑 \n<em>必须</em> 在 Angular 销毁指令之前运行。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4tcue5xgu5xvh0jktpap47vje\">这是通知应用程序的另一个部分，该组件即将消失的时候。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2lvm95twkt4vo9xe32fc4wn3\">这是释放不会被自动垃圾回收的资源的地方。 取消订阅可观察者和 DOM 事件。停止间隔计时器。 取消注册此指令向全局或应用程序服务注册的所有回调。 如果你忽略了这样做，你可能会造成内存泄漏。</p>\n<a id=\"onchanges\"></a>\n<h2 id=\"onchanges\"><em>OnChanges()</em></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"77avdpth9207apjd6wmeqoqg2\">每当 Angular 检测到组件（或指令）的 \n<strong><em>输入属性</em></strong> 发生变化时，它就会调用其 \n<code>ngOnChanges()</code> 方法。 此示例监控 \n<code><a href=\"api/core/OnChanges\" class=\"code-anchor\">OnChanges</a></code> 钩子。</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"ng-on-changes\" title=\"on-changes.component.ts (excerpt)\" linenums=\"false\">\nngOnChanges(changes: <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a>) {\n  for (let propName in changes) {\n    let chng = changes[propName];\n    let cur  = JSON.stringify(chng.currentValue);\n    let prev = JSON.stringify(chng.previousValue);\n    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"awf7q230i6msp8ewl6itk40a8\"><code>ngOnChanges()</code> 方法接受一个对象，该对象将每个更改的属性名称映射到一个 \n<a href=\"api/core/SimpleChange\">SimpleChange</a> 对象，该对象保存当前和以前的属性值。 此钩子会遍历更改的属性并记录它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"92iwc37tdskh80iweu8n2wnnh\">示例组件 \n<code>OnChangesComponent</code> 有两个输入属性：\n<code>hero</code> 和 \n<code>power</code>。</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes.component.ts\" region=\"inputs\" title=\"src/app/on-changes.component.ts\" linenums=\"false\">\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() power: string;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"blkpq2u27pll14c62j9gx0wnb\">宿主 \n<code>OnChangesParentComponent</code> 这样绑定到它们：</p>\n<code-example path=\"lifecycle-hooks/src/app/on-changes-parent.component.html\" region=\"on-changes\" title=\"src/app/on-changes-parent.component.html\">\n&lt;on-changes [hero]=\"hero\" [power]=\"power\"&gt;&lt;/on-changes&gt;\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cnr0y8l44obycqgjo6odcdm7j\">以下是示例在用户进行更改时的实际操作。</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/on-changes-anim.gif\" alt=\"OnChanges\" width=\"632\" height=\"512\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"2cstlyfvtih138cmtcla4l2wh\">日志条目会随着 \n<em>power</em> 属性的字符串值发生变化而出现。 但 \n<code>ngOnChanges</code> 不会捕获对 \n<code>hero.name</code> 的更改。 这乍一看令人惊讶。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"bbqw0odpcv5wjpkwx2fytincj\">Angular 只会在输入属性的值发生变化时调用钩子。 \n<code>hero</code> 属性的值是 \n<em>对英雄对象的引用</em>。 Angular 不关心英雄自己的 \n<code>name</code> 属性是否发生了变化。 英雄对象 \n<em>引用</em> 没有改变，因此，从 Angular 的角度来看，没有变化需要报告！</p>\n<a id=\"docheck\"></a>\n<h2 id=\"docheck\"><em>DoCheck()</em></h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"69gilaol6cgugx4lzjdkddkhe\">使用 \n<code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code> 钩子来检测和处理 Angular 本身无法捕获的更改。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1fpv6vj3uapvswxgqpsf5mjlk\">使用此方法来检测 Angular 忽略的更改。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f5ehfkc37tlvv8vkfs90i7bul\"><em>DoCheck</em> 示例扩展了 \n<em>OnChanges</em> 示例，添加了以下 \n<code>ngDoCheck()</code> 钩子：</p>\n<code-example path=\"lifecycle-hooks/src/app/do-check.component.ts\" region=\"ng-do-check\" title=\"DoCheckComponent (ngDoCheck)\" linenums=\"false\">\nngDoCheck() {\n\n  if (this.hero.name !== this.oldHeroName) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Hero name changed to \"${this.hero.name}\" from \"${this.oldHeroName}\"`);\n    this.oldHeroName = this.hero.name;\n  }\n\n  if (this.power !== this.oldPower) {\n    this.changeDetected = true;\n    this.changeLog.push(`<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a>: Power changed to \"${this.power}\" from \"${this.oldPower}\"`);\n    this.oldPower = this.power;\n  }\n\n  if (this.changeDetected) {\n      this.noChangeCount = 0;\n  } else {\n      // log that hook was called when there was no relevant change.\n      let count = this.noChangeCount += 1;\n      let noChangeMsg = `<a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a> called ${count}x when no change to hero or power`;\n      if (count === 1) {\n        // add new \"no change\" message\n        this.changeLog.push(noChangeMsg);\n      } else {\n        // update last \"no change\" message\n        this.changeLog[this.changeLog.length - 1] = noChangeMsg;\n      }\n  }\n\n  this.changeDetected = false;\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4806yrbm31qqc1me0zdvbgf0b\">此代码会检查某些 \n<em>感兴趣的值</em>，捕获并比较它们当前状态与先前值。 当 \n<code>hero</code> 或 \n<code>power</code> 没有实质性变化时，它会向日志写入一条特殊消息，这样你就可以看到 \n<code><a href=\"api/core/DoCheck\" class=\"code-anchor\">DoCheck</a></code> 被调用的频率。结果很明显：</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/do-check-anim.gif\" alt=\"DoCheck\" width=\"632\" height=\"588\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"adwum1hkkwb43vi5w3sqbmipc\">虽然 \n<code>ngDoCheck()</code> 钩子可以检测到英雄的 \n<code>name</code> 是否发生了变化，但它有一个可怕的代价。 此钩子会非常频繁地被调用——在 \n<em>每次</em> 更改检测周期之后，无论更改发生在哪里。 在本例中，在用户可以执行任何操作之前，它被调用了二十多次。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"eiv07l9xm9ksujntekxfy99hr\">这些初始检查中的大多数是由 Angular 对 \n<em>页面其他地方的无关数据</em> 的首次渲染触发的。 仅仅将鼠标移入另一个 \n<code>&lt;input&gt;</code> 就会触发调用。 相对较少的调用揭示了对相关数据的实际更改。 显然，我们的实现必须非常轻量级，否则用户体验会受到影响。</p>\n<a id=\"afterview\"></a>\n<h2 id=\"afterview\">AfterView</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"375soz64toe75utphh18ukb9b\"><em>AfterView</em> 示例探讨了 \n<code><a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>()</code> 和 \n<code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code> 钩子，Angular 会在 \n<em>创建组件的子视图</em> 之后调用它们。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"b6uyi1er1keu8ffbvoef99wzh\">这是一个子视图，它在 \n<code>&lt;input&gt;</code> 中显示英雄的名字。</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"child-view\" title=\"ChildComponent\" linenums=\"false\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-child-view',\n  template: '&lt;input [(<a href=\"api/forms/NgModel\" class=\"code-anchor\">ngModel</a>)]=\"hero\"&gt;'\n})\nexport class ChildViewComponent {\n  hero = 'Magneta';\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9efj1fvgzgxc3j34gthgaw71d\"><code>AfterViewComponent</code> 在其模板中显示此子视图。</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"template\" title=\"AfterViewComponent (template)\" linenums=\"false\">\ntemplate: `\n  &lt;div&gt;-- child view begins --&lt;/div&gt;\n    &lt;app-child-view&gt;&lt;/app-child-view&gt;\n  &lt;div&gt;-- child view ends --&lt;/div&gt;`\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ena1k9i2gtmgcj36qr2oe3m\">以下钩子根据子视图中值的改变采取行动，只能通过使用装饰了 \n<a href=\"api/core/ViewChild\">@ViewChild</a> 的属性查询子视图来访问。</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"hooks\" title=\"AfterViewComponent (class excerpts)\" linenums=\"false\">\nexport class AfterViewComponent implements  <a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>, <a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a> {\n  private prevHero = '';\n\n  // <a href=\"api/core/Query\" class=\"code-anchor\">Query</a> for <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> VIEW child of type `ChildViewComponent`\n  @<a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a>(ChildViewComponent) viewChild: ChildViewComponent;\n\n  ngAfterViewInit() {\n    // viewChild is set after the view has been initialized\n    this.logIt('<a href=\"api/core/AfterViewInit\" class=\"code-anchor\">AfterViewInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterViewChecked() {\n    // viewChild is updated after the view has been checked\n    if (this.prevHero === this.viewChild.hero) {\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a> (no change)');\n    } else {\n      this.prevHero = this.viewChild.hero;\n      this.logIt('<a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<a id=\"wait-a-tick\"></a>\n<h3 id=\"abide-by-the-unidirectional-data-flow-rule\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"4qexwkkyzs2j9uzpqq5a1ikud\"><i class=\"material-icons\">link</i>遵守单向数据流规则。</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2jusffdm4lwx8zp7qz8f0f3l\">当英雄名字超过 10 个字符时，\n<code>doSomething()</code> 方法会更新屏幕。</p>\n<code-example path=\"lifecycle-hooks/src/app/after-view.component.ts\" region=\"do-something\" title=\"AfterViewComponent (doSomething)\" linenums=\"false\">\n// This surrogate for real business logic sets the `comment`\nprivate doSomething() {\n  let c = this.viewChild.hero.length &gt; 10 ? `That's <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> long name` : '';\n  if (c !== this.comment) {\n    // Wait <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> <a href=\"api/core/testing/tick\" class=\"code-anchor\">tick</a> because the component's view has already been checked\n    this.logger.tick_then(() =&gt; this.comment = c);\n  }\n}\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"89k4h3pf6v56n2gh4lzufgl5h\">为什么 \n<code>doSomething()</code> 方法在更新 \n<code>comment</code> 之前要等待一个周期？</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d4ds9ollcfio0955neld44u5n\">Angular 的单向数据流规则禁止在视图组合后更新视图。 这两个钩子都在组件视图组合后触发。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"dvu64bf4olq8guk6ay96u18wz\">如果钩子立即更新组件的数据绑定 \n<code>comment</code> 属性，Angular 会抛出一个错误（试试看！）。 \n<code>LoggerService.tick_then()</code> 将日志更新推迟一个浏览器 JavaScript 周期，这足够长了。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"d2qa6bcznl0l73tu12zqui11a\">以下是 \n<em>AfterView</em> 的实际应用：</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/after-view-anim.gif\" alt=\"AfterView\" width=\"520\" height=\"532\">\n</figure>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"ds4sj5w1yfnejubngdyuq2ize\">注意，Angular 经常调用 \n<code><a href=\"api/core/AfterViewChecked\" class=\"code-anchor\">AfterViewChecked</a>()</code>，通常是在没有感兴趣的更改时。 编写精简的钩子方法以避免性能问题。</p>\n<a id=\"aftercontent\"></a>\n<h2 id=\"aftercontent\">AfterContent</h2>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6yid8vttdq5xtx6smpuy5itpb\"><em>AfterContent</em> 示例探讨了 \n<code><a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>()</code> 和 \n<code><a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>()</code> 钩子，Angular 在将外部内容投影到组件后调用这些钩子。</p>\n<a id=\"content-projection\"></a>\n<h3 id=\"content-projection\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"989mo7z4iqxffwo989mz2d05n\"><i class=\"material-icons\">link</i>内容投影</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"f1p07cvigrdz6z4cazxrcryo6\"><em>内容投影</em> 是一种从组件外部导入 HTML 内容并将该内容插入到组件模板中指定位置的方法。</p>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"8z46z1m3fkjzk063skusxf1qr\">AngularJS 开发人员将此技术称为 \n<em>transclusion</em>。</p>\n</div>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cscb6llzknp0glv0vhtpoyzem\">考虑对 \n<a href=\"guide/lifecycle-hooks#afterview\">之前的 <em>AfterView</em></a> 示例进行以下修改。 这次，不是将子视图包含在模板中，而是从 \n<code>AfterContentComponent</code> 的父组件导入内容。以下是父组件的模板：</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"parent-template\" title=\"AfterContentParentComponent (template excerpt)\" linenums=\"false\">\n`&lt;after-content&gt;\n   &lt;app-child&gt;&lt;/app-child&gt;\n &lt;/after-content&gt;`\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1gyasrg6iz55hpps1xxzimgfb\">注意，\n<code>&lt;my-child&gt;</code> 标签位于 \n<code>&lt;after-content&gt;</code> 标签之间。 永远不要在组件元素标签之间放置内容，\n<em>除非你打算将该内容投影到组件中</em>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cn5hzbr4cz11y0ix6k3h6z5qc\">现在看看组件的模板：</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"template\" title=\"AfterContentComponent (template)\" linenums=\"false\">\ntemplate: `\n  &lt;div&gt;-- projected content begins --&lt;/div&gt;\n    &lt;ng-content&gt;&lt;/ng-content&gt;\n  &lt;div&gt;-- projected content ends --&lt;/div&gt;`\n\n</code-example>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"1ly3rtwm3cjvsmz349lzdgj7s\"><code>&lt;ng-content&gt;</code> 标签是外部内容的 \n<em>占位符</em>。 它告诉 Angular 在哪里插入该内容。 在本例中，投影的内容是来自父组件的 \n<code>&lt;my-child&gt;</code>。</p>\n<figure>\n  <img src=\"generated/images/guide/lifecycle-hooks/projected-child-view.png\" alt=\"Projected Content\" width=\"230\" height=\"89\">\n</figure>\n<div class=\"l-sub-section\">\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"7sf0d5l2pwmh8ozn8ggcfvxaz\"><em>内容投影</em> 的明显特征有两个：</p>\n<ul>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"mjoacfg8idsdl820x4rtw3r4\">组件元素标签之间的 HTML。</li>\n<li data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6te7ue106fmox55vltyk4u0uv\">组件模板中 \n<code>&lt;ng-content&gt;</code> 标签的存在。</li>\n</ul>\n</div>\n<a id=\"aftercontent-hooks\"></a>\n<h3 id=\"aftercontent-hooks\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cz1u3fu0iwdkk6sqm4ocpcow9\"><i class=\"material-icons\">link</i>AfterContent 钩子</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"iljw1k4lbqmcyx53xu0vd0vi\"><em>AfterContent</em> 钩子类似于 \n<em>AfterView</em> 钩子。 关键区别在于子组件。</p>\n<ul>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"cc0go160jhv9e37rqq2at7esp\"><em>AfterView</em> 钩子关注 \n<code><a href=\"api/core/ViewChildren\" class=\"code-anchor\">ViewChildren</a></code>，即元素标签 出现在组件模板中的子组件。</p>\n</li>\n<li>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"6zox5y4llr4sdmh3cnzgigv3r\"><em>AfterContent</em> 钩子关注 \n<code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code>，即 Angular 投影到组件中的子组件。</p>\n</li>\n</ul>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9cn3a1q4of16n29fwiu53xryu\">以下 \n<em>AfterContent</em> 钩子根据内容子组件中值的改变采取行动， 只能通过使用装饰了 \n<a href=\"api/core/ContentChild\">@ContentChild</a> 的属性查询它们来访问。</p>\n<code-example path=\"lifecycle-hooks/src/app/after-content.component.ts\" region=\"hooks\" title=\"AfterContentComponent (class excerpts)\" linenums=\"false\">\nexport class AfterContentComponent implements <a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>, <a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a> {\n  private prevHero = '';\n  comment = '';\n\n  // <a href=\"api/core/Query\" class=\"code-anchor\">Query</a> for <a href=\"api/router/RouterLinkWithHref\" class=\"code-anchor\">a</a> CONTENT child of type `ChildComponent`\n  @<a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a>(ChildComponent) contentChild: ChildComponent;\n\n  ngAfterContentInit() {\n    // contentChild is set after the content has been initialized\n    this.logIt('<a href=\"api/core/AfterContentInit\" class=\"code-anchor\">AfterContentInit</a>');\n    this.doSomething();\n  }\n\n  ngAfterContentChecked() {\n    // contentChild is updated after the content has been checked\n    if (this.prevHero === this.contentChild.hero) {\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a> (no change)');\n    } else {\n      this.prevHero = this.contentChild.hero;\n      this.logIt('<a href=\"api/core/AfterContentChecked\" class=\"code-anchor\">AfterContentChecked</a>');\n      this.doSomething();\n    }\n  }\n  // ...\n}\n\n</code-example>\n<a id=\"no-unidirectional-flow-worries\"></a>\n<h3 id=\"no-unidirectional-flow-worries-with-aftercontent\" data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"axkb8d06pk0i8czmzzrjbboxo\"><i class=\"material-icons\">link</i><em>AfterContent</em> 没有单向数据流的担忧</h3>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"3j0jnmewdyaczk6taoc20k2c3\">此组件的 \n<code>doSomething()</code> 方法立即更新组件的数据绑定 \n<code>comment</code> 属性。 不需要 \n<a href=\"guide/lifecycle-hooks#wait-a-tick\">等待</a>。</p>\n<p data-ng_translator_product=\"100\" data-ng_translator_ref_id=\"9nqm9dimxfrbhmfiynt0v83t7\">回想一下，Angular 在调用任何 \n<em>AfterView</em> 钩子之前都会调用 \n<em>AfterContent</em> 钩子。 Angular 在完成此组件视图的组合之前，会完成投影内容的组合。 在 \n<code>AfterContent...</code> 和 \n<code>AfterView...</code> 钩子之间有一个小窗口可以修改宿主视图。</p>\n\n</div>\n<!-- links to this doc:\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/DoCheck\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - guide/architecture-components\n - guide/architecture-next-steps\n - guide/change-log\n - guide/component-interaction\n - guide/glossary\n - guide/reactive-forms\n - guide/testing\n - guide/upgrade\n - tutorial/toh-pt1\n - tutorial/toh-pt4\n - tutorial/toh-pt5\n-->\n<!-- links from this doc:\n - api/common/NgForOf\n - api/core/AfterContentChecked\n - api/core/AfterContentInit\n - api/core/AfterViewChecked\n - api/core/AfterViewInit\n - api/core/Component\n - api/core/ContentChild\n - api/core/ContentChildren\n - api/core/Directive\n - api/core/DoCheck\n - api/core/Input\n - api/core/OnChanges\n - api/core/OnDestroy\n - api/core/OnInit\n - api/core/Query\n - api/core/SimpleChange\n - api/core/SimpleChanges\n - api/core/ViewChild\n - api/core/ViewChildren\n - api/core/testing/tick\n - api/forms/NgModel\n - api/router/RouterLinkWithHref\n - guide/lifecycle-hooks#abide-by-the-unidirectional-data-flow-rule\n - guide/lifecycle-hooks#aftercontent\n - guide/lifecycle-hooks#aftercontent-hooks\n - guide/lifecycle-hooks#afterview\n - guide/lifecycle-hooks#component-lifecycle-hooks-overview\n - guide/lifecycle-hooks#content-projection\n - guide/lifecycle-hooks#docheck\n - guide/lifecycle-hooks#interfaces-are-optional-technically\n - guide/lifecycle-hooks#lifecycle-examples\n - guide/lifecycle-hooks#lifecycle-hooks\n - guide/lifecycle-hooks#lifecycle-sequence\n - guide/lifecycle-hooks#no-unidirectional-flow-worries-with-aftercontent\n - guide/lifecycle-hooks#onchanges\n - guide/lifecycle-hooks#ondestroy\n - guide/lifecycle-hooks#oninit\n - guide/lifecycle-hooks#other-angular-lifecycle-hooks\n - guide/lifecycle-hooks#peek-a-boo\n - guide/lifecycle-hooks#peek-a-boo-all-hooks\n - guide/lifecycle-hooks#spy\n - guide/lifecycle-hooks#spying-oninit-and-ondestroy\n - guide/lifecycle-hooks#wait-a-tick\n - tutorial/toh-pt4#oninit\n - http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/\n-->"
}